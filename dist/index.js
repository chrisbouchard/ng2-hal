/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(258);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	/**
	 * @module
	 * @description
	 * Entry point from which you should import all public core APIs.
	 */
	__export(__webpack_require__(158));
	__export(__webpack_require__(228));
	__export(__webpack_require__(12));
	var application_ref_1 = __webpack_require__(87);
	exports.createPlatform = application_ref_1.createPlatform;
	exports.assertPlatform = application_ref_1.assertPlatform;
	exports.disposePlatform = application_ref_1.disposePlatform;
	exports.getPlatform = application_ref_1.getPlatform;
	exports.coreBootstrap = application_ref_1.coreBootstrap;
	exports.coreLoadAndBootstrap = application_ref_1.coreLoadAndBootstrap;
	exports.PlatformRef = application_ref_1.PlatformRef;
	exports.ApplicationRef = application_ref_1.ApplicationRef;
	exports.enableProdMode = application_ref_1.enableProdMode;
	exports.lockRunMode = application_ref_1.lockRunMode;
	exports.isDevMode = application_ref_1.isDevMode;
	exports.createPlatformFactory = application_ref_1.createPlatformFactory;
	var application_tokens_1 = __webpack_require__(47);
	exports.APP_ID = application_tokens_1.APP_ID;
	exports.PACKAGE_ROOT_URL = application_tokens_1.PACKAGE_ROOT_URL;
	exports.PLATFORM_INITIALIZER = application_tokens_1.PLATFORM_INITIALIZER;
	exports.APP_BOOTSTRAP_LISTENER = application_tokens_1.APP_BOOTSTRAP_LISTENER;
	var application_init_1 = __webpack_require__(86);
	exports.APP_INITIALIZER = application_init_1.APP_INITIALIZER;
	exports.ApplicationInitStatus = application_init_1.ApplicationInitStatus;
	__export(__webpack_require__(229));
	__export(__webpack_require__(227));
	__export(__webpack_require__(216));
	var debug_node_1 = __webpack_require__(145);
	exports.DebugElement = debug_node_1.DebugElement;
	exports.DebugNode = debug_node_1.DebugNode;
	exports.asNativeElements = debug_node_1.asNativeElements;
	exports.getDebugNode = debug_node_1.getDebugNode;
	__export(__webpack_require__(100));
	__export(__webpack_require__(211));
	__export(__webpack_require__(224));
	__export(__webpack_require__(223));
	var application_module_1 = __webpack_require__(210);
	exports.APPLICATION_COMMON_PROVIDERS = application_module_1.APPLICATION_COMMON_PROVIDERS;
	exports.ApplicationModule = application_module_1.ApplicationModule;
	var profile_1 = __webpack_require__(57);
	exports.wtfCreateScope = profile_1.wtfCreateScope;
	exports.wtfLeave = profile_1.wtfLeave;
	exports.wtfStartTimeRange = profile_1.wtfStartTimeRange;
	exports.wtfEndTimeRange = profile_1.wtfEndTimeRange;
	var lang_1 = __webpack_require__(2);
	exports.Type = lang_1.Type;
	var async_1 = __webpack_require__(93);
	exports.EventEmitter = async_1.EventEmitter;
	var exceptions_1 = __webpack_require__(4);
	exports.ExceptionHandler = exceptions_1.ExceptionHandler;
	exports.WrappedException = exceptions_1.WrappedException;
	exports.BaseException = exceptions_1.BaseException;
	__export(__webpack_require__(204));
	__export(__webpack_require__(141));
	var animation_player_1 = __webpack_require__(85);
	exports.AnimationPlayer = animation_player_1.AnimationPlayer;
	var security_1 = __webpack_require__(166);
	exports.SanitizationService = security_1.SanitizationService;
	exports.SecurityContext = security_1.SecurityContext;
	//# sourceMappingURL=index.js.map

/***/ },
/* 2 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var globalScope;
	if (typeof window === 'undefined') {
	    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	        globalScope = self;
	    }
	    else {
	        globalScope = global;
	    }
	}
	else {
	    globalScope = window;
	}
	function scheduleMicroTask(fn) {
	    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
	}
	exports.scheduleMicroTask = scheduleMicroTask;
	// Need to declare a new variable for global here since TypeScript
	// exports the original value of the symbol.
	var _global = globalScope;
	exports.global = _global;
	/**
	 * Runtime representation a type that a Component or other object is instances of.
	 *
	 * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
	 * the `MyCustomComponent` constructor function.
	 *
	 * @stable
	 */
	exports.Type = Function;
	function getTypeNameForDebugging(type) {
	    if (type['name']) {
	        return type['name'];
	    }
	    return typeof type;
	}
	exports.getTypeNameForDebugging = getTypeNameForDebugging;
	exports.Math = _global.Math;
	exports.Date = _global.Date;
	// TODO: remove calls to assert in production environment
	// Note: Can't just export this and import in in other files
	// as `assert` is a reserved keyword in Dart
	_global.assert = function assert(condition) {
	    // TODO: to be fixed properly via #2830, noop for now
	};
	function isPresent(obj) {
	    return obj !== undefined && obj !== null;
	}
	exports.isPresent = isPresent;
	function isBlank(obj) {
	    return obj === undefined || obj === null;
	}
	exports.isBlank = isBlank;
	function isBoolean(obj) {
	    return typeof obj === 'boolean';
	}
	exports.isBoolean = isBoolean;
	function isNumber(obj) {
	    return typeof obj === 'number';
	}
	exports.isNumber = isNumber;
	function isString(obj) {
	    return typeof obj === 'string';
	}
	exports.isString = isString;
	function isFunction(obj) {
	    return typeof obj === 'function';
	}
	exports.isFunction = isFunction;
	function isType(obj) {
	    return isFunction(obj);
	}
	exports.isType = isType;
	function isStringMap(obj) {
	    return typeof obj === 'object' && obj !== null;
	}
	exports.isStringMap = isStringMap;
	var STRING_MAP_PROTO = Object.getPrototypeOf({});
	function isStrictStringMap(obj) {
	    return isStringMap(obj) && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
	}
	exports.isStrictStringMap = isStrictStringMap;
	function isPromise(obj) {
	    // allow any Promise/A+ compliant thenable.
	    // It's up to the caller to ensure that obj.then conforms to the spec
	    return isPresent(obj) && isFunction(obj.then);
	}
	exports.isPromise = isPromise;
	function isArray(obj) {
	    return Array.isArray(obj);
	}
	exports.isArray = isArray;
	function isDate(obj) {
	    return obj instanceof exports.Date && !isNaN(obj.valueOf());
	}
	exports.isDate = isDate;
	function noop() { }
	exports.noop = noop;
	function stringify(token) {
	    if (typeof token === 'string') {
	        return token;
	    }
	    if (token === undefined || token === null) {
	        return '' + token;
	    }
	    if (token.overriddenName) {
	        return token.overriddenName;
	    }
	    if (token.name) {
	        return token.name;
	    }
	    var res = token.toString();
	    var newLineIndex = res.indexOf('\n');
	    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
	}
	exports.stringify = stringify;
	// serialize / deserialize enum exist only for consistency with dart API
	// enums in typescript don't need to be serialized
	function serializeEnum(val) {
	    return val;
	}
	exports.serializeEnum = serializeEnum;
	function deserializeEnum(val, values) {
	    return val;
	}
	exports.deserializeEnum = deserializeEnum;
	function resolveEnumToken(enumValue, val) {
	    return enumValue[val];
	}
	exports.resolveEnumToken = resolveEnumToken;
	var StringWrapper = (function () {
	    function StringWrapper() {
	    }
	    StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };
	    StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };
	    StringWrapper.split = function (s, regExp) { return s.split(regExp); };
	    StringWrapper.equals = function (s, s2) { return s === s2; };
	    StringWrapper.stripLeft = function (s, charVal) {
	        if (s && s.length) {
	            var pos = 0;
	            for (var i = 0; i < s.length; i++) {
	                if (s[i] != charVal)
	                    break;
	                pos++;
	            }
	            s = s.substring(pos);
	        }
	        return s;
	    };
	    StringWrapper.stripRight = function (s, charVal) {
	        if (s && s.length) {
	            var pos = s.length;
	            for (var i = s.length - 1; i >= 0; i--) {
	                if (s[i] != charVal)
	                    break;
	                pos--;
	            }
	            s = s.substring(0, pos);
	        }
	        return s;
	    };
	    StringWrapper.replace = function (s, from, replace) {
	        return s.replace(from, replace);
	    };
	    StringWrapper.replaceAll = function (s, from, replace) {
	        return s.replace(from, replace);
	    };
	    StringWrapper.slice = function (s, from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = null; }
	        return s.slice(from, to === null ? undefined : to);
	    };
	    StringWrapper.replaceAllMapped = function (s, from, cb) {
	        return s.replace(from, function () {
	            var matches = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                matches[_i - 0] = arguments[_i];
	            }
	            // Remove offset & string from the result array
	            matches.splice(-2, 2);
	            // The callback receives match, p1, ..., pn
	            return cb(matches);
	        });
	    };
	    StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };
	    StringWrapper.compare = function (a, b) {
	        if (a < b) {
	            return -1;
	        }
	        else if (a > b) {
	            return 1;
	        }
	        else {
	            return 0;
	        }
	    };
	    return StringWrapper;
	}());
	exports.StringWrapper = StringWrapper;
	var StringJoiner = (function () {
	    function StringJoiner(parts) {
	        if (parts === void 0) { parts = []; }
	        this.parts = parts;
	    }
	    StringJoiner.prototype.add = function (part) { this.parts.push(part); };
	    StringJoiner.prototype.toString = function () { return this.parts.join(''); };
	    return StringJoiner;
	}());
	exports.StringJoiner = StringJoiner;
	var NumberParseError = (function (_super) {
	    __extends(NumberParseError, _super);
	    function NumberParseError(message) {
	        _super.call(this);
	        this.message = message;
	    }
	    NumberParseError.prototype.toString = function () { return this.message; };
	    return NumberParseError;
	}(Error));
	exports.NumberParseError = NumberParseError;
	var NumberWrapper = (function () {
	    function NumberWrapper() {
	    }
	    NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
	    NumberWrapper.equal = function (a, b) { return a === b; };
	    NumberWrapper.parseIntAutoRadix = function (text) {
	        var result = parseInt(text);
	        if (isNaN(result)) {
	            throw new NumberParseError('Invalid integer literal when parsing ' + text);
	        }
	        return result;
	    };
	    NumberWrapper.parseInt = function (text, radix) {
	        if (radix == 10) {
	            if (/^(\-|\+)?[0-9]+$/.test(text)) {
	                return parseInt(text, radix);
	            }
	        }
	        else if (radix == 16) {
	            if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
	                return parseInt(text, radix);
	            }
	        }
	        else {
	            var result = parseInt(text, radix);
	            if (!isNaN(result)) {
	                return result;
	            }
	        }
	        throw new NumberParseError('Invalid integer literal when parsing ' + text + ' in base ' + radix);
	    };
	    // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.
	    NumberWrapper.parseFloat = function (text) { return parseFloat(text); };
	    Object.defineProperty(NumberWrapper, "NaN", {
	        get: function () { return NaN; },
	        enumerable: true,
	        configurable: true
	    });
	    NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };
	    NumberWrapper.isNaN = function (value) { return isNaN(value); };
	    NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
	    return NumberWrapper;
	}());
	exports.NumberWrapper = NumberWrapper;
	exports.RegExp = _global.RegExp;
	var FunctionWrapper = (function () {
	    function FunctionWrapper() {
	    }
	    FunctionWrapper.apply = function (fn, posArgs) { return fn.apply(null, posArgs); };
	    FunctionWrapper.bind = function (fn, scope) { return fn.bind(scope); };
	    return FunctionWrapper;
	}());
	exports.FunctionWrapper = FunctionWrapper;
	// JS has NaN !== NaN
	function looseIdentical(a, b) {
	    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
	}
	exports.looseIdentical = looseIdentical;
	// JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)
	// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
	function getMapKey(value) {
	    return value;
	}
	exports.getMapKey = getMapKey;
	function normalizeBlank(obj) {
	    return isBlank(obj) ? null : obj;
	}
	exports.normalizeBlank = normalizeBlank;
	function normalizeBool(obj) {
	    return isBlank(obj) ? false : obj;
	}
	exports.normalizeBool = normalizeBool;
	function isJsObject(o) {
	    return o !== null && (typeof o === 'function' || typeof o === 'object');
	}
	exports.isJsObject = isJsObject;
	function print(obj) {
	    console.log(obj);
	}
	exports.print = print;
	function warn(obj) {
	    console.warn(obj);
	}
	exports.warn = warn;
	// Can't be all uppercase as our transpiler would think it is a special directive...
	var Json = (function () {
	    function Json() {
	    }
	    Json.parse = function (s) { return _global.JSON.parse(s); };
	    Json.stringify = function (data) {
	        // Dart doesn't take 3 arguments
	        return _global.JSON.stringify(data, null, 2);
	    };
	    return Json;
	}());
	exports.Json = Json;
	var DateWrapper = (function () {
	    function DateWrapper() {
	    }
	    DateWrapper.create = function (year, month, day, hour, minutes, seconds, milliseconds) {
	        if (month === void 0) { month = 1; }
	        if (day === void 0) { day = 1; }
	        if (hour === void 0) { hour = 0; }
	        if (minutes === void 0) { minutes = 0; }
	        if (seconds === void 0) { seconds = 0; }
	        if (milliseconds === void 0) { milliseconds = 0; }
	        return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
	    };
	    DateWrapper.fromISOString = function (str) { return new exports.Date(str); };
	    DateWrapper.fromMillis = function (ms) { return new exports.Date(ms); };
	    DateWrapper.toMillis = function (date) { return date.getTime(); };
	    DateWrapper.now = function () { return new exports.Date(); };
	    DateWrapper.toJson = function (date) { return date.toJSON(); };
	    return DateWrapper;
	}());
	exports.DateWrapper = DateWrapper;
	function setValueOnPath(global, path, value) {
	    var parts = path.split('.');
	    var obj = global;
	    while (parts.length > 1) {
	        var name = parts.shift();
	        if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
	            obj = obj[name];
	        }
	        else {
	            obj = obj[name] = {};
	        }
	    }
	    if (obj === undefined || obj === null) {
	        obj = {};
	    }
	    obj[parts.shift()] = value;
	}
	exports.setValueOnPath = setValueOnPath;
	var _symbolIterator = null;
	function getSymbolIterator() {
	    if (isBlank(_symbolIterator)) {
	        if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
	            _symbolIterator = Symbol.iterator;
	        }
	        else {
	            // es6-shim specific logic
	            var keys = Object.getOwnPropertyNames(Map.prototype);
	            for (var i = 0; i < keys.length; ++i) {
	                var key = keys[i];
	                if (key !== 'entries' && key !== 'size' &&
	                    Map.prototype[key] === Map.prototype['entries']) {
	                    _symbolIterator = key;
	                }
	            }
	        }
	    }
	    return _symbolIterator;
	}
	exports.getSymbolIterator = getSymbolIterator;
	function evalExpression(sourceUrl, expr, declarations, vars) {
	    var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
	    var fnArgNames = [];
	    var fnArgValues = [];
	    for (var argName in vars) {
	        fnArgNames.push(argName);
	        fnArgValues.push(vars[argName]);
	    }
	    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
	}
	exports.evalExpression = evalExpression;
	function isPrimitive(obj) {
	    return !isJsObject(obj);
	}
	exports.isPrimitive = isPrimitive;
	function hasConstructor(value, type) {
	    return value.constructor === type;
	}
	exports.hasConstructor = hasConstructor;
	function escape(s) {
	    return _global.encodeURI(s);
	}
	exports.escape = escape;
	function escapeRegExp(s) {
	    return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
	}
	exports.escapeRegExp = escapeRegExp;
	//# sourceMappingURL=lang.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
2,
/* 4 */
[295, 148, 149, 149],
/* 5 */
2,
/* 6 */
[293, 2],
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(5);
	var _DOM = null;
	function getDOM() {
	    return _DOM;
	}
	exports.getDOM = getDOM;
	function setDOM(adapter) {
	    _DOM = adapter;
	}
	exports.setDOM = setDOM;
	function setRootDomAdapter(adapter) {
	    if (lang_1.isBlank(_DOM)) {
	        _DOM = adapter;
	    }
	}
	exports.setRootDomAdapter = setRootDomAdapter;
	/* tslint:disable:requireParameterType */
	/**
	 * Provides DOM operations in an environment-agnostic way.
	 */
	var DomAdapter = (function () {
	    function DomAdapter() {
	        this.xhrType = null;
	    }
	    /** @deprecated */
	    DomAdapter.prototype.getXHR = function () { return this.xhrType; };
	    Object.defineProperty(DomAdapter.prototype, "attrToPropMap", {
	        /**
	         * Maps attribute names to their corresponding property names for cases
	         * where attribute name doesn't match property name.
	         */
	        get: function () { return this._attrToPropMap; },
	        set: function (value) { this._attrToPropMap = value; },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    ;
	    return DomAdapter;
	}());
	exports.DomAdapter = DomAdapter;
	//# sourceMappingURL=dom_adapter.js.map

/***/ },
/* 8 */
[293, 5],
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var _slice = Array.prototype.slice;

	var _createDecoratedClass = (function () { function defineProperties(target, descriptors, initializers) { for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } if (descriptor.initializer !== undefined) { initializers[key] = descriptor; continue; } } Object.defineProperty(target, key, descriptor); } } return function (Constructor, protoProps, staticProps, protoInitializers, staticInitializers) { if (protoProps) defineProperties(Constructor.prototype, protoProps, protoInitializers); if (staticProps) defineProperties(Constructor, staticProps, staticInitializers); return Constructor; }; })();

	exports.isDescriptor = isDescriptor;
	exports.decorate = decorate;
	exports.metaFor = metaFor;
	exports.getOwnPropertyDescriptors = getOwnPropertyDescriptors;
	exports.createDefaultSetter = createDefaultSetter;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _defineDecoratedPropertyDescriptor(target, key, descriptors) { var _descriptor = descriptors[key]; if (!_descriptor) return; var descriptor = {}; for (var _key in _descriptor) descriptor[_key] = _descriptor[_key]; descriptor.value = descriptor.initializer ? descriptor.initializer.call(target) : undefined; Object.defineProperty(target, key, descriptor); }

	var _lazyInitialize = __webpack_require__(193);

	var _lazyInitialize2 = _interopRequireDefault(_lazyInitialize);

	var defineProperty = Object.defineProperty;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	var getOwnPropertyNames = Object.getOwnPropertyNames;
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;

	function isDescriptor(desc) {
	  if (!desc || !desc.hasOwnProperty) {
	    return false;
	  }

	  var keys = ['value', 'initializer', 'get', 'set'];

	  for (var i = 0, l = keys.length; i < l; i++) {
	    if (desc.hasOwnProperty(keys[i])) {
	      return true;
	    }
	  }

	  return false;
	}

	function decorate(handleDescriptor, entryArgs) {
	  if (isDescriptor(entryArgs[entryArgs.length - 1])) {
	    return handleDescriptor.apply(undefined, _toConsumableArray(entryArgs).concat([[]]));
	  } else {
	    return function () {
	      return handleDescriptor.apply(undefined, _slice.call(arguments).concat([entryArgs]));
	    };
	  }
	}

	var Meta = (function () {
	  var _instanceInitializers = {};

	  function Meta() {
	    _classCallCheck(this, Meta);

	    _defineDecoratedPropertyDescriptor(this, 'debounceTimeoutIds', _instanceInitializers);

	    _defineDecoratedPropertyDescriptor(this, 'throttleTimeoutIds', _instanceInitializers);

	    _defineDecoratedPropertyDescriptor(this, 'throttlePreviousTimestamps', _instanceInitializers);
	  }

	  _createDecoratedClass(Meta, [{
	    key: 'debounceTimeoutIds',
	    decorators: [_lazyInitialize2['default']],
	    initializer: function initializer() {
	      return {};
	    },
	    enumerable: true
	  }, {
	    key: 'throttleTimeoutIds',
	    decorators: [_lazyInitialize2['default']],
	    initializer: function initializer() {
	      return {};
	    },
	    enumerable: true
	  }, {
	    key: 'throttlePreviousTimestamps',
	    decorators: [_lazyInitialize2['default']],
	    initializer: function initializer() {
	      return {};
	    },
	    enumerable: true
	  }], null, _instanceInitializers);

	  return Meta;
	})();

	var META_KEY = typeof Symbol === 'function' ? Symbol('__core_decorators__') : '__core_decorators__';

	function metaFor(obj) {
	  if (obj.hasOwnProperty(META_KEY) === false) {
	    defineProperty(obj, META_KEY, {
	      // Defaults: NOT enumerable, configurable, or writable
	      value: new Meta()
	    });
	  }

	  return obj[META_KEY];
	}

	var getOwnKeys = getOwnPropertySymbols ? function (object) {
	  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
	} : getOwnPropertyNames;

	exports.getOwnKeys = getOwnKeys;

	function getOwnPropertyDescriptors(obj) {
	  var descs = {};

	  getOwnKeys(obj).forEach(function (key) {
	    return descs[key] = getOwnPropertyDescriptor(obj, key);
	  });

	  return descs;
	}

	function createDefaultSetter(key) {
	  return function set(newValue) {
	    Object.defineProperty(this, key, {
	      configurable: true,
	      writable: true,
	      // IS enumerable when reassigned by the outside word
	      enumerable: true,
	      value: newValue
	    });

	    return newValue;
	  };
	}

/***/ },
/* 10 */
[293, 3],
/* 11 */
2,
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	/**
	 * @module
	 * @description
	 * The `di` module provides dependency injection container services.
	 */
	var metadata_1 = __webpack_require__(22);
	exports.HostMetadata = metadata_1.HostMetadata;
	exports.InjectMetadata = metadata_1.InjectMetadata;
	exports.InjectableMetadata = metadata_1.InjectableMetadata;
	exports.OptionalMetadata = metadata_1.OptionalMetadata;
	exports.SelfMetadata = metadata_1.SelfMetadata;
	exports.SkipSelfMetadata = metadata_1.SkipSelfMetadata;
	// we have to reexport * because Dart and TS export two different sets of types
	__export(__webpack_require__(30));
	var forward_ref_1 = __webpack_require__(52);
	exports.forwardRef = forward_ref_1.forwardRef;
	exports.resolveForwardRef = forward_ref_1.resolveForwardRef;
	var injector_1 = __webpack_require__(53);
	exports.Injector = injector_1.Injector;
	var reflective_injector_1 = __webpack_require__(214);
	exports.ReflectiveInjector = reflective_injector_1.ReflectiveInjector;
	var provider_1 = __webpack_require__(89);
	exports.Binding = provider_1.Binding;
	exports.ProviderBuilder = provider_1.ProviderBuilder;
	exports.bind = provider_1.bind;
	exports.Provider = provider_1.Provider;
	exports.provide = provider_1.provide;
	var reflective_provider_1 = __webpack_require__(92);
	exports.ResolvedReflectiveFactory = reflective_provider_1.ResolvedReflectiveFactory;
	var reflective_key_1 = __webpack_require__(91);
	exports.ReflectiveKey = reflective_key_1.ReflectiveKey;
	var reflective_exceptions_1 = __webpack_require__(90);
	exports.NoProviderError = reflective_exceptions_1.NoProviderError;
	exports.AbstractProviderError = reflective_exceptions_1.AbstractProviderError;
	exports.CyclicDependencyError = reflective_exceptions_1.CyclicDependencyError;
	exports.InstantiationError = reflective_exceptions_1.InstantiationError;
	exports.InvalidProviderError = reflective_exceptions_1.InvalidProviderError;
	exports.NoAnnotationError = reflective_exceptions_1.NoAnnotationError;
	exports.OutOfBoundsError = reflective_exceptions_1.OutOfBoundsError;
	var opaque_token_1 = __webpack_require__(146);
	exports.OpaqueToken = opaque_token_1.OpaqueToken;
	//# sourceMappingURL=di.js.map

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	/**
	 * Used to provide a {@link ControlValueAccessor} for form controls.
	 *
	 * See {@link DefaultValueAccessor} for how to implement one.
	 * @experimental
	 */
	exports.NG_VALUE_ACCESSOR = new core_1.OpaqueToken('NgValueAccessor');
	//# sourceMappingURL=control_value_accessor.js.map

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var core_private_1 = __webpack_require__(34);
	var exceptions_1 = __webpack_require__(19);
	var lang_1 = __webpack_require__(5);
	var render_store_1 = __webpack_require__(37);
	var serialized_types_1 = __webpack_require__(109);
	// PRIMITIVE is any type that does not need to be serialized (string, number, boolean)
	// We set it to String so that it is considered a Type.
	/**
	 * @experimental WebWorker support in Angular is currently experimental.
	 */
	exports.PRIMITIVE = String;
	var Serializer = (function () {
	    function Serializer(_renderStore) {
	        this._renderStore = _renderStore;
	    }
	    Serializer.prototype.serialize = function (obj, type) {
	        var _this = this;
	        if (!lang_1.isPresent(obj)) {
	            return null;
	        }
	        if (lang_1.isArray(obj)) {
	            return obj.map(function (v) { return _this.serialize(v, type); });
	        }
	        if (type == exports.PRIMITIVE) {
	            return obj;
	        }
	        if (type == RenderStoreObject) {
	            return this._renderStore.serialize(obj);
	        }
	        else if (type === core_1.RenderComponentType) {
	            return this._serializeRenderComponentType(obj);
	        }
	        else if (type === core_1.ViewEncapsulation) {
	            return lang_1.serializeEnum(obj);
	        }
	        else if (type === serialized_types_1.LocationType) {
	            return this._serializeLocation(obj);
	        }
	        else {
	            throw new exceptions_1.BaseException('No serializer for ' + type.toString());
	        }
	    };
	    Serializer.prototype.deserialize = function (map, type, data) {
	        var _this = this;
	        if (!lang_1.isPresent(map)) {
	            return null;
	        }
	        if (lang_1.isArray(map)) {
	            var obj = [];
	            map.forEach(function (val) { return obj.push(_this.deserialize(val, type, data)); });
	            return obj;
	        }
	        if (type == exports.PRIMITIVE) {
	            return map;
	        }
	        if (type == RenderStoreObject) {
	            return this._renderStore.deserialize(map);
	        }
	        else if (type === core_1.RenderComponentType) {
	            return this._deserializeRenderComponentType(map);
	        }
	        else if (type === core_1.ViewEncapsulation) {
	            return core_private_1.VIEW_ENCAPSULATION_VALUES[map];
	        }
	        else if (type === serialized_types_1.LocationType) {
	            return this._deserializeLocation(map);
	        }
	        else {
	            throw new exceptions_1.BaseException('No deserializer for ' + type.toString());
	        }
	    };
	    Serializer.prototype._serializeLocation = function (loc) {
	        return {
	            'href': loc.href,
	            'protocol': loc.protocol,
	            'host': loc.host,
	            'hostname': loc.hostname,
	            'port': loc.port,
	            'pathname': loc.pathname,
	            'search': loc.search,
	            'hash': loc.hash,
	            'origin': loc.origin
	        };
	    };
	    Serializer.prototype._deserializeLocation = function (loc) {
	        return new serialized_types_1.LocationType(loc['href'], loc['protocol'], loc['host'], loc['hostname'], loc['port'], loc['pathname'], loc['search'], loc['hash'], loc['origin']);
	    };
	    Serializer.prototype._serializeRenderComponentType = function (obj) {
	        return {
	            'id': obj.id,
	            'templateUrl': obj.templateUrl,
	            'slotCount': obj.slotCount,
	            'encapsulation': this.serialize(obj.encapsulation, core_1.ViewEncapsulation),
	            'styles': this.serialize(obj.styles, exports.PRIMITIVE)
	        };
	    };
	    Serializer.prototype._deserializeRenderComponentType = function (map) {
	        return new core_1.RenderComponentType(map['id'], map['templateUrl'], map['slotCount'], this.deserialize(map['encapsulation'], core_1.ViewEncapsulation), this.deserialize(map['styles'], exports.PRIMITIVE), {});
	    };
	    /** @nocollapse */
	    Serializer.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    Serializer.ctorParameters = [
	        { type: render_store_1.RenderStore, },
	    ];
	    return Serializer;
	}());
	exports.Serializer = Serializer;
	var RenderStoreObject = (function () {
	    function RenderStoreObject() {
	    }
	    return RenderStoreObject;
	}());
	exports.RenderStoreObject = RenderStoreObject;
	//# sourceMappingURL=serializer.js.map

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var toPromise_1 = __webpack_require__(282);
	var collection_1 = __webpack_require__(10);
	var lang_1 = __webpack_require__(3);
	/**
	 * Providers for validators to be used for {@link Control}s in a form.
	 *
	 * Provide this using `multi: true` to add validators.
	 *
	 * ### Example
	 *
	 * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}
	 * @experimental
	 */
	exports.NG_VALIDATORS = new core_1.OpaqueToken('NgValidators');
	/**
	 * Providers for asynchronous validators to be used for {@link Control}s
	 * in a form.
	 *
	 * Provide this using `multi: true` to add validators.
	 *
	 * See {@link NG_VALIDATORS} for more details.
	 *
	 * @experimental
	 */
	exports.NG_ASYNC_VALIDATORS = new core_1.OpaqueToken('NgAsyncValidators');
	/**
	 * Provides a set of validators used by form controls.
	 *
	 * A validator is a function that processes a {@link Control} or collection of
	 * controls and returns a map of errors. A null map means that validation has passed.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * var loginControl = new Control("", Validators.required)
	 * ```
	 *
	 * @experimental
	 */
	var Validators = (function () {
	    function Validators() {
	    }
	    /**
	     * Validator that requires controls to have a non-empty value.
	     */
	    Validators.required = function (control) {
	        return lang_1.isBlank(control.value) || (lang_1.isString(control.value) && control.value == '') ?
	            { 'required': true } :
	            null;
	    };
	    /**
	     * Validator that requires controls to have a value of a minimum length.
	     */
	    Validators.minLength = function (minLength) {
	        return function (control) {
	            if (lang_1.isPresent(Validators.required(control)))
	                return null;
	            var v = control.value;
	            return v.length < minLength ?
	                { 'minlength': { 'requiredLength': minLength, 'actualLength': v.length } } :
	                null;
	        };
	    };
	    /**
	     * Validator that requires controls to have a value of a maximum length.
	     */
	    Validators.maxLength = function (maxLength) {
	        return function (control) {
	            if (lang_1.isPresent(Validators.required(control)))
	                return null;
	            var v = control.value;
	            return v.length > maxLength ?
	                { 'maxlength': { 'requiredLength': maxLength, 'actualLength': v.length } } :
	                null;
	        };
	    };
	    /**
	     * Validator that requires a control to match a regex to its value.
	     */
	    Validators.pattern = function (pattern) {
	        return function (control) {
	            if (lang_1.isPresent(Validators.required(control)))
	                return null;
	            var regex = new RegExp("^" + pattern + "$");
	            var v = control.value;
	            return regex.test(v) ? null :
	                { 'pattern': { 'requiredPattern': "^" + pattern + "$", 'actualValue': v } };
	        };
	    };
	    /**
	     * No-op validator.
	     */
	    Validators.nullValidator = function (c) { return null; };
	    /**
	     * Compose multiple validators into a single function that returns the union
	     * of the individual error maps.
	     */
	    Validators.compose = function (validators) {
	        if (lang_1.isBlank(validators))
	            return null;
	        var presentValidators = validators.filter(lang_1.isPresent);
	        if (presentValidators.length == 0)
	            return null;
	        return function (control) {
	            return _mergeErrors(_executeValidators(control, presentValidators));
	        };
	    };
	    Validators.composeAsync = function (validators) {
	        if (lang_1.isBlank(validators))
	            return null;
	        var presentValidators = validators.filter(lang_1.isPresent);
	        if (presentValidators.length == 0)
	            return null;
	        return function (control) {
	            var promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);
	            return Promise.all(promises).then(_mergeErrors);
	        };
	    };
	    return Validators;
	}());
	exports.Validators = Validators;
	function _convertToPromise(obj) {
	    return lang_1.isPromise(obj) ? obj : toPromise_1.toPromise.call(obj);
	}
	function _executeValidators(control, validators) {
	    return validators.map(function (v) { return v(control); });
	}
	function _executeAsyncValidators(control, validators) {
	    return validators.map(function (v) { return v(control); });
	}
	function _mergeErrors(arrayOfErrors) {
	    var res = arrayOfErrors.reduce(function (res, errors) {
	        return lang_1.isPresent(errors) ? collection_1.StringMapWrapper.merge(res, errors) : res;
	    }, {});
	    return collection_1.StringMapWrapper.isEmpty(res) ? null : res;
	}
	//# sourceMappingURL=validators.js.map

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var exceptions_1 = __webpack_require__(20);
	var lang_1 = __webpack_require__(3);
	var InvalidPipeArgumentException = (function (_super) {
	    __extends(InvalidPipeArgumentException, _super);
	    function InvalidPipeArgumentException(type, value) {
	        _super.call(this, "Invalid argument '" + value + "' for pipe '" + lang_1.stringify(type) + "'");
	    }
	    return InvalidPipeArgumentException;
	}(exceptions_1.BaseException));
	exports.InvalidPipeArgumentException = InvalidPipeArgumentException;
	//# sourceMappingURL=invalid_pipe_argument_exception.js.map

/***/ },
/* 17 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * Message Bus is a low level API used to communicate between the UI and the background.
	 * Communication is based on a channel abstraction. Messages published in a
	 * given channel to one MessageBusSink are received on the same channel
	 * by the corresponding MessageBusSource.
	 *
	 * @experimental WebWorker support in Angular is currenlty experimental.
	 */
	var MessageBus = (function () {
	    function MessageBus() {
	    }
	    return MessageBus;
	}());
	exports.MessageBus = MessageBus;
	//# sourceMappingURL=message_bus.js.map

/***/ },
/* 18 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * Supported http methods.
	 * @experimental
	 */
	(function (RequestMethod) {
	    RequestMethod[RequestMethod["Get"] = 0] = "Get";
	    RequestMethod[RequestMethod["Post"] = 1] = "Post";
	    RequestMethod[RequestMethod["Put"] = 2] = "Put";
	    RequestMethod[RequestMethod["Delete"] = 3] = "Delete";
	    RequestMethod[RequestMethod["Options"] = 4] = "Options";
	    RequestMethod[RequestMethod["Head"] = 5] = "Head";
	    RequestMethod[RequestMethod["Patch"] = 6] = "Patch";
	})(exports.RequestMethod || (exports.RequestMethod = {}));
	var RequestMethod = exports.RequestMethod;
	/**
	 * All possible states in which a connection can be, based on
	 * [States](http://www.w3.org/TR/XMLHttpRequest/#states) from the `XMLHttpRequest` spec, but with an
	 * additional "CANCELLED" state.
	 * @experimental
	 */
	(function (ReadyState) {
	    ReadyState[ReadyState["Unsent"] = 0] = "Unsent";
	    ReadyState[ReadyState["Open"] = 1] = "Open";
	    ReadyState[ReadyState["HeadersReceived"] = 2] = "HeadersReceived";
	    ReadyState[ReadyState["Loading"] = 3] = "Loading";
	    ReadyState[ReadyState["Done"] = 4] = "Done";
	    ReadyState[ReadyState["Cancelled"] = 5] = "Cancelled";
	})(exports.ReadyState || (exports.ReadyState = {}));
	var ReadyState = exports.ReadyState;
	/**
	 * Acceptable response types to be associated with a {@link Response}, based on
	 * [ResponseType](https://fetch.spec.whatwg.org/#responsetype) from the Fetch spec.
	 * @experimental
	 */
	(function (ResponseType) {
	    ResponseType[ResponseType["Basic"] = 0] = "Basic";
	    ResponseType[ResponseType["Cors"] = 1] = "Cors";
	    ResponseType[ResponseType["Default"] = 2] = "Default";
	    ResponseType[ResponseType["Error"] = 3] = "Error";
	    ResponseType[ResponseType["Opaque"] = 4] = "Opaque";
	})(exports.ResponseType || (exports.ResponseType = {}));
	var ResponseType = exports.ResponseType;
	/**
	 * Supported content type to be automatically associated with a {@link Request}.
	 * @experimental
	 */
	(function (ContentType) {
	    ContentType[ContentType["NONE"] = 0] = "NONE";
	    ContentType[ContentType["JSON"] = 1] = "JSON";
	    ContentType[ContentType["FORM"] = 2] = "FORM";
	    ContentType[ContentType["FORM_DATA"] = 3] = "FORM_DATA";
	    ContentType[ContentType["TEXT"] = 4] = "TEXT";
	    ContentType[ContentType["BLOB"] = 5] = "BLOB";
	    ContentType[ContentType["ARRAY_BUFFER"] = 6] = "ARRAY_BUFFER";
	})(exports.ContentType || (exports.ContentType = {}));
	var ContentType = exports.ContentType;
	/**
	 * Define which buffer to use to store the response
	 * @experimental
	 */
	(function (ResponseContentType) {
	    ResponseContentType[ResponseContentType["Text"] = 0] = "Text";
	    ResponseContentType[ResponseContentType["Json"] = 1] = "Json";
	    ResponseContentType[ResponseContentType["ArrayBuffer"] = 2] = "ArrayBuffer";
	    ResponseContentType[ResponseContentType["Blob"] = 3] = "Blob";
	})(exports.ResponseContentType || (exports.ResponseContentType = {}));
	var ResponseContentType = exports.ResponseContentType;
	//# sourceMappingURL=enums.js.map

/***/ },
/* 19 */
[295, 181, 182, 182],
/* 20 */
[295, 123, 124, 124],
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var exceptions_1 = __webpack_require__(20);
	var abstract_control_directive_1 = __webpack_require__(71);
	/**
	 * A base class that all control directive extend.
	 * It binds a {@link Control} object to a DOM element.
	 *
	 * Used internally by Angular forms.
	 *
	 * @experimental
	 */
	var NgControl = (function (_super) {
	    __extends(NgControl, _super);
	    function NgControl() {
	        _super.apply(this, arguments);
	        this.name = null;
	        this.valueAccessor = null;
	    }
	    Object.defineProperty(NgControl.prototype, "validator", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControl.prototype, "asyncValidator", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    return NgControl;
	}(abstract_control_directive_1.AbstractControlDirective));
	exports.NgControl = NgControl;
	//# sourceMappingURL=ng_control.js.map

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	/**
	 * A parameter metadata that specifies a dependency.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/6uHYJK?p=preview))
	 *
	 * ```typescript
	 * class Engine {}
	 *
	 * @Injectable()
	 * class Car {
	 *   engine;
	 *   constructor(@Inject("MyEngine") engine:Engine) {
	 *     this.engine = engine;
	 *   }
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([
	 *  {provide: "MyEngine", useClass: Engine},
	 *  Car
	 * ]);
	 *
	 * expect(injector.get(Car).engine instanceof Engine).toBe(true);
	 * ```
	 *
	 * When `@Inject()` is not present, {@link Injector} will use the type annotation of the parameter.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * class Engine {}
	 *
	 * @Injectable()
	 * class Car {
	 *   constructor(public engine: Engine) {} //same as constructor(@Inject(Engine) engine:Engine)
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([Engine, Car]);
	 * expect(injector.get(Car).engine instanceof Engine).toBe(true);
	 * ```
	 * @stable
	 */
	var InjectMetadata = (function () {
	    function InjectMetadata(token) {
	        this.token = token;
	    }
	    InjectMetadata.prototype.toString = function () { return "@Inject(" + lang_1.stringify(this.token) + ")"; };
	    return InjectMetadata;
	}());
	exports.InjectMetadata = InjectMetadata;
	/**
	 * A parameter metadata that marks a dependency as optional. {@link Injector} provides `null` if
	 * the dependency is not found.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/AsryOm?p=preview))
	 *
	 * ```typescript
	 * class Engine {}
	 *
	 * @Injectable()
	 * class Car {
	 *   engine;
	 *   constructor(@Optional() engine:Engine) {
	 *     this.engine = engine;
	 *   }
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([Car]);
	 * expect(injector.get(Car).engine).toBeNull();
	 * ```
	 * @stable
	 */
	var OptionalMetadata = (function () {
	    function OptionalMetadata() {
	    }
	    OptionalMetadata.prototype.toString = function () { return "@Optional()"; };
	    return OptionalMetadata;
	}());
	exports.OptionalMetadata = OptionalMetadata;
	/**
	 * `DependencyMetadata` is used by the framework to extend DI.
	 * This is internal to Angular and should not be used directly.
	 * @stable
	 */
	var DependencyMetadata = (function () {
	    function DependencyMetadata() {
	    }
	    Object.defineProperty(DependencyMetadata.prototype, "token", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    return DependencyMetadata;
	}());
	exports.DependencyMetadata = DependencyMetadata;
	/**
	 * A marker metadata that marks a class as available to {@link Injector} for creation.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Wk4DMQ?p=preview))
	 *
	 * ```typescript
	 * @Injectable()
	 * class UsefulService {}
	 *
	 * @Injectable()
	 * class NeedsService {
	 *   constructor(public service:UsefulService) {}
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);
	 * expect(injector.get(NeedsService).service instanceof UsefulService).toBe(true);
	 * ```
	 * {@link Injector} will throw {@link NoAnnotationError} when trying to instantiate a class that
	 * does not have `@Injectable` marker, as shown in the example below.
	 *
	 * ```typescript
	 * class UsefulService {}
	 *
	 * class NeedsService {
	 *   constructor(public service:UsefulService) {}
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);
	 * expect(() => injector.get(NeedsService)).toThrowError();
	 * ```
	 * @stable
	 */
	var InjectableMetadata = (function () {
	    function InjectableMetadata() {
	    }
	    return InjectableMetadata;
	}());
	exports.InjectableMetadata = InjectableMetadata;
	/**
	 * Specifies that an {@link Injector} should retrieve a dependency only from itself.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/NeagAg?p=preview))
	 *
	 * ```typescript
	 * class Dependency {
	 * }
	 *
	 * @Injectable()
	 * class NeedsDependency {
	 *   dependency;
	 *   constructor(@Self() dependency:Dependency) {
	 *     this.dependency = dependency;
	 *   }
	 * }
	 *
	 * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);
	 * var nd = inj.get(NeedsDependency);
	 *
	 * expect(nd.dependency instanceof Dependency).toBe(true);
	 *
	 * var inj = Injector.resolveAndCreate([Dependency]);
	 * var child = inj.resolveAndCreateChild([NeedsDependency]);
	 * expect(() => child.get(NeedsDependency)).toThrowError();
	 * ```
	 * @stable
	 */
	var SelfMetadata = (function () {
	    function SelfMetadata() {
	    }
	    SelfMetadata.prototype.toString = function () { return "@Self()"; };
	    return SelfMetadata;
	}());
	exports.SelfMetadata = SelfMetadata;
	/**
	 * Specifies that the dependency resolution should start from the parent injector.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Wchdzb?p=preview))
	 *
	 * ```typescript
	 * class Dependency {
	 * }
	 *
	 * @Injectable()
	 * class NeedsDependency {
	 *   dependency;
	 *   constructor(@SkipSelf() dependency:Dependency) {
	 *     this.dependency = dependency;
	 *   }
	 * }
	 *
	 * var parent = Injector.resolveAndCreate([Dependency]);
	 * var child = parent.resolveAndCreateChild([NeedsDependency]);
	 * expect(child.get(NeedsDependency).dependency instanceof Depedency).toBe(true);
	 *
	 * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);
	 * expect(() => inj.get(NeedsDependency)).toThrowError();
	 * ```
	 * @stable
	 */
	var SkipSelfMetadata = (function () {
	    function SkipSelfMetadata() {
	    }
	    SkipSelfMetadata.prototype.toString = function () { return "@SkipSelf()"; };
	    return SkipSelfMetadata;
	}());
	exports.SkipSelfMetadata = SkipSelfMetadata;
	/**
	 * Specifies that an injector should retrieve a dependency from any injector until reaching the
	 * closest host.
	 *
	 * In Angular, a component element is automatically declared as a host for all the injectors in
	 * its view.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/GX79pV?p=preview))
	 *
	 * In the following example `App` contains `ParentCmp`, which contains `ChildDirective`.
	 * So `ParentCmp` is the host of `ChildDirective`.
	 *
	 * `ChildDirective` depends on two services: `HostService` and `OtherService`.
	 * `HostService` is defined at `ParentCmp`, and `OtherService` is defined at `App`.
	 *
	 *```typescript
	 * class OtherService {}
	 * class HostService {}
	 *
	 * @Directive({
	 *   selector: 'child-directive'
	 * })
	 * class ChildDirective {
	 *   constructor(@Optional() @Host() os:OtherService, @Optional() @Host() hs:HostService){
	 *     console.log("os is null", os);
	 *     console.log("hs is NOT null", hs);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'parent-cmp',
	 *   providers: [HostService],
	 *   template: `
	 *     Dir: <child-directive></child-directive>
	 *   `,
	 *   directives: [ChildDirective]
	 * })
	 * class ParentCmp {
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   providers: [OtherService],
	 *   template: `
	 *     Parent: <parent-cmp></parent-cmp>
	 *   `,
	 *   directives: [ParentCmp]
	 * })
	 * class App {
	 * }
	 *
	 * bootstrap(App);
	 *```
	 * @stable
	 */
	var HostMetadata = (function () {
	    function HostMetadata() {
	    }
	    HostMetadata.prototype.toString = function () { return "@Host()"; };
	    return HostMetadata;
	}());
	exports.HostMetadata = HostMetadata;
	//# sourceMappingURL=metadata.js.map

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(8);
	var exceptions_1 = __webpack_require__(19);
	/**
	 * @stable
	 */
	exports.EVENT_MANAGER_PLUGINS = new core_1.OpaqueToken('EventManagerPlugins');
	var EventManager = (function () {
	    function EventManager(plugins, _zone) {
	        var _this = this;
	        this._zone = _zone;
	        plugins.forEach(function (p) { return p.manager = _this; });
	        this._plugins = collection_1.ListWrapper.reversed(plugins);
	    }
	    EventManager.prototype.addEventListener = function (element, eventName, handler) {
	        var plugin = this._findPluginFor(eventName);
	        return plugin.addEventListener(element, eventName, handler);
	    };
	    EventManager.prototype.addGlobalEventListener = function (target, eventName, handler) {
	        var plugin = this._findPluginFor(eventName);
	        return plugin.addGlobalEventListener(target, eventName, handler);
	    };
	    EventManager.prototype.getZone = function () { return this._zone; };
	    /** @internal */
	    EventManager.prototype._findPluginFor = function (eventName) {
	        var plugins = this._plugins;
	        for (var i = 0; i < plugins.length; i++) {
	            var plugin = plugins[i];
	            if (plugin.supports(eventName)) {
	                return plugin;
	            }
	        }
	        throw new exceptions_1.BaseException("No event manager plugin found for event " + eventName);
	    };
	    /** @nocollapse */
	    EventManager.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    EventManager.ctorParameters = [
	        { type: Array, decorators: [{ type: core_1.Inject, args: [exports.EVENT_MANAGER_PLUGINS,] },] },
	        { type: core_1.NgZone, },
	    ];
	    return EventManager;
	}());
	exports.EventManager = EventManager;
	var EventManagerPlugin = (function () {
	    function EventManagerPlugin() {
	    }
	    // That is equivalent to having supporting $event.target
	    EventManagerPlugin.prototype.supports = function (eventName) { return false; };
	    EventManagerPlugin.prototype.addEventListener = function (element, eventName, handler) {
	        throw 'not implemented';
	    };
	    EventManagerPlugin.prototype.addGlobalEventListener = function (element, eventName, handler) {
	        throw 'not implemented';
	    };
	    return EventManagerPlugin;
	}());
	exports.EventManagerPlugin = EventManagerPlugin;
	//# sourceMappingURL=event_manager.js.map

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(40);
	var observable_1 = __webpack_require__(283);
	var toSubscriber_1 = __webpack_require__(289);
	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is  called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    /**
	     * Registers handlers for handling emitted values, error and completions from the observable, and
	     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
	     * @method subscribe
	     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,
	     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
	     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
	     *  the error will be thrown as unhandled
	     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
	     * @return {ISubscription} a subscription reference to the registered handlers
	     */
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        sink.add(operator ? operator.call(sink, this) : this._subscribe(sink));
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            var subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` imple will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[observable_1.$$observable] = function () {
	        return this;
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	exports.Observable = Observable;
	//# sourceMappingURL=Observable.js.map

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(27);
	var Observable_1 = __webpack_require__(24);
	exports.Observable = Observable_1.Observable;
	var Subject_2 = __webpack_require__(27);
	exports.Subject = Subject_2.Subject;
	/**
	 * Use by directives and components to emit custom Events.
	 *
	 * ### Examples
	 *
	 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	 * title gets clicked:
	 *
	 * ```
	 * @Component({
	 *   selector: 'zippy',
	 *   template: `
	 *   <div class="zippy">
	 *     <div (click)="toggle()">Toggle</div>
	 *     <div [hidden]="!visible">
	 *       <ng-content></ng-content>
	 *     </div>
	 *  </div>`})
	 * export class Zippy {
	 *   visible: boolean = true;
	 *   @Output() open: EventEmitter<any> = new EventEmitter();
	 *   @Output() close: EventEmitter<any> = new EventEmitter();
	 *
	 *   toggle() {
	 *     this.visible = !this.visible;
	 *     if (this.visible) {
	 *       this.open.emit(null);
	 *     } else {
	 *       this.close.emit(null);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * The events payload can be accessed by the parameter `$event` on the components output event
	 * handler:
	 *
	 * ```
	 * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	 * ```
	 *
	 * Uses Rx.Observable but provides an adapter to make it work as specified here:
	 * https://github.com/jhusain/observable-spec
	 *
	 * Once a reference implementation of the spec is available, switch to it.
	 * @stable
	 */
	var EventEmitter = (function (_super) {
	    __extends(EventEmitter, _super);
	    /**
	     * Creates an instance of [EventEmitter], which depending on [isAsync],
	     * delivers events synchronously or asynchronously.
	     */
	    function EventEmitter(isAsync) {
	        if (isAsync === void 0) { isAsync = false; }
	        _super.call(this);
	        this.__isAsync = isAsync;
	    }
	    EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };
	    /**
	     * @deprecated - use .emit(value) instead
	     */
	    EventEmitter.prototype.next = function (value) { _super.prototype.next.call(this, value); };
	    EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
	        var schedulerFn;
	        var errorFn = function (err) { return null; };
	        var completeFn = function () { return null; };
	        if (generatorOrNext && typeof generatorOrNext === 'object') {
	            schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
	                setTimeout(function () { return generatorOrNext.next(value); });
	            } : function (value /** TODO #9100 */) { generatorOrNext.next(value); };
	            if (generatorOrNext.error) {
	                errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :
	                    function (err) { generatorOrNext.error(err); };
	            }
	            if (generatorOrNext.complete) {
	                completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :
	                    function () { generatorOrNext.complete(); };
	            }
	        }
	        else {
	            schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
	                setTimeout(function () { return generatorOrNext(value); });
	            } : function (value /** TODO #9100 */) { generatorOrNext(value); };
	            if (error) {
	                errorFn =
	                    this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
	            }
	            if (complete) {
	                completeFn =
	                    this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
	            }
	        }
	        return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
	    };
	    return EventEmitter;
	}(Subject_1.Subject));
	exports.EventEmitter = EventEmitter;
	//# sourceMappingURL=async.js.map

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(10);
	var exceptions_1 = __webpack_require__(20);
	var lang_1 = __webpack_require__(3);
	var validators_1 = __webpack_require__(15);
	var checkbox_value_accessor_1 = __webpack_require__(41);
	var default_value_accessor_1 = __webpack_require__(42);
	var normalize_validator_1 = __webpack_require__(199);
	var number_value_accessor_1 = __webpack_require__(79);
	var radio_control_value_accessor_1 = __webpack_require__(43);
	var select_control_value_accessor_1 = __webpack_require__(44);
	var select_multiple_control_value_accessor_1 = __webpack_require__(80);
	function controlPath(name, parent) {
	    var p = collection_1.ListWrapper.clone(parent.path);
	    p.push(name);
	    return p;
	}
	exports.controlPath = controlPath;
	function setUpControl(control, dir) {
	    if (lang_1.isBlank(control))
	        _throwError(dir, 'Cannot find control with');
	    if (lang_1.isBlank(dir.valueAccessor))
	        _throwError(dir, 'No value accessor for form control with');
	    control.validator = validators_1.Validators.compose([control.validator, dir.validator]);
	    control.asyncValidator = validators_1.Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
	    dir.valueAccessor.writeValue(control.value);
	    // view -> model
	    dir.valueAccessor.registerOnChange(function (newValue) {
	        dir.viewToModelUpdate(newValue);
	        control.updateValue(newValue, { emitModelToViewChange: false });
	        control.markAsDirty();
	    });
	    // model -> view
	    control.registerOnChange(function (newValue) { return dir.valueAccessor.writeValue(newValue); });
	    // touched
	    dir.valueAccessor.registerOnTouched(function () { return control.markAsTouched(); });
	}
	exports.setUpControl = setUpControl;
	function setUpControlGroup(control, dir) {
	    if (lang_1.isBlank(control))
	        _throwError(dir, 'Cannot find control with');
	    control.validator = validators_1.Validators.compose([control.validator, dir.validator]);
	    control.asyncValidator = validators_1.Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
	}
	exports.setUpControlGroup = setUpControlGroup;
	function _throwError(dir, message) {
	    var messageEnd;
	    if (dir.path.length > 1) {
	        messageEnd = "path: '" + dir.path.join(' -> ') + "'";
	    }
	    else if (dir.path[0]) {
	        messageEnd = "name: '" + dir.path + "'";
	    }
	    else {
	        messageEnd = 'unspecified name';
	    }
	    throw new exceptions_1.BaseException(message + " " + messageEnd);
	}
	function composeValidators(validators) {
	    return lang_1.isPresent(validators) ? validators_1.Validators.compose(validators.map(normalize_validator_1.normalizeValidator)) : null;
	}
	exports.composeValidators = composeValidators;
	function composeAsyncValidators(validators) {
	    return lang_1.isPresent(validators) ? validators_1.Validators.composeAsync(validators.map(normalize_validator_1.normalizeAsyncValidator)) :
	        null;
	}
	exports.composeAsyncValidators = composeAsyncValidators;
	function isPropertyUpdated(changes, viewModel) {
	    if (!collection_1.StringMapWrapper.contains(changes, 'model'))
	        return false;
	    var change = changes['model'];
	    if (change.isFirstChange())
	        return true;
	    return !lang_1.looseIdentical(viewModel, change.currentValue);
	}
	exports.isPropertyUpdated = isPropertyUpdated;
	// TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented
	function selectValueAccessor(dir, valueAccessors) {
	    if (lang_1.isBlank(valueAccessors))
	        return null;
	    var defaultAccessor;
	    var builtinAccessor;
	    var customAccessor;
	    valueAccessors.forEach(function (v) {
	        if (lang_1.hasConstructor(v, default_value_accessor_1.DefaultValueAccessor)) {
	            defaultAccessor = v;
	        }
	        else if (lang_1.hasConstructor(v, checkbox_value_accessor_1.CheckboxControlValueAccessor) || lang_1.hasConstructor(v, number_value_accessor_1.NumberValueAccessor) ||
	            lang_1.hasConstructor(v, select_control_value_accessor_1.SelectControlValueAccessor) ||
	            lang_1.hasConstructor(v, select_multiple_control_value_accessor_1.SelectMultipleControlValueAccessor) ||
	            lang_1.hasConstructor(v, radio_control_value_accessor_1.RadioControlValueAccessor)) {
	            if (lang_1.isPresent(builtinAccessor))
	                _throwError(dir, 'More than one built-in value accessor matches form control with');
	            builtinAccessor = v;
	        }
	        else {
	            if (lang_1.isPresent(customAccessor))
	                _throwError(dir, 'More than one custom value accessor matches form control with');
	            customAccessor = v;
	        }
	    });
	    if (lang_1.isPresent(customAccessor))
	        return customAccessor;
	    if (lang_1.isPresent(builtinAccessor))
	        return builtinAccessor;
	    if (lang_1.isPresent(defaultAccessor))
	        return defaultAccessor;
	    _throwError(dir, 'No valid value accessor for form control with');
	    return null;
	}
	exports.selectValueAccessor = selectValueAccessor;
	//# sourceMappingURL=shared.js.map

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(24);
	var Subscriber_1 = __webpack_require__(194);
	var Subscription_1 = __webpack_require__(113);
	var SubjectSubscription_1 = __webpack_require__(280);
	var rxSubscriber_1 = __webpack_require__(114);
	var throwError_1 = __webpack_require__(288);
	var ObjectUnsubscribedError_1 = __webpack_require__(284);
	/**
	 * @class Subject<T>
	 */
	var Subject = (function (_super) {
	    __extends(Subject, _super);
	    function Subject(destination, source) {
	        _super.call(this);
	        this.destination = destination;
	        this.source = source;
	        this.observers = [];
	        this.isUnsubscribed = false;
	        this.isStopped = false;
	        this.hasErrored = false;
	        this.dispatching = false;
	        this.hasCompleted = false;
	        this.source = source;
	    }
	    Subject.prototype.lift = function (operator) {
	        var subject = new Subject(this.destination || this, this);
	        subject.operator = operator;
	        return subject;
	    };
	    Subject.prototype.add = function (subscription) {
	        return Subscription_1.Subscription.prototype.add.call(this, subscription);
	    };
	    Subject.prototype.remove = function (subscription) {
	        Subscription_1.Subscription.prototype.remove.call(this, subscription);
	    };
	    Subject.prototype.unsubscribe = function () {
	        Subscription_1.Subscription.prototype.unsubscribe.call(this);
	    };
	    Subject.prototype._subscribe = function (subscriber) {
	        if (this.source) {
	            return this.source.subscribe(subscriber);
	        }
	        else {
	            if (subscriber.isUnsubscribed) {
	                return;
	            }
	            else if (this.hasErrored) {
	                return subscriber.error(this.errorValue);
	            }
	            else if (this.hasCompleted) {
	                return subscriber.complete();
	            }
	            this.throwIfUnsubscribed();
	            var subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
	            this.observers.push(subscriber);
	            return subscription;
	        }
	    };
	    Subject.prototype._unsubscribe = function () {
	        this.source = null;
	        this.isStopped = true;
	        this.observers = null;
	        this.destination = null;
	    };
	    Subject.prototype.next = function (value) {
	        this.throwIfUnsubscribed();
	        if (this.isStopped) {
	            return;
	        }
	        this.dispatching = true;
	        this._next(value);
	        this.dispatching = false;
	        if (this.hasErrored) {
	            this._error(this.errorValue);
	        }
	        else if (this.hasCompleted) {
	            this._complete();
	        }
	    };
	    Subject.prototype.error = function (err) {
	        this.throwIfUnsubscribed();
	        if (this.isStopped) {
	            return;
	        }
	        this.isStopped = true;
	        this.hasErrored = true;
	        this.errorValue = err;
	        if (this.dispatching) {
	            return;
	        }
	        this._error(err);
	    };
	    Subject.prototype.complete = function () {
	        this.throwIfUnsubscribed();
	        if (this.isStopped) {
	            return;
	        }
	        this.isStopped = true;
	        this.hasCompleted = true;
	        if (this.dispatching) {
	            return;
	        }
	        this._complete();
	    };
	    Subject.prototype.asObservable = function () {
	        var observable = new SubjectObservable(this);
	        return observable;
	    };
	    Subject.prototype._next = function (value) {
	        if (this.destination) {
	            this.destination.next(value);
	        }
	        else {
	            this._finalNext(value);
	        }
	    };
	    Subject.prototype._finalNext = function (value) {
	        var index = -1;
	        var observers = this.observers.slice(0);
	        var len = observers.length;
	        while (++index < len) {
	            observers[index].next(value);
	        }
	    };
	    Subject.prototype._error = function (err) {
	        if (this.destination) {
	            this.destination.error(err);
	        }
	        else {
	            this._finalError(err);
	        }
	    };
	    Subject.prototype._finalError = function (err) {
	        var index = -1;
	        var observers = this.observers;
	        // optimization to block our SubjectSubscriptions from
	        // splicing themselves out of the observers list one by one.
	        this.observers = null;
	        this.isUnsubscribed = true;
	        if (observers) {
	            var len = observers.length;
	            while (++index < len) {
	                observers[index].error(err);
	            }
	        }
	        this.isUnsubscribed = false;
	        this.unsubscribe();
	    };
	    Subject.prototype._complete = function () {
	        if (this.destination) {
	            this.destination.complete();
	        }
	        else {
	            this._finalComplete();
	        }
	    };
	    Subject.prototype._finalComplete = function () {
	        var index = -1;
	        var observers = this.observers;
	        // optimization to block our SubjectSubscriptions from
	        // splicing themselves out of the observers list one by one.
	        this.observers = null;
	        this.isUnsubscribed = true;
	        if (observers) {
	            var len = observers.length;
	            while (++index < len) {
	                observers[index].complete();
	            }
	        }
	        this.isUnsubscribed = false;
	        this.unsubscribe();
	    };
	    Subject.prototype.throwIfUnsubscribed = function () {
	        if (this.isUnsubscribed) {
	            throwError_1.throwError(new ObjectUnsubscribedError_1.ObjectUnsubscribedError());
	        }
	    };
	    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
	        return new Subscriber_1.Subscriber(this);
	    };
	    Subject.create = function (destination, source) {
	        return new Subject(destination, source);
	    };
	    return Subject;
	}(Observable_1.Observable));
	exports.Subject = Subject;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubjectObservable = (function (_super) {
	    __extends(SubjectObservable, _super);
	    function SubjectObservable(source) {
	        _super.call(this);
	        this.source = source;
	    }
	    return SubjectObservable;
	}(Observable_1.Observable));
	//# sourceMappingURL=Subject.js.map

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var core_1 = __webpack_require__(1);
	var common_directives_1 = __webpack_require__(115);
	var pipes_1 = __webpack_require__(128);
	__export(__webpack_require__(128));
	__export(__webpack_require__(116));
	__export(__webpack_require__(198));
	__export(__webpack_require__(115));
	__export(__webpack_require__(200));
	var localization_1 = __webpack_require__(82);
	exports.NgLocalization = localization_1.NgLocalization;
	var CommonModule = (function () {
	    function CommonModule() {
	    }
	    /** @nocollapse */
	    CommonModule.decorators = [
	        { type: core_1.NgModule, args: [{ declarations: [common_directives_1.COMMON_DIRECTIVES, pipes_1.COMMON_PIPES], exports: [common_directives_1.COMMON_DIRECTIVES, pipes_1.COMMON_PIPES] },] },
	    ];
	    return CommonModule;
	}());
	exports.CommonModule = CommonModule;
	//# sourceMappingURL=index.js.map

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var abstract_control_directive_1 = __webpack_require__(71);
	/**
	 * A directive that contains multiple {@link NgControl}s.
	 *
	 * Only used by the forms module.
	 *
	 * @experimental
	 */
	var ControlContainer = (function (_super) {
	    __extends(ControlContainer, _super);
	    function ControlContainer() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(ControlContainer.prototype, "formDirective", {
	        /**
	         * Get the form to which this container belongs.
	         */
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ControlContainer.prototype, "path", {
	        /**
	         * Get the path to this container.
	         */
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    return ControlContainer;
	}(abstract_control_directive_1.AbstractControlDirective));
	exports.ControlContainer = ControlContainer;
	//# sourceMappingURL=control_container.js.map

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var decorators_1 = __webpack_require__(58);
	var metadata_1 = __webpack_require__(22);
	/**
	 * Factory for creating {@link InjectMetadata}.
	 * @stable
	 * @Annotation
	 */
	exports.Inject = decorators_1.makeParamDecorator(metadata_1.InjectMetadata);
	/**
	 * Factory for creating {@link OptionalMetadata}.
	 * @stable
	 * @Annotation
	 */
	exports.Optional = decorators_1.makeParamDecorator(metadata_1.OptionalMetadata);
	/**
	 * Factory for creating {@link InjectableMetadata}.
	 * @stable
	 * @Annotation
	 */
	exports.Injectable = decorators_1.makeDecorator(metadata_1.InjectableMetadata);
	/**
	 * Factory for creating {@link SelfMetadata}.
	 * @stable
	 * @Annotation
	 */
	exports.Self = decorators_1.makeParamDecorator(metadata_1.SelfMetadata);
	/**
	 * Factory for creating {@link HostMetadata}.
	 * @stable
	 * @Annotation
	 */
	exports.Host = decorators_1.makeParamDecorator(metadata_1.HostMetadata);
	/**
	 * Factory for creating {@link SkipSelfMetadata}.
	 * @stable
	 * @Annotation
	 */
	exports.SkipSelf = decorators_1.makeParamDecorator(metadata_1.SkipSelfMetadata);
	//# sourceMappingURL=decorators.js.map

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var di_1 = __webpack_require__(12);
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	/**
	 * Indicates that a component is still being loaded in a synchronous compile.
	 *
	 * @stable
	 */
	var ComponentStillLoadingError = (function (_super) {
	    __extends(ComponentStillLoadingError, _super);
	    function ComponentStillLoadingError(compType) {
	        _super.call(this, "Can't compile synchronously as " + lang_1.stringify(compType) + " is still being loaded!");
	        this.compType = compType;
	    }
	    return ComponentStillLoadingError;
	}(exceptions_1.BaseException));
	exports.ComponentStillLoadingError = ComponentStillLoadingError;
	/**
	 * Combination of NgModuleFactory and ComponentFactorys.
	 *
	 * @experimental
	 */
	var ModuleWithComponentFactories = (function () {
	    function ModuleWithComponentFactories(ngModuleFactory, componentFactories) {
	        this.ngModuleFactory = ngModuleFactory;
	        this.componentFactories = componentFactories;
	    }
	    return ModuleWithComponentFactories;
	}());
	exports.ModuleWithComponentFactories = ModuleWithComponentFactories;
	function _throwError() {
	    throw new exceptions_1.BaseException("Runtime compiler is not loaded");
	}
	/**
	 * Low-level service for running the angular compiler duirng runtime
	 * to create {@link ComponentFactory}s, which
	 * can later be used to create and render a Component instance.
	 *
	 * Each `@NgModule` provides an own `Compiler` to its injector,
	 * that will use the directives/pipes of the ng module for compilation
	 * of components.
	 * @stable
	 */
	var Compiler = (function () {
	    function Compiler() {
	    }
	    /**
	     * Loads the template and styles of a component and returns the associated `ComponentFactory`.
	     */
	    Compiler.prototype.compileComponentAsync = function (component, ngModule) {
	        if (ngModule === void 0) { ngModule = null; }
	        throw _throwError();
	    };
	    /**
	     * Compiles the given component. All templates have to be either inline or compiled via
	     * `compileComponentAsync` before. Otherwise throws a {@link ComponentStillLoadingError}.
	     */
	    Compiler.prototype.compileComponentSync = function (component, ngModule) {
	        if (ngModule === void 0) { ngModule = null; }
	        throw _throwError();
	    };
	    /**
	     * Compiles the given NgModule and all of its components. All templates of the components listed
	     * in `entryComponents`
	     * have to be inlined. Otherwise throws a {@link ComponentStillLoadingError}.
	     */
	    Compiler.prototype.compileModuleSync = function (moduleType) { throw _throwError(); };
	    /**
	     * Compiles the given NgModule and all of its components
	     */
	    Compiler.prototype.compileModuleAsync = function (moduleType) {
	        throw _throwError();
	    };
	    /**
	     * Same as {@link compileModuleSync} put also creates ComponentFactories for all components.
	     */
	    Compiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
	        throw _throwError();
	    };
	    /**
	     * Same as {@link compileModuleAsync} put also creates ComponentFactories for all components.
	     */
	    Compiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
	        throw _throwError();
	    };
	    /**
	     * Clears all caches
	     */
	    Compiler.prototype.clearCache = function () { };
	    /**
	     * Clears the cache for the given component/ngModule.
	     */
	    Compiler.prototype.clearCacheFor = function (type) { };
	    return Compiler;
	}());
	exports.Compiler = Compiler;
	/**
	 * Token to provide CompilerOptions in the platform injector.
	 *
	 * @experimental
	 */
	exports.COMPILER_OPTIONS = new di_1.OpaqueToken('compilerOptions');
	/**
	 * A factory for creating a Compiler
	 *
	 * @experimental
	 */
	var CompilerFactory = (function () {
	    function CompilerFactory() {
	    }
	    return CompilerFactory;
	}());
	exports.CompilerFactory = CompilerFactory;
	//# sourceMappingURL=compiler.js.map

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(104);
	var exceptions_1 = __webpack_require__(60);
	var lang_1 = __webpack_require__(11);
	/**
	 * Polyfill for [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers/Headers), as
	 * specified in the [Fetch Spec](https://fetch.spec.whatwg.org/#headers-class).
	 *
	 * The only known difference between this `Headers` implementation and the spec is the
	 * lack of an `entries` method.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/MTdwT6?p=preview))
	 *
	 * ```
	 * import {Headers} from '@angular/http';
	 *
	 * var firstHeaders = new Headers();
	 * firstHeaders.append('Content-Type', 'image/jpeg');
	 * console.log(firstHeaders.get('Content-Type')) //'image/jpeg'
	 *
	 * // Create headers from Plain Old JavaScript Object
	 * var secondHeaders = new Headers({
	 *   'X-My-Custom-Header': 'Angular'
	 * });
	 * console.log(secondHeaders.get('X-My-Custom-Header')); //'Angular'
	 *
	 * var thirdHeaders = new Headers(secondHeaders);
	 * console.log(thirdHeaders.get('X-My-Custom-Header')); //'Angular'
	 * ```
	 *
	 * @experimental
	 */
	var Headers = (function () {
	    function Headers(headers) {
	        var _this = this;
	        if (headers instanceof Headers) {
	            this._headersMap = headers._headersMap;
	            return;
	        }
	        this._headersMap = new collection_1.Map();
	        if (lang_1.isBlank(headers)) {
	            return;
	        }
	        // headers instanceof StringMap
	        collection_1.StringMapWrapper.forEach(headers, function (v, k) {
	            _this._headersMap.set(normalize(k), collection_1.isListLikeIterable(v) ? v : [v]);
	        });
	    }
	    /**
	     * Returns a new Headers instance from the given DOMString of Response Headers
	     */
	    Headers.fromResponseHeaderString = function (headersString) {
	        var headers = new Headers();
	        headersString.split('\n').forEach(function (line) {
	            var index = line.indexOf(':');
	            if (index > 0) {
	                var key = line.substring(0, index);
	                var value = line.substring(index + 1).trim();
	                headers.set(key, value);
	            }
	        });
	        return headers;
	    };
	    /**
	     * Appends a header to existing list of header values for a given header name.
	     */
	    Headers.prototype.append = function (name, value) {
	        name = normalize(name);
	        var mapName = this._headersMap.get(name);
	        var list = collection_1.isListLikeIterable(mapName) ? mapName : [];
	        list.push(value);
	        this._headersMap.set(name, list);
	    };
	    /**
	     * Deletes all header values for the given name.
	     */
	    Headers.prototype.delete = function (name) { this._headersMap.delete(normalize(name)); };
	    Headers.prototype.forEach = function (fn) {
	        this._headersMap.forEach(fn);
	    };
	    /**
	     * Returns first header that matches given name.
	     */
	    Headers.prototype.get = function (header) { return collection_1.ListWrapper.first(this._headersMap.get(normalize(header))); };
	    /**
	     * Check for existence of header by given name.
	     */
	    Headers.prototype.has = function (header) { return this._headersMap.has(normalize(header)); };
	    /**
	     * Provides names of set headers
	     */
	    Headers.prototype.keys = function () { return collection_1.MapWrapper.keys(this._headersMap); };
	    /**
	     * Sets or overrides header value for given name.
	     */
	    Headers.prototype.set = function (header, value) {
	        var list = [];
	        if (collection_1.isListLikeIterable(value)) {
	            var pushValue = value.join(',');
	            list.push(pushValue);
	        }
	        else {
	            list.push(value);
	        }
	        this._headersMap.set(normalize(header), list);
	    };
	    /**
	     * Returns values of all headers.
	     */
	    Headers.prototype.values = function () { return collection_1.MapWrapper.values(this._headersMap); };
	    /**
	     * Returns string of all headers.
	     */
	    Headers.prototype.toJSON = function () {
	        var serializableHeaders = {};
	        this._headersMap.forEach(function (values, name) {
	            var list = [];
	            collection_1.iterateListLike(values, function (val /** TODO #9100 */) { return list = collection_1.ListWrapper.concat(list, val.split(',')); });
	            serializableHeaders[normalize(name)] = list;
	        });
	        return serializableHeaders;
	    };
	    /**
	     * Returns list of header values for a given name.
	     */
	    Headers.prototype.getAll = function (header) {
	        var headers = this._headersMap.get(normalize(header));
	        return collection_1.isListLikeIterable(headers) ? headers : [];
	    };
	    /**
	     * This method is not implemented.
	     */
	    Headers.prototype.entries = function () { throw new exceptions_1.BaseException('"entries" method is not implemented on Headers class'); };
	    return Headers;
	}());
	exports.Headers = Headers;
	// "HTTP character sets are identified by case-insensitive tokens"
	// Spec at https://tools.ietf.org/html/rfc2616
	// This implementation is same as NodeJS.
	// see https://nodejs.org/dist/latest-v6.x/docs/api/http.html#http_message_headers
	function normalize(name) {
	    return name.toLowerCase();
	}
	//# sourceMappingURL=headers.js.map

/***/ },
/* 33 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * Abstract class from which real backends are derived.
	 *
	 * The primary purpose of a `ConnectionBackend` is to create new connections to fulfill a given
	 * {@link Request}.
	 *
	 * @experimental
	 */
	var ConnectionBackend = (function () {
	    function ConnectionBackend() {
	    }
	    return ConnectionBackend;
	}());
	exports.ConnectionBackend = ConnectionBackend;
	/**
	 * Abstract class from which real connections are derived.
	 *
	 * @experimental
	 */
	var Connection = (function () {
	    function Connection() {
	    }
	    return Connection;
	}());
	exports.Connection = Connection;
	/**
	 * An XSRFStrategy configures XSRF protection (e.g. via headers) on an HTTP request.
	 *
	 * @experimental
	 */
	var XSRFStrategy = (function () {
	    function XSRFStrategy() {
	    }
	    return XSRFStrategy;
	}());
	exports.XSRFStrategy = XSRFStrategy;
	//# sourceMappingURL=interfaces.js.map

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	exports.RenderDebugInfo = core_1.__core_private__.RenderDebugInfo;
	exports.wtfInit = core_1.__core_private__.wtfInit;
	exports.ReflectionCapabilities = core_1.__core_private__.ReflectionCapabilities;
	exports.VIEW_ENCAPSULATION_VALUES = core_1.__core_private__.VIEW_ENCAPSULATION_VALUES;
	exports.DebugDomRootRenderer = core_1.__core_private__.DebugDomRootRenderer;
	exports.reflector = core_1.__core_private__.reflector;
	exports.NoOpAnimationPlayer = core_1.__core_private__.NoOpAnimationPlayer;
	exports.AnimationPlayer = core_1.__core_private__.AnimationPlayer;
	exports.AnimationSequencePlayer = core_1.__core_private__.AnimationSequencePlayer;
	exports.AnimationGroupPlayer = core_1.__core_private__.AnimationGroupPlayer;
	exports.AnimationKeyframe = core_1.__core_private__.AnimationKeyframe;
	exports.AnimationStyles = core_1.__core_private__.AnimationStyles;
	exports.prepareFinalAnimationStyles = core_1.__core_private__.prepareFinalAnimationStyles;
	exports.balanceAnimationKeyframes = core_1.__core_private__.balanceAnimationKeyframes;
	exports.flattenStyles = core_1.__core_private__.flattenStyles;
	exports.clearStyles = core_1.__core_private__.clearStyles;
	exports.collectAndResolveStyles = core_1.__core_private__.collectAndResolveStyles;
	//# sourceMappingURL=core_private.js.map

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	/**
	 * A DI Token representing the main rendering context. In a browser this is the DOM Document.
	 *
	 * Note: Document might not be available in the Application Context when Application and Rendering
	 * Contexts are not the same (e.g. when running the application into a Web Worker).
	 *
	 * @stable
	 */
	exports.DOCUMENT = new core_1.OpaqueToken('DocumentToken');
	//# sourceMappingURL=dom_tokens.js.map

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(8);
	var lang_1 = __webpack_require__(5);
	var message_bus_1 = __webpack_require__(17);
	var serializer_1 = __webpack_require__(14);
	/**
	 * @experimental WebWorker support in Angular is experimental.
	 */
	var ClientMessageBrokerFactory = (function () {
	    function ClientMessageBrokerFactory() {
	    }
	    return ClientMessageBrokerFactory;
	}());
	exports.ClientMessageBrokerFactory = ClientMessageBrokerFactory;
	var ClientMessageBrokerFactory_ = (function (_super) {
	    __extends(ClientMessageBrokerFactory_, _super);
	    function ClientMessageBrokerFactory_(_messageBus, _serializer) {
	        _super.call(this);
	        this._messageBus = _messageBus;
	        this._serializer = _serializer;
	    }
	    /**
	     * Initializes the given channel and attaches a new {@link ClientMessageBroker} to it.
	     */
	    ClientMessageBrokerFactory_.prototype.createMessageBroker = function (channel, runInZone) {
	        if (runInZone === void 0) { runInZone = true; }
	        this._messageBus.initChannel(channel, runInZone);
	        return new ClientMessageBroker_(this._messageBus, this._serializer, channel);
	    };
	    /** @nocollapse */
	    ClientMessageBrokerFactory_.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    ClientMessageBrokerFactory_.ctorParameters = [
	        { type: message_bus_1.MessageBus, },
	        { type: serializer_1.Serializer, },
	    ];
	    return ClientMessageBrokerFactory_;
	}(ClientMessageBrokerFactory));
	exports.ClientMessageBrokerFactory_ = ClientMessageBrokerFactory_;
	/**
	 * @experimental WebWorker support in Angular is experimental.
	 */
	var ClientMessageBroker = (function () {
	    function ClientMessageBroker() {
	    }
	    return ClientMessageBroker;
	}());
	exports.ClientMessageBroker = ClientMessageBroker;
	var ClientMessageBroker_ = (function (_super) {
	    __extends(ClientMessageBroker_, _super);
	    function ClientMessageBroker_(messageBus, _serializer, channel /** TODO #9100 */) {
	        var _this = this;
	        _super.call(this);
	        this.channel = channel;
	        this._pending = new Map();
	        this._sink = messageBus.to(channel);
	        this._serializer = _serializer;
	        var source = messageBus.from(channel);
	        source.subscribe({ next: function (message) { return _this._handleMessage(message); } });
	    }
	    ClientMessageBroker_.prototype._generateMessageId = function (name) {
	        var time = lang_1.stringify(lang_1.DateWrapper.toMillis(lang_1.DateWrapper.now()));
	        var iteration = 0;
	        var id = name + time + lang_1.stringify(iteration);
	        while (lang_1.isPresent(this._pending[id])) {
	            id = "" + name + time + iteration;
	            iteration++;
	        }
	        return id;
	    };
	    ClientMessageBroker_.prototype.runOnService = function (args, returnType) {
	        var _this = this;
	        var fnArgs = [];
	        if (lang_1.isPresent(args.args)) {
	            args.args.forEach(function (argument) {
	                if (argument.type != null) {
	                    fnArgs.push(_this._serializer.serialize(argument.value, argument.type));
	                }
	                else {
	                    fnArgs.push(argument.value);
	                }
	            });
	        }
	        var promise;
	        var id = null;
	        if (returnType != null) {
	            var completer_1;
	            promise = new Promise(function (resolve, reject) { completer_1 = { resolve: resolve, reject: reject }; });
	            id = this._generateMessageId(args.method);
	            this._pending.set(id, completer_1);
	            promise.catch(function (err) {
	                lang_1.print(err);
	                completer_1.reject(err);
	            });
	            promise = promise.then(function (value) {
	                if (_this._serializer == null) {
	                    return value;
	                }
	                else {
	                    return _this._serializer.deserialize(value, returnType);
	                }
	            });
	        }
	        else {
	            promise = null;
	        }
	        // TODO(jteplitz602): Create a class for these messages so we don't keep using StringMap #3685
	        var message = { 'method': args.method, 'args': fnArgs };
	        if (id != null) {
	            message['id'] = id;
	        }
	        this._sink.emit(message);
	        return promise;
	    };
	    ClientMessageBroker_.prototype._handleMessage = function (message) {
	        var data = new MessageData(message);
	        // TODO(jteplitz602): replace these strings with messaging constants #3685
	        if (lang_1.StringWrapper.equals(data.type, 'result') || lang_1.StringWrapper.equals(data.type, 'error')) {
	            var id = data.id;
	            if (this._pending.has(id)) {
	                if (lang_1.StringWrapper.equals(data.type, 'result')) {
	                    this._pending.get(id).resolve(data.value);
	                }
	                else {
	                    this._pending.get(id).reject(data.value);
	                }
	                this._pending.delete(id);
	            }
	        }
	    };
	    return ClientMessageBroker_;
	}(ClientMessageBroker));
	exports.ClientMessageBroker_ = ClientMessageBroker_;
	var MessageData = (function () {
	    function MessageData(data) {
	        this.type = collection_1.StringMapWrapper.get(data, 'type');
	        this.id = this._getValueIfPresent(data, 'id');
	        this.value = this._getValueIfPresent(data, 'value');
	    }
	    /**
	     * Returns the value from the StringMap if present. Otherwise returns null
	     * @internal
	     */
	    MessageData.prototype._getValueIfPresent = function (data, key) {
	        if (collection_1.StringMapWrapper.contains(data, key)) {
	            return collection_1.StringMapWrapper.get(data, key);
	        }
	        else {
	            return null;
	        }
	    };
	    return MessageData;
	}());
	/**
	 * @experimental WebWorker support in Angular is experimental.
	 */
	var FnArg = (function () {
	    function FnArg(value /** TODO #9100 */, type) {
	        this.value = value;
	        this.type = type;
	    }
	    return FnArg;
	}());
	exports.FnArg = FnArg;
	/**
	 * @experimental WebWorker support in Angular is experimental.
	 */
	var UiArguments = (function () {
	    function UiArguments(method, args) {
	        this.method = method;
	        this.args = args;
	    }
	    return UiArguments;
	}());
	exports.UiArguments = UiArguments;
	//# sourceMappingURL=client_message_broker.js.map

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var RenderStore = (function () {
	    function RenderStore() {
	        this._nextIndex = 0;
	        this._lookupById = new Map();
	        this._lookupByObject = new Map();
	    }
	    RenderStore.prototype.allocateId = function () { return this._nextIndex++; };
	    RenderStore.prototype.store = function (obj, id) {
	        this._lookupById.set(id, obj);
	        this._lookupByObject.set(obj, id);
	    };
	    RenderStore.prototype.remove = function (obj) {
	        var index = this._lookupByObject.get(obj);
	        this._lookupByObject.delete(obj);
	        this._lookupById.delete(index);
	    };
	    RenderStore.prototype.deserialize = function (id) {
	        if (id == null) {
	            return null;
	        }
	        if (!this._lookupById.has(id)) {
	            return null;
	        }
	        return this._lookupById.get(id);
	    };
	    RenderStore.prototype.serialize = function (obj) {
	        if (obj == null) {
	            return null;
	        }
	        return this._lookupByObject.get(obj);
	    };
	    /** @nocollapse */
	    RenderStore.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    RenderStore.ctorParameters = [];
	    return RenderStore;
	}());
	exports.RenderStore = RenderStore;
	//# sourceMappingURL=render_store.js.map

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(8);
	var lang_1 = __webpack_require__(5);
	var message_bus_1 = __webpack_require__(17);
	var serializer_1 = __webpack_require__(14);
	/**
	 * @experimental WebWorker support in Angular is currently experimental.
	 */
	var ServiceMessageBrokerFactory = (function () {
	    function ServiceMessageBrokerFactory() {
	    }
	    return ServiceMessageBrokerFactory;
	}());
	exports.ServiceMessageBrokerFactory = ServiceMessageBrokerFactory;
	var ServiceMessageBrokerFactory_ = (function (_super) {
	    __extends(ServiceMessageBrokerFactory_, _super);
	    function ServiceMessageBrokerFactory_(_messageBus, _serializer) {
	        _super.call(this);
	        this._messageBus = _messageBus;
	        this._serializer = _serializer;
	    }
	    ServiceMessageBrokerFactory_.prototype.createMessageBroker = function (channel, runInZone) {
	        if (runInZone === void 0) { runInZone = true; }
	        this._messageBus.initChannel(channel, runInZone);
	        return new ServiceMessageBroker_(this._messageBus, this._serializer, channel);
	    };
	    /** @nocollapse */
	    ServiceMessageBrokerFactory_.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    ServiceMessageBrokerFactory_.ctorParameters = [
	        { type: message_bus_1.MessageBus, },
	        { type: serializer_1.Serializer, },
	    ];
	    return ServiceMessageBrokerFactory_;
	}(ServiceMessageBrokerFactory));
	exports.ServiceMessageBrokerFactory_ = ServiceMessageBrokerFactory_;
	/**
	 * Helper class for UIComponents that allows components to register methods.
	 * If a registered method message is received from the broker on the worker,
	 * the UIMessageBroker deserializes its arguments and calls the registered method.
	 * If that method returns a promise, the UIMessageBroker returns the result to the worker.
	 *
	 * @experimental WebWorker support in Angular is currently experimental.
	 */
	var ServiceMessageBroker = (function () {
	    function ServiceMessageBroker() {
	    }
	    return ServiceMessageBroker;
	}());
	exports.ServiceMessageBroker = ServiceMessageBroker;
	var ServiceMessageBroker_ = (function (_super) {
	    __extends(ServiceMessageBroker_, _super);
	    function ServiceMessageBroker_(messageBus, _serializer, channel /** TODO #9100 */) {
	        var _this = this;
	        _super.call(this);
	        this._serializer = _serializer;
	        this.channel = channel;
	        this._methods = new collection_1.Map();
	        this._sink = messageBus.to(channel);
	        var source = messageBus.from(channel);
	        source.subscribe({ next: function (message) { return _this._handleMessage(message); } });
	    }
	    ServiceMessageBroker_.prototype.registerMethod = function (methodName, signature, method, returnType) {
	        var _this = this;
	        this._methods.set(methodName, function (message) {
	            var serializedArgs = message.args;
	            var numArgs = signature === null ? 0 : signature.length;
	            var deserializedArgs = collection_1.ListWrapper.createFixedSize(numArgs);
	            for (var i = 0; i < numArgs; i++) {
	                var serializedArg = serializedArgs[i];
	                deserializedArgs[i] = _this._serializer.deserialize(serializedArg, signature[i]);
	            }
	            var promise = lang_1.FunctionWrapper.apply(method, deserializedArgs);
	            if (lang_1.isPresent(returnType) && lang_1.isPresent(promise)) {
	                _this._wrapWebWorkerPromise(message.id, promise, returnType);
	            }
	        });
	    };
	    ServiceMessageBroker_.prototype._handleMessage = function (map) {
	        var message = new ReceivedMessage(map);
	        if (this._methods.has(message.method)) {
	            this._methods.get(message.method)(message);
	        }
	    };
	    ServiceMessageBroker_.prototype._wrapWebWorkerPromise = function (id, promise, type) {
	        var _this = this;
	        promise.then(function (result) {
	            _this._sink.emit({ 'type': 'result', 'value': _this._serializer.serialize(result, type), 'id': id });
	        });
	    };
	    return ServiceMessageBroker_;
	}(ServiceMessageBroker));
	exports.ServiceMessageBroker_ = ServiceMessageBroker_;
	/**
	 * @experimental WebWorker support in Angular is currently experimental.
	 */
	var ReceivedMessage = (function () {
	    function ReceivedMessage(data) {
	        this.method = data['method'];
	        this.args = data['args'];
	        this.id = data['id'];
	        this.type = data['type'];
	    }
	    return ReceivedMessage;
	}());
	exports.ReceivedMessage = ReceivedMessage;
	//# sourceMappingURL=service_message_broker.js.map

/***/ },
/* 39 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var HalLinkObject = exports.HalLinkObject = function HalLinkObject(href, templated) {
	    _classCallCheck(this, HalLinkObject);

	    this.href = href;
	    this.templated = templated;
	};

	var HalObject = exports.HalObject = function HalObject(embedded, links, resource) {
	    _classCallCheck(this, HalObject);

	    this.embedded = embedded;
	    this.links = links;
	    this.resource = resource;
	};

	var HalObjectSerializer = exports.HalObjectSerializer = function HalObjectSerializer() {
	    _classCallCheck(this, HalObjectSerializer);
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {"use strict";
	var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	};
	exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);
	/* tslint:disable:no-unused-variable */
	var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
	var freeGlobal = objectTypes[typeof global] && global;
	if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
	    exports.root = freeGlobal;
	}
	//# sourceMappingURL=root.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(292)(module), (function() { return this; }())))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var control_value_accessor_1 = __webpack_require__(13);
	exports.CHECKBOX_VALUE_ACCESSOR = {
	    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
	    useExisting: core_1.forwardRef(function () { return CheckboxControlValueAccessor; }),
	    multi: true
	};
	var CheckboxControlValueAccessor = (function () {
	    function CheckboxControlValueAccessor(_renderer, _elementRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this.onChange = function (_) { };
	        this.onTouched = function () { };
	    }
	    CheckboxControlValueAccessor.prototype.writeValue = function (value) {
	        this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', value);
	    };
	    CheckboxControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	    CheckboxControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    /** @nocollapse */
	    CheckboxControlValueAccessor.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'input[type=checkbox][ngControl],input[type=checkbox][ngFormControl],input[type=checkbox][ngModel]',
	                    host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },
	                    providers: [exports.CHECKBOX_VALUE_ACCESSOR]
	                },] },
	    ];
	    /** @nocollapse */
	    CheckboxControlValueAccessor.ctorParameters = [
	        { type: core_1.Renderer, },
	        { type: core_1.ElementRef, },
	    ];
	    return CheckboxControlValueAccessor;
	}());
	exports.CheckboxControlValueAccessor = CheckboxControlValueAccessor;
	//# sourceMappingURL=checkbox_value_accessor.js.map

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(3);
	var control_value_accessor_1 = __webpack_require__(13);
	exports.DEFAULT_VALUE_ACCESSOR = {
	    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
	    useExisting: core_1.forwardRef(function () { return DefaultValueAccessor; }),
	    multi: true
	};
	var DefaultValueAccessor = (function () {
	    function DefaultValueAccessor(_renderer, _elementRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this.onChange = function (_) { };
	        this.onTouched = function () { };
	    }
	    DefaultValueAccessor.prototype.writeValue = function (value) {
	        var normalizedValue = lang_1.isBlank(value) ? '' : value;
	        this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
	    };
	    DefaultValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	    DefaultValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    /** @nocollapse */
	    DefaultValueAccessor.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'input:not([type=checkbox])[ngControl],textarea[ngControl],input:not([type=checkbox])[ngFormControl],textarea[ngFormControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',
	                    // TODO: vsavkin replace the above selector with the one below it once
	                    // https://github.com/angular/angular/issues/3011 is implemented
	                    // selector: '[ngControl],[ngModel],[ngFormControl]',
	                    host: { '(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
	                    providers: [exports.DEFAULT_VALUE_ACCESSOR]
	                },] },
	    ];
	    /** @nocollapse */
	    DefaultValueAccessor.ctorParameters = [
	        { type: core_1.Renderer, },
	        { type: core_1.ElementRef, },
	    ];
	    return DefaultValueAccessor;
	}());
	exports.DefaultValueAccessor = DefaultValueAccessor;
	//# sourceMappingURL=default_value_accessor.js.map

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(10);
	var lang_1 = __webpack_require__(3);
	var control_value_accessor_1 = __webpack_require__(13);
	var ng_control_1 = __webpack_require__(21);
	exports.RADIO_VALUE_ACCESSOR = {
	    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
	    useExisting: core_1.forwardRef(function () { return RadioControlValueAccessor; }),
	    multi: true
	};
	var RadioControlRegistry = (function () {
	    function RadioControlRegistry() {
	        this._accessors = [];
	    }
	    RadioControlRegistry.prototype.add = function (control, accessor) {
	        this._accessors.push([control, accessor]);
	    };
	    RadioControlRegistry.prototype.remove = function (accessor) {
	        var indexToRemove = -1;
	        for (var i = 0; i < this._accessors.length; ++i) {
	            if (this._accessors[i][1] === accessor) {
	                indexToRemove = i;
	            }
	        }
	        collection_1.ListWrapper.removeAt(this._accessors, indexToRemove);
	    };
	    RadioControlRegistry.prototype.select = function (accessor) {
	        var _this = this;
	        this._accessors.forEach(function (c) {
	            if (_this._isSameGroup(c, accessor) && c[1] !== accessor) {
	                c[1].fireUncheck();
	            }
	        });
	    };
	    RadioControlRegistry.prototype._isSameGroup = function (controlPair, accessor) {
	        return controlPair[0].control.root === accessor._control.control.root &&
	            controlPair[1].name === accessor.name;
	    };
	    /** @nocollapse */
	    RadioControlRegistry.decorators = [
	        { type: core_1.Injectable },
	    ];
	    return RadioControlRegistry;
	}());
	exports.RadioControlRegistry = RadioControlRegistry;
	/**
	 * The value provided by the forms API for radio buttons.
	 *
	 * @experimental
	 */
	var RadioButtonState = (function () {
	    function RadioButtonState(checked, value) {
	        this.checked = checked;
	        this.value = value;
	    }
	    return RadioButtonState;
	}());
	exports.RadioButtonState = RadioButtonState;
	var RadioControlValueAccessor = (function () {
	    function RadioControlValueAccessor(_renderer, _elementRef, _registry, _injector) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this._registry = _registry;
	        this._injector = _injector;
	        this.onChange = function () { };
	        this.onTouched = function () { };
	    }
	    RadioControlValueAccessor.prototype.ngOnInit = function () {
	        this._control = this._injector.get(ng_control_1.NgControl);
	        this._registry.add(this._control, this);
	    };
	    RadioControlValueAccessor.prototype.ngOnDestroy = function () { this._registry.remove(this); };
	    RadioControlValueAccessor.prototype.writeValue = function (value) {
	        this._state = value;
	        if (lang_1.isPresent(value) && value.checked) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', true);
	        }
	    };
	    RadioControlValueAccessor.prototype.registerOnChange = function (fn) {
	        var _this = this;
	        this._fn = fn;
	        this.onChange = function () {
	            fn(new RadioButtonState(true, _this._state.value));
	            _this._registry.select(_this);
	        };
	    };
	    RadioControlValueAccessor.prototype.fireUncheck = function () { this._fn(new RadioButtonState(false, this._state.value)); };
	    RadioControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    /** @nocollapse */
	    RadioControlValueAccessor.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'input[type=radio][ngControl],input[type=radio][ngFormControl],input[type=radio][ngModel]',
	                    host: { '(change)': 'onChange()', '(blur)': 'onTouched()' },
	                    providers: [exports.RADIO_VALUE_ACCESSOR]
	                },] },
	    ];
	    /** @nocollapse */
	    RadioControlValueAccessor.ctorParameters = [
	        { type: core_1.Renderer, },
	        { type: core_1.ElementRef, },
	        { type: RadioControlRegistry, },
	        { type: core_1.Injector, },
	    ];
	    /** @nocollapse */
	    RadioControlValueAccessor.propDecorators = {
	        'name': [{ type: core_1.Input },],
	    };
	    return RadioControlValueAccessor;
	}());
	exports.RadioControlValueAccessor = RadioControlValueAccessor;
	//# sourceMappingURL=radio_control_value_accessor.js.map

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(10);
	var lang_1 = __webpack_require__(3);
	var control_value_accessor_1 = __webpack_require__(13);
	exports.SELECT_VALUE_ACCESSOR = {
	    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
	    useExisting: core_1.forwardRef(function () { return SelectControlValueAccessor; }),
	    multi: true
	};
	function _buildValueString(id, value) {
	    if (lang_1.isBlank(id))
	        return "" + value;
	    if (!lang_1.isPrimitive(value))
	        value = 'Object';
	    return lang_1.StringWrapper.slice(id + ": " + value, 0, 50);
	}
	function _extractId(valueString) {
	    return valueString.split(':')[0];
	}
	var SelectControlValueAccessor = (function () {
	    function SelectControlValueAccessor(_renderer, _elementRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        /** @internal */
	        this._optionMap = new Map();
	        /** @internal */
	        this._idCounter = 0;
	        this.onChange = function (_) { };
	        this.onTouched = function () { };
	    }
	    SelectControlValueAccessor.prototype.writeValue = function (value) {
	        this.value = value;
	        var valueString = _buildValueString(this._getOptionId(value), value);
	        this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', valueString);
	    };
	    SelectControlValueAccessor.prototype.registerOnChange = function (fn) {
	        var _this = this;
	        this.onChange = function (valueString) {
	            _this.value = valueString;
	            fn(_this._getOptionValue(valueString));
	        };
	    };
	    SelectControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    /** @internal */
	    SelectControlValueAccessor.prototype._registerOption = function () { return (this._idCounter++).toString(); };
	    /** @internal */
	    SelectControlValueAccessor.prototype._getOptionId = function (value) {
	        for (var _i = 0, _a = collection_1.MapWrapper.keys(this._optionMap); _i < _a.length; _i++) {
	            var id = _a[_i];
	            if (lang_1.looseIdentical(this._optionMap.get(id), value))
	                return id;
	        }
	        return null;
	    };
	    /** @internal */
	    SelectControlValueAccessor.prototype._getOptionValue = function (valueString) {
	        var value = this._optionMap.get(_extractId(valueString));
	        return lang_1.isPresent(value) ? value : valueString;
	    };
	    /** @nocollapse */
	    SelectControlValueAccessor.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'select:not([multiple])[ngControl],select:not([multiple])[ngFormControl],select:not([multiple])[ngModel]',
	                    host: { '(change)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
	                    providers: [exports.SELECT_VALUE_ACCESSOR]
	                },] },
	    ];
	    /** @nocollapse */
	    SelectControlValueAccessor.ctorParameters = [
	        { type: core_1.Renderer, },
	        { type: core_1.ElementRef, },
	    ];
	    return SelectControlValueAccessor;
	}());
	exports.SelectControlValueAccessor = SelectControlValueAccessor;
	var NgSelectOption = (function () {
	    function NgSelectOption(_element, _renderer, _select) {
	        this._element = _element;
	        this._renderer = _renderer;
	        this._select = _select;
	        if (lang_1.isPresent(this._select))
	            this.id = this._select._registerOption();
	    }
	    Object.defineProperty(NgSelectOption.prototype, "ngValue", {
	        set: function (value) {
	            if (this._select == null)
	                return;
	            this._select._optionMap.set(this.id, value);
	            this._setElementValue(_buildValueString(this.id, value));
	            this._select.writeValue(this._select.value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgSelectOption.prototype, "value", {
	        set: function (value) {
	            this._setElementValue(value);
	            if (lang_1.isPresent(this._select))
	                this._select.writeValue(this._select.value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** @internal */
	    NgSelectOption.prototype._setElementValue = function (value) {
	        this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
	    };
	    NgSelectOption.prototype.ngOnDestroy = function () {
	        if (lang_1.isPresent(this._select)) {
	            this._select._optionMap.delete(this.id);
	            this._select.writeValue(this._select.value);
	        }
	    };
	    /** @nocollapse */
	    NgSelectOption.decorators = [
	        { type: core_1.Directive, args: [{ selector: 'option' },] },
	    ];
	    /** @nocollapse */
	    NgSelectOption.ctorParameters = [
	        { type: core_1.ElementRef, },
	        { type: core_1.Renderer, },
	        { type: SelectControlValueAccessor, decorators: [{ type: core_1.Optional }, { type: core_1.Host },] },
	    ];
	    /** @nocollapse */
	    NgSelectOption.propDecorators = {
	        'ngValue': [{ type: core_1.Input, args: ['ngValue',] },],
	        'value': [{ type: core_1.Input, args: ['value',] },],
	    };
	    return NgSelectOption;
	}());
	exports.NgSelectOption = NgSelectOption;
	//# sourceMappingURL=select_control_value_accessor.js.map

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var PromiseObservable_1 = __webpack_require__(281);
	var async_1 = __webpack_require__(25);
	var collection_1 = __webpack_require__(10);
	var lang_1 = __webpack_require__(3);
	/**
	 * Indicates that a Control is valid, i.e. that no errors exist in the input value.
	 */
	exports.VALID = 'VALID';
	/**
	 * Indicates that a Control is invalid, i.e. that an error exists in the input value.
	 */
	exports.INVALID = 'INVALID';
	/**
	 * Indicates that a Control is pending, i.e. that async validation is occurring and
	 * errors are not yet available for the input value.
	 */
	exports.PENDING = 'PENDING';
	function isControl(control) {
	    return control instanceof AbstractControl;
	}
	exports.isControl = isControl;
	function _find(control, path) {
	    if (lang_1.isBlank(path))
	        return null;
	    if (!(path instanceof Array)) {
	        path = path.split('/');
	    }
	    if (path instanceof Array && collection_1.ListWrapper.isEmpty(path))
	        return null;
	    return path.reduce(function (v, name) {
	        if (v instanceof ControlGroup) {
	            return lang_1.isPresent(v.controls[name]) ? v.controls[name] : null;
	        }
	        else if (v instanceof ControlArray) {
	            var index = name;
	            return lang_1.isPresent(v.at(index)) ? v.at(index) : null;
	        }
	        else {
	            return null;
	        }
	    }, control);
	}
	function toObservable(r) {
	    return lang_1.isPromise(r) ? PromiseObservable_1.PromiseObservable.create(r) : r;
	}
	/**
	 * @experimental
	 */
	var AbstractControl = (function () {
	    function AbstractControl(validator, asyncValidator) {
	        this.validator = validator;
	        this.asyncValidator = asyncValidator;
	        this._pristine = true;
	        this._touched = false;
	    }
	    Object.defineProperty(AbstractControl.prototype, "value", {
	        get: function () { return this._value; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "status", {
	        get: function () { return this._status; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "valid", {
	        get: function () { return this._status === exports.VALID; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "errors", {
	        /**
	         * Returns the errors of this control.
	         */
	        get: function () { return this._errors; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "pristine", {
	        get: function () { return this._pristine; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "dirty", {
	        get: function () { return !this.pristine; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "touched", {
	        get: function () { return this._touched; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "untouched", {
	        get: function () { return !this._touched; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "valueChanges", {
	        get: function () { return this._valueChanges; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "statusChanges", {
	        get: function () { return this._statusChanges; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "pending", {
	        get: function () { return this._status == exports.PENDING; },
	        enumerable: true,
	        configurable: true
	    });
	    AbstractControl.prototype.markAsTouched = function () { this._touched = true; };
	    AbstractControl.prototype.markAsDirty = function (_a) {
	        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	        onlySelf = lang_1.normalizeBool(onlySelf);
	        this._pristine = false;
	        if (lang_1.isPresent(this._parent) && !onlySelf) {
	            this._parent.markAsDirty({ onlySelf: onlySelf });
	        }
	    };
	    AbstractControl.prototype.markAsPending = function (_a) {
	        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	        onlySelf = lang_1.normalizeBool(onlySelf);
	        this._status = exports.PENDING;
	        if (lang_1.isPresent(this._parent) && !onlySelf) {
	            this._parent.markAsPending({ onlySelf: onlySelf });
	        }
	    };
	    AbstractControl.prototype.setParent = function (parent) { this._parent = parent; };
	    AbstractControl.prototype.updateValueAndValidity = function (_a) {
	        var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	        onlySelf = lang_1.normalizeBool(onlySelf);
	        emitEvent = lang_1.isPresent(emitEvent) ? emitEvent : true;
	        this._updateValue();
	        this._errors = this._runValidator();
	        this._status = this._calculateStatus();
	        if (this._status == exports.VALID || this._status == exports.PENDING) {
	            this._runAsyncValidator(emitEvent);
	        }
	        if (emitEvent) {
	            this._valueChanges.emit(this._value);
	            this._statusChanges.emit(this._status);
	        }
	        if (lang_1.isPresent(this._parent) && !onlySelf) {
	            this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        }
	    };
	    AbstractControl.prototype._runValidator = function () {
	        return lang_1.isPresent(this.validator) ? this.validator(this) : null;
	    };
	    AbstractControl.prototype._runAsyncValidator = function (emitEvent) {
	        var _this = this;
	        if (lang_1.isPresent(this.asyncValidator)) {
	            this._status = exports.PENDING;
	            this._cancelExistingSubscription();
	            var obs = toObservable(this.asyncValidator(this));
	            this._asyncValidationSubscription = obs.subscribe({ next: function (res) { return _this.setErrors(res, { emitEvent: emitEvent }); } });
	        }
	    };
	    AbstractControl.prototype._cancelExistingSubscription = function () {
	        if (lang_1.isPresent(this._asyncValidationSubscription)) {
	            this._asyncValidationSubscription.unsubscribe();
	        }
	    };
	    /**
	     * Sets errors on a control.
	     *
	     * This is used when validations are run not automatically, but manually by the user.
	     *
	     * Calling `setErrors` will also update the validity of the parent control.
	     *
	     * ## Usage
	     *
	     * ```
	     * var login = new Control("someLogin");
	     * login.setErrors({
	     *   "notUnique": true
	     * });
	     *
	     * expect(login.valid).toEqual(false);
	     * expect(login.errors).toEqual({"notUnique": true});
	     *
	     * login.updateValue("someOtherLogin");
	     *
	     * expect(login.valid).toEqual(true);
	     * ```
	     */
	    AbstractControl.prototype.setErrors = function (errors, _a) {
	        var emitEvent = (_a === void 0 ? {} : _a).emitEvent;
	        emitEvent = lang_1.isPresent(emitEvent) ? emitEvent : true;
	        this._errors = errors;
	        this._status = this._calculateStatus();
	        if (emitEvent) {
	            this._statusChanges.emit(this._status);
	        }
	        if (lang_1.isPresent(this._parent)) {
	            this._parent._updateControlsErrors();
	        }
	    };
	    AbstractControl.prototype.find = function (path) { return _find(this, path); };
	    AbstractControl.prototype.getError = function (errorCode, path) {
	        if (path === void 0) { path = null; }
	        var control = lang_1.isPresent(path) && !collection_1.ListWrapper.isEmpty(path) ? this.find(path) : this;
	        if (lang_1.isPresent(control) && lang_1.isPresent(control._errors)) {
	            return collection_1.StringMapWrapper.get(control._errors, errorCode);
	        }
	        else {
	            return null;
	        }
	    };
	    AbstractControl.prototype.hasError = function (errorCode, path) {
	        if (path === void 0) { path = null; }
	        return lang_1.isPresent(this.getError(errorCode, path));
	    };
	    Object.defineProperty(AbstractControl.prototype, "root", {
	        get: function () {
	            var x = this;
	            while (lang_1.isPresent(x._parent)) {
	                x = x._parent;
	            }
	            return x;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** @internal */
	    AbstractControl.prototype._updateControlsErrors = function () {
	        this._status = this._calculateStatus();
	        if (lang_1.isPresent(this._parent)) {
	            this._parent._updateControlsErrors();
	        }
	    };
	    /** @internal */
	    AbstractControl.prototype._initObservables = function () {
	        this._valueChanges = new async_1.EventEmitter();
	        this._statusChanges = new async_1.EventEmitter();
	    };
	    AbstractControl.prototype._calculateStatus = function () {
	        if (lang_1.isPresent(this._errors))
	            return exports.INVALID;
	        if (this._anyControlsHaveStatus(exports.PENDING))
	            return exports.PENDING;
	        if (this._anyControlsHaveStatus(exports.INVALID))
	            return exports.INVALID;
	        return exports.VALID;
	    };
	    return AbstractControl;
	}());
	exports.AbstractControl = AbstractControl;
	/**
	 * Defines a part of a form that cannot be divided into other controls. `Control`s have values and
	 * validation state, which is determined by an optional validation function.
	 *
	 * `Control` is one of the three fundamental building blocks used to define forms in Angular, along
	 * with {@link ControlGroup} and {@link ControlArray}.
	 *
	 * ## Usage
	 *
	 * By default, a `Control` is created for every `<input>` or other form component.
	 * With {@link NgFormControl} or {@link NgFormModel} an existing {@link Control} can be
	 * bound to a DOM element instead. This `Control` can be configured with a custom
	 * validation function.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
	 *
	 * @experimental
	 */
	var Control = (function (_super) {
	    __extends(Control, _super);
	    function Control(value, validator, asyncValidator) {
	        if (value === void 0) { value = null; }
	        if (validator === void 0) { validator = null; }
	        if (asyncValidator === void 0) { asyncValidator = null; }
	        _super.call(this, validator, asyncValidator);
	        this._value = value;
	        this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        this._initObservables();
	    }
	    /**
	     * Set the value of the control to `value`.
	     *
	     * If `onlySelf` is `true`, this change will only affect the validation of this `Control`
	     * and not its parent component. If `emitEvent` is `true`, this change will cause a
	     * `valueChanges` event on the `Control` to be emitted. Both of these options default to
	     * `false`.
	     *
	     * If `emitModelToViewChange` is `true`, the view will be notified about the new value
	     * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not
	     * specified.
	     */
	    Control.prototype.updateValue = function (value, _a) {
	        var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent, emitModelToViewChange = _b.emitModelToViewChange;
	        emitModelToViewChange = lang_1.isPresent(emitModelToViewChange) ? emitModelToViewChange : true;
	        this._value = value;
	        if (lang_1.isPresent(this._onChange) && emitModelToViewChange)
	            this._onChange(this._value);
	        this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	    };
	    /**
	     * @internal
	     */
	    Control.prototype._updateValue = function () { };
	    /**
	     * @internal
	     */
	    Control.prototype._anyControlsHaveStatus = function (status) { return false; };
	    /**
	     * Register a listener for change events.
	     */
	    Control.prototype.registerOnChange = function (fn) { this._onChange = fn; };
	    return Control;
	}(AbstractControl));
	exports.Control = Control;
	/**
	 * Defines a part of a form, of fixed length, that can contain other controls.
	 *
	 * A `ControlGroup` aggregates the values of each {@link Control} in the group.
	 * The status of a `ControlGroup` depends on the status of its children.
	 * If one of the controls in a group is invalid, the entire group is invalid.
	 * Similarly, if a control changes its value, the entire group changes as well.
	 *
	 * `ControlGroup` is one of the three fundamental building blocks used to define forms in Angular,
	 * along with {@link Control} and {@link ControlArray}. {@link ControlArray} can also contain other
	 * controls, but is of variable length.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
	 *
	 * @experimental
	 */
	var ControlGroup = (function (_super) {
	    __extends(ControlGroup, _super);
	    function ControlGroup(controls, optionals, validator, asyncValidator) {
	        if (optionals === void 0) { optionals = null; }
	        if (validator === void 0) { validator = null; }
	        if (asyncValidator === void 0) { asyncValidator = null; }
	        _super.call(this, validator, asyncValidator);
	        this.controls = controls;
	        this._optionals = lang_1.isPresent(optionals) ? optionals : {};
	        this._initObservables();
	        this._setParentForControls();
	        this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	    }
	    /**
	     * Register a control with the group's list of controls.
	     */
	    ControlGroup.prototype.registerControl = function (name, control) {
	        this.controls[name] = control;
	        control.setParent(this);
	    };
	    /**
	     * Add a control to this group.
	     */
	    ControlGroup.prototype.addControl = function (name, control) {
	        this.registerControl(name, control);
	        this.updateValueAndValidity();
	    };
	    /**
	     * Remove a control from this group.
	     */
	    ControlGroup.prototype.removeControl = function (name) {
	        collection_1.StringMapWrapper.delete(this.controls, name);
	        this.updateValueAndValidity();
	    };
	    /**
	     * Mark the named control as non-optional.
	     */
	    ControlGroup.prototype.include = function (controlName) {
	        collection_1.StringMapWrapper.set(this._optionals, controlName, true);
	        this.updateValueAndValidity();
	    };
	    /**
	     * Mark the named control as optional.
	     */
	    ControlGroup.prototype.exclude = function (controlName) {
	        collection_1.StringMapWrapper.set(this._optionals, controlName, false);
	        this.updateValueAndValidity();
	    };
	    /**
	     * Check whether there is a control with the given name in the group.
	     */
	    ControlGroup.prototype.contains = function (controlName) {
	        var c = collection_1.StringMapWrapper.contains(this.controls, controlName);
	        return c && this._included(controlName);
	    };
	    /** @internal */
	    ControlGroup.prototype._setParentForControls = function () {
	        var _this = this;
	        collection_1.StringMapWrapper.forEach(this.controls, function (control, name) { control.setParent(_this); });
	    };
	    /** @internal */
	    ControlGroup.prototype._updateValue = function () { this._value = this._reduceValue(); };
	    /** @internal */
	    ControlGroup.prototype._anyControlsHaveStatus = function (status) {
	        var _this = this;
	        var res = false;
	        collection_1.StringMapWrapper.forEach(this.controls, function (control, name) {
	            res = res || (_this.contains(name) && control.status == status);
	        });
	        return res;
	    };
	    /** @internal */
	    ControlGroup.prototype._reduceValue = function () {
	        return this._reduceChildren({}, function (acc, control, name) {
	            acc[name] = control.value;
	            return acc;
	        });
	    };
	    /** @internal */
	    ControlGroup.prototype._reduceChildren = function (initValue, fn) {
	        var _this = this;
	        var res = initValue;
	        collection_1.StringMapWrapper.forEach(this.controls, function (control, name) {
	            if (_this._included(name)) {
	                res = fn(res, control, name);
	            }
	        });
	        return res;
	    };
	    /** @internal */
	    ControlGroup.prototype._included = function (controlName) {
	        var isOptional = collection_1.StringMapWrapper.contains(this._optionals, controlName);
	        return !isOptional || collection_1.StringMapWrapper.get(this._optionals, controlName);
	    };
	    return ControlGroup;
	}(AbstractControl));
	exports.ControlGroup = ControlGroup;
	/**
	 * Defines a part of a form, of variable length, that can contain other controls.
	 *
	 * A `ControlArray` aggregates the values of each {@link Control} in the group.
	 * The status of a `ControlArray` depends on the status of its children.
	 * If one of the controls in a group is invalid, the entire array is invalid.
	 * Similarly, if a control changes its value, the entire array changes as well.
	 *
	 * `ControlArray` is one of the three fundamental building blocks used to define forms in Angular,
	 * along with {@link Control} and {@link ControlGroup}. {@link ControlGroup} can also contain
	 * other controls, but is of fixed length.
	 *
	 * ## Adding or removing controls
	 *
	 * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods
	 * in `ControlArray` itself. These methods ensure the controls are properly tracked in the
	 * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
	 * the `ControlArray` directly, as that will result in strange and unexpected behavior such
	 * as broken change detection.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
	 *
	 * @experimental
	 */
	var ControlArray = (function (_super) {
	    __extends(ControlArray, _super);
	    function ControlArray(controls, validator, asyncValidator) {
	        if (validator === void 0) { validator = null; }
	        if (asyncValidator === void 0) { asyncValidator = null; }
	        _super.call(this, validator, asyncValidator);
	        this.controls = controls;
	        this._initObservables();
	        this._setParentForControls();
	        this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	    }
	    /**
	     * Get the {@link AbstractControl} at the given `index` in the array.
	     */
	    ControlArray.prototype.at = function (index) { return this.controls[index]; };
	    /**
	     * Insert a new {@link AbstractControl} at the end of the array.
	     */
	    ControlArray.prototype.push = function (control) {
	        this.controls.push(control);
	        control.setParent(this);
	        this.updateValueAndValidity();
	    };
	    /**
	     * Insert a new {@link AbstractControl} at the given `index` in the array.
	     */
	    ControlArray.prototype.insert = function (index, control) {
	        collection_1.ListWrapper.insert(this.controls, index, control);
	        control.setParent(this);
	        this.updateValueAndValidity();
	    };
	    /**
	     * Remove the control at the given `index` in the array.
	     */
	    ControlArray.prototype.removeAt = function (index) {
	        collection_1.ListWrapper.removeAt(this.controls, index);
	        this.updateValueAndValidity();
	    };
	    Object.defineProperty(ControlArray.prototype, "length", {
	        /**
	         * Length of the control array.
	         */
	        get: function () { return this.controls.length; },
	        enumerable: true,
	        configurable: true
	    });
	    /** @internal */
	    ControlArray.prototype._updateValue = function () { this._value = this.controls.map(function (control) { return control.value; }); };
	    /** @internal */
	    ControlArray.prototype._anyControlsHaveStatus = function (status) {
	        return this.controls.some(function (c) { return c.status == status; });
	    };
	    /** @internal */
	    ControlArray.prototype._setParentForControls = function () {
	        var _this = this;
	        this.controls.forEach(function (control) { control.setParent(_this); });
	    };
	    return ControlArray;
	}(AbstractControl));
	exports.ControlArray = ControlArray;
	//# sourceMappingURL=model.js.map

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	/**
	 * `LocationStrategy` is responsible for representing and reading route state
	 * from the browser's URL. Angular provides two strategies:
	 * {@link HashLocationStrategy} and {@link PathLocationStrategy} (default).
	 *
	 * This is used under the hood of the {@link Location} service.
	 *
	 * Applications should use the {@link Router} or {@link Location} services to
	 * interact with application route state.
	 *
	 * For instance, {@link HashLocationStrategy} produces URLs like
	 * `http://example.com#/foo`, and {@link PathLocationStrategy} produces
	 * `http://example.com/foo` as an equivalent URL.
	 *
	 * See these two classes for more.
	 *
	 * @stable
	 */
	var LocationStrategy = (function () {
	    function LocationStrategy() {
	    }
	    return LocationStrategy;
	}());
	exports.LocationStrategy = LocationStrategy;
	/**
	 * The `APP_BASE_HREF` token represents the base href to be used with the
	 * {@link PathLocationStrategy}.
	 *
	 * If you're using {@link PathLocationStrategy}, you must provide a provider to a string
	 * representing the URL prefix that should be preserved when generating and recognizing
	 * URLs.
	 *
	 * ### Example
	 *
	 * ```
	 * import {Component} from '@angular/core';
	 * import {ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from '@angular/router';
	 * import {APP_BASE_HREF} from '@angular/common';
	 *
	 * @Component({directives: [ROUTER_DIRECTIVES]})
	 * @RouteConfig([
	 *  {...},
	 * ])
	 * class AppCmp {
	 *   // ...
	 * }
	 *
	 * bootstrap(AppCmp, [
	 *   ROUTER_PROVIDERS,
	 *   {provide: APP_BASE_HREF, useValue: '/my/app'}
	 * ]);
	 * ```
	 * @stable
	 */
	exports.APP_BASE_HREF = new core_1.OpaqueToken('appBaseHref');
	//# sourceMappingURL=location_strategy.js.map

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var di_1 = __webpack_require__(12);
	/**
	 * A DI Token representing a unique string id assigned to the application by Angular and used
	 * primarily for prefixing application attributes and CSS styles when
	 * {@link ViewEncapsulation#Emulated} is being used.
	 *
	 * If you need to avoid randomly generated value to be used as an application id, you can provide
	 * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
	 * using this token.
	 * @experimental
	 */
	exports.APP_ID = new di_1.OpaqueToken('AppId');
	function _appIdRandomProviderFactory() {
	    return "" + _randomChar() + _randomChar() + _randomChar();
	}
	exports._appIdRandomProviderFactory = _appIdRandomProviderFactory;
	/**
	 * Providers that will generate a random APP_ID_TOKEN.
	 * @experimental
	 */
	exports.APP_ID_RANDOM_PROVIDER = {
	    provide: exports.APP_ID,
	    useFactory: _appIdRandomProviderFactory,
	    deps: []
	};
	function _randomChar() {
	    return lang_1.StringWrapper.fromCharCode(97 + lang_1.Math.floor(lang_1.Math.random() * 25));
	}
	/**
	 * A function that will be executed when a platform is initialized.
	 * @experimental
	 */
	exports.PLATFORM_INITIALIZER = new di_1.OpaqueToken('Platform Initializer');
	/**
	 * All callbacks provided via this token will be called for every component that is bootstrapped.
	 * Signature of the callback:
	 *
	 * `(componentRef: ComponentRef) => void`.
	 *
	 * @experimental
	 */
	exports.APP_BOOTSTRAP_LISTENER = new di_1.OpaqueToken('appBootstrapListener');
	/**
	 * A token which indicates the root directory of the application
	 * @experimental
	 */
	exports.PACKAGE_ROOT_URL = new di_1.OpaqueToken('Application Packages Root URL');
	//# sourceMappingURL=application_tokens.js.map

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var default_iterable_differ_1 = __webpack_require__(88);
	var default_keyvalue_differ_1 = __webpack_require__(142);
	var iterable_differs_1 = __webpack_require__(143);
	var keyvalue_differs_1 = __webpack_require__(144);
	var change_detection_util_1 = __webpack_require__(49);
	exports.SimpleChange = change_detection_util_1.SimpleChange;
	exports.UNINITIALIZED = change_detection_util_1.UNINITIALIZED;
	exports.ValueUnwrapper = change_detection_util_1.ValueUnwrapper;
	exports.WrappedValue = change_detection_util_1.WrappedValue;
	exports.devModeEqual = change_detection_util_1.devModeEqual;
	exports.looseIdentical = change_detection_util_1.looseIdentical;
	var change_detector_ref_1 = __webpack_require__(212);
	exports.ChangeDetectorRef = change_detector_ref_1.ChangeDetectorRef;
	var constants_1 = __webpack_require__(50);
	exports.CHANGE_DETECTION_STRATEGY_VALUES = constants_1.CHANGE_DETECTION_STRATEGY_VALUES;
	exports.ChangeDetectionStrategy = constants_1.ChangeDetectionStrategy;
	exports.ChangeDetectorStatus = constants_1.ChangeDetectorStatus;
	exports.isDefaultChangeDetectionStrategy = constants_1.isDefaultChangeDetectionStrategy;
	var default_iterable_differ_2 = __webpack_require__(88);
	exports.CollectionChangeRecord = default_iterable_differ_2.CollectionChangeRecord;
	exports.DefaultIterableDifferFactory = default_iterable_differ_2.DefaultIterableDifferFactory;
	var default_iterable_differ_3 = __webpack_require__(88);
	exports.DefaultIterableDiffer = default_iterable_differ_3.DefaultIterableDiffer;
	var default_keyvalue_differ_2 = __webpack_require__(142);
	exports.DefaultKeyValueDifferFactory = default_keyvalue_differ_2.DefaultKeyValueDifferFactory;
	exports.KeyValueChangeRecord = default_keyvalue_differ_2.KeyValueChangeRecord;
	var iterable_differs_2 = __webpack_require__(143);
	exports.IterableDiffers = iterable_differs_2.IterableDiffers;
	var keyvalue_differs_2 = __webpack_require__(144);
	exports.KeyValueDiffers = keyvalue_differs_2.KeyValueDiffers;
	/**
	 * Structural diffing for `Object`s and `Map`s.
	 */
	exports.keyValDiff = [new default_keyvalue_differ_1.DefaultKeyValueDifferFactory()];
	/**
	 * Structural diffing for `Iterable` types such as `Array`s.
	 */
	exports.iterableDiff = [new default_iterable_differ_1.DefaultIterableDifferFactory()];
	exports.defaultIterableDiffers = new iterable_differs_1.IterableDiffers(exports.iterableDiff);
	exports.defaultKeyValueDiffers = new keyvalue_differs_1.KeyValueDiffers(exports.keyValDiff);
	//# sourceMappingURL=change_detection.js.map

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var lang_1 = __webpack_require__(2);
	var lang_2 = __webpack_require__(2);
	exports.looseIdentical = lang_2.looseIdentical;
	exports.UNINITIALIZED = {
	    toString: function () { return 'CD_INIT_VALUE'; }
	};
	function devModeEqual(a, b) {
	    if (collection_1.isListLikeIterable(a) && collection_1.isListLikeIterable(b)) {
	        return collection_1.areIterablesEqual(a, b, devModeEqual);
	    }
	    else if (!collection_1.isListLikeIterable(a) && !lang_1.isPrimitive(a) && !collection_1.isListLikeIterable(b) && !lang_1.isPrimitive(b)) {
	        return true;
	    }
	    else {
	        return lang_1.looseIdentical(a, b);
	    }
	}
	exports.devModeEqual = devModeEqual;
	/**
	 * Indicates that the result of a {@link PipeMetadata} transformation has changed even though the
	 * reference
	 * has not changed.
	 *
	 * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
	 *
	 * Example:
	 *
	 * ```
	 * if (this._latestValue === this._latestReturnedValue) {
	 *    return this._latestReturnedValue;
	 *  } else {
	 *    this._latestReturnedValue = this._latestValue;
	 *    return WrappedValue.wrap(this._latestValue); // this will force update
	 *  }
	 * ```
	 * @stable
	 */
	var WrappedValue = (function () {
	    function WrappedValue(wrapped) {
	        this.wrapped = wrapped;
	    }
	    WrappedValue.wrap = function (value) { return new WrappedValue(value); };
	    return WrappedValue;
	}());
	exports.WrappedValue = WrappedValue;
	/**
	 * Helper class for unwrapping WrappedValue s
	 */
	var ValueUnwrapper = (function () {
	    function ValueUnwrapper() {
	        this.hasWrappedValue = false;
	    }
	    ValueUnwrapper.prototype.unwrap = function (value) {
	        if (value instanceof WrappedValue) {
	            this.hasWrappedValue = true;
	            return value.wrapped;
	        }
	        return value;
	    };
	    ValueUnwrapper.prototype.reset = function () { this.hasWrappedValue = false; };
	    return ValueUnwrapper;
	}());
	exports.ValueUnwrapper = ValueUnwrapper;
	/**
	 * Represents a basic change from a previous to a new value.
	 * @stable
	 */
	var SimpleChange = (function () {
	    function SimpleChange(previousValue, currentValue) {
	        this.previousValue = previousValue;
	        this.currentValue = currentValue;
	    }
	    /**
	     * Check whether the new value is the first value assigned.
	     */
	    SimpleChange.prototype.isFirstChange = function () { return this.previousValue === exports.UNINITIALIZED; };
	    return SimpleChange;
	}());
	exports.SimpleChange = SimpleChange;
	//# sourceMappingURL=change_detection_util.js.map

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	/**
	 * Describes within the change detector which strategy will be used the next time change
	 * detection is triggered.
	 * @stable
	 */
	(function (ChangeDetectionStrategy) {
	    /**
	     * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.
	     */
	    ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
	    /**
	     * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.
	     */
	    ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
	})(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));
	var ChangeDetectionStrategy = exports.ChangeDetectionStrategy;
	/**
	 * Describes the status of the detector.
	 */
	(function (ChangeDetectorStatus) {
	    /**
	     * `CheckedOnce` means that after calling detectChanges the mode of the change detector
	     * will become `Checked`.
	     */
	    ChangeDetectorStatus[ChangeDetectorStatus["CheckOnce"] = 0] = "CheckOnce";
	    /**
	     * `Checked` means that the change detector should be skipped until its mode changes to
	     * `CheckOnce`.
	     */
	    ChangeDetectorStatus[ChangeDetectorStatus["Checked"] = 1] = "Checked";
	    /**
	     * `CheckAlways` means that after calling detectChanges the mode of the change detector
	     * will remain `CheckAlways`.
	     */
	    ChangeDetectorStatus[ChangeDetectorStatus["CheckAlways"] = 2] = "CheckAlways";
	    /**
	     * `Detached` means that the change detector sub tree is not a part of the main tree and
	     * should be skipped.
	     */
	    ChangeDetectorStatus[ChangeDetectorStatus["Detached"] = 3] = "Detached";
	    /**
	     * `Errored` means that the change detector encountered an error checking a binding
	     * or calling a directive lifecycle method and is now in an inconsistent state. Change
	     * detectors in this state will no longer detect changes.
	     */
	    ChangeDetectorStatus[ChangeDetectorStatus["Errored"] = 4] = "Errored";
	    /**
	     * `Destroyed` means that the change detector is destroyed.
	     */
	    ChangeDetectorStatus[ChangeDetectorStatus["Destroyed"] = 5] = "Destroyed";
	})(exports.ChangeDetectorStatus || (exports.ChangeDetectorStatus = {}));
	var ChangeDetectorStatus = exports.ChangeDetectorStatus;
	/**
	 * List of possible {@link ChangeDetectionStrategy} values.
	 */
	exports.CHANGE_DETECTION_STRATEGY_VALUES = [
	    ChangeDetectionStrategy.OnPush,
	    ChangeDetectionStrategy.Default,
	];
	/**
	 * List of possible {@link ChangeDetectorStatus} values.
	 */
	exports.CHANGE_DETECTOR_STATUS_VALUES = [
	    ChangeDetectorStatus.CheckOnce,
	    ChangeDetectorStatus.Checked,
	    ChangeDetectorStatus.CheckAlways,
	    ChangeDetectorStatus.Detached,
	    ChangeDetectorStatus.Errored,
	    ChangeDetectorStatus.Destroyed,
	];
	function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
	    return lang_1.isBlank(changeDetectionStrategy) ||
	        changeDetectionStrategy === ChangeDetectionStrategy.Default;
	}
	exports.isDefaultChangeDetectionStrategy = isDefaultChangeDetectionStrategy;
	//# sourceMappingURL=constants.js.map

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var decorators_1 = __webpack_require__(30);
	var lang_1 = __webpack_require__(2);
	var Console = (function () {
	    function Console() {
	    }
	    Console.prototype.log = function (message) { lang_1.print(message); };
	    // Note: for reporting errors use `DOM.logError()` as it is platform specific
	    Console.prototype.warn = function (message) { lang_1.warn(message); };
	    /** @nocollapse */
	    Console.decorators = [
	        { type: decorators_1.Injectable },
	    ];
	    return Console;
	}());
	exports.Console = Console;
	//# sourceMappingURL=console.js.map

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	/**
	 * Allows to refer to references which are not yet defined.
	 *
	 * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
	 * DI is declared,
	 * but not yet defined. It is also used when the `token` which we use when creating a query is not
	 * yet defined.
	 *
	 * ### Example
	 * {@example core/di/ts/forward_ref/forward_ref.ts region='forward_ref'}
	 * @experimental
	 */
	function forwardRef(forwardRefFn) {
	    forwardRefFn.__forward_ref__ = forwardRef;
	    forwardRefFn.toString = function () { return lang_1.stringify(this()); };
	    return forwardRefFn;
	}
	exports.forwardRef = forwardRef;
	/**
	 * Lazily retrieves the reference value from a forwardRef.
	 *
	 * Acts as the identity function when given a non-forward-ref value.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
	 *
	 * ```typescript
	 * var ref = forwardRef(() => "refValue");
	 * expect(resolveForwardRef(ref)).toEqual("refValue");
	 * expect(resolveForwardRef("regularValue")).toEqual("regularValue");
	 * ```
	 *
	 * See: {@link forwardRef}
	 * @experimental
	 */
	function resolveForwardRef(type) {
	    if (lang_1.isFunction(type) && type.hasOwnProperty('__forward_ref__') &&
	        type.__forward_ref__ === forwardRef) {
	        return type();
	    }
	    else {
	        return type;
	    }
	}
	exports.resolveForwardRef = resolveForwardRef;
	//# sourceMappingURL=forward_ref.js.map

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	var _THROW_IF_NOT_FOUND = new Object();
	exports.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
	var _NullInjector = (function () {
	    function _NullInjector() {
	    }
	    _NullInjector.prototype.get = function (token, notFoundValue) {
	        if (notFoundValue === void 0) { notFoundValue = _THROW_IF_NOT_FOUND; }
	        if (notFoundValue === _THROW_IF_NOT_FOUND) {
	            throw new exceptions_1.BaseException("No provider for " + lang_1.stringify(token) + "!");
	        }
	        return notFoundValue;
	    };
	    return _NullInjector;
	}());
	/**
	 * @stable
	 */
	var Injector = (function () {
	    function Injector() {
	    }
	    /**
	     * Retrieves an instance from the injector based on the provided token.
	     * If not found:
	     * - Throws {@link NoProviderError} if no `notFoundValue` that is not equal to
	     * Injector.THROW_IF_NOT_FOUND is given
	     * - Returns the `notFoundValue` otherwise
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/HeXSHg?p=preview))
	     *
	     * ```typescript
	     * var injector = ReflectiveInjector.resolveAndCreate([
	     *   {provide: "validToken", useValue: "Value"}
	     * ]);
	     * expect(injector.get("validToken")).toEqual("Value");
	     * expect(() => injector.get("invalidToken")).toThrowError();
	     * ```
	     *
	     * `Injector` returns itself when given `Injector` as a token.
	     *
	     * ```typescript
	     * var injector = ReflectiveInjector.resolveAndCreate([]);
	     * expect(injector.get(Injector)).toBe(injector);
	     * ```
	     */
	    Injector.prototype.get = function (token, notFoundValue) { return exceptions_1.unimplemented(); };
	    Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
	    Injector.NULL = new _NullInjector();
	    return Injector;
	}());
	exports.Injector = Injector;
	//# sourceMappingURL=injector.js.map

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	/**
	 * @stable
	 */
	var NoComponentFactoryError = (function (_super) {
	    __extends(NoComponentFactoryError, _super);
	    function NoComponentFactoryError(component) {
	        _super.call(this, "No component factory found for " + lang_1.stringify(component));
	        this.component = component;
	    }
	    return NoComponentFactoryError;
	}(exceptions_1.BaseException));
	exports.NoComponentFactoryError = NoComponentFactoryError;
	var _NullComponentFactoryResolver = (function () {
	    function _NullComponentFactoryResolver() {
	    }
	    _NullComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
	        throw new NoComponentFactoryError(component);
	    };
	    return _NullComponentFactoryResolver;
	}());
	/**
	 * @stable
	 */
	var ComponentFactoryResolver = (function () {
	    function ComponentFactoryResolver() {
	    }
	    ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();
	    return ComponentFactoryResolver;
	}());
	exports.ComponentFactoryResolver = ComponentFactoryResolver;
	var CodegenComponentFactoryResolver = (function () {
	    function CodegenComponentFactoryResolver(factories, _parent) {
	        this._parent = _parent;
	        this._factories = new Map();
	        for (var i = 0; i < factories.length; i++) {
	            var factory = factories[i];
	            this._factories.set(factory.componentType, factory);
	        }
	    }
	    CodegenComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
	        var result = this._factories.get(component);
	        if (!result) {
	            result = this._parent.resolveComponentFactory(component);
	        }
	        return result;
	    };
	    return CodegenComponentFactoryResolver;
	}());
	exports.CodegenComponentFactoryResolver = CodegenComponentFactoryResolver;
	//# sourceMappingURL=component_factory_resolver.js.map

/***/ },
/* 55 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	(function (ViewType) {
	    // A view that contains the host element with bound component directive.
	    // Contains a COMPONENT view
	    ViewType[ViewType["HOST"] = 0] = "HOST";
	    // The view of the component
	    // Can contain 0 to n EMBEDDED views
	    ViewType[ViewType["COMPONENT"] = 1] = "COMPONENT";
	    // A view that is embedded into another View via a <template> element
	    // inside of a COMPONENT view
	    ViewType[ViewType["EMBEDDED"] = 2] = "EMBEDDED";
	})(exports.ViewType || (exports.ViewType = {}));
	var ViewType = exports.ViewType;
	//# sourceMappingURL=view_type.js.map

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var application_tokens_1 = __webpack_require__(47);
	var change_detection_1 = __webpack_require__(48);
	var change_detection_util_1 = __webpack_require__(49);
	var decorators_1 = __webpack_require__(30);
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	var api_1 = __webpack_require__(99);
	var security_1 = __webpack_require__(166);
	var element_1 = __webpack_require__(95);
	var exceptions_2 = __webpack_require__(96);
	var ViewUtils = (function () {
	    function ViewUtils(_renderer, _appId, sanitizer) {
	        this._renderer = _renderer;
	        this._appId = _appId;
	        this._nextCompTypeId = 0;
	        this.sanitizer = sanitizer;
	    }
	    /**
	     * Used by the generated code
	     */
	    // TODO (matsko): add typing for the animation function
	    ViewUtils.prototype.createRenderComponentType = function (templateUrl, slotCount, encapsulation, styles, animations) {
	        return new api_1.RenderComponentType(this._appId + "-" + this._nextCompTypeId++, templateUrl, slotCount, encapsulation, styles, animations);
	    };
	    /** @internal */
	    ViewUtils.prototype.renderComponent = function (renderComponentType) {
	        return this._renderer.renderComponent(renderComponentType);
	    };
	    /** @nocollapse */
	    ViewUtils.decorators = [
	        { type: decorators_1.Injectable },
	    ];
	    /** @nocollapse */
	    ViewUtils.ctorParameters = [
	        { type: api_1.RootRenderer, },
	        { type: undefined, decorators: [{ type: decorators_1.Inject, args: [application_tokens_1.APP_ID,] },] },
	        { type: security_1.SanitizationService, },
	    ];
	    return ViewUtils;
	}());
	exports.ViewUtils = ViewUtils;
	function flattenNestedViewRenderNodes(nodes) {
	    return _flattenNestedViewRenderNodes(nodes, []);
	}
	exports.flattenNestedViewRenderNodes = flattenNestedViewRenderNodes;
	function _flattenNestedViewRenderNodes(nodes, renderNodes) {
	    for (var i = 0; i < nodes.length; i++) {
	        var node = nodes[i];
	        if (node instanceof element_1.AppElement) {
	            var appEl = node;
	            renderNodes.push(appEl.nativeElement);
	            if (lang_1.isPresent(appEl.nestedViews)) {
	                for (var k = 0; k < appEl.nestedViews.length; k++) {
	                    _flattenNestedViewRenderNodes(appEl.nestedViews[k].rootNodesOrAppElements, renderNodes);
	                }
	            }
	        }
	        else {
	            renderNodes.push(node);
	        }
	    }
	    return renderNodes;
	}
	var EMPTY_ARR = [];
	function ensureSlotCount(projectableNodes, expectedSlotCount) {
	    var res;
	    if (lang_1.isBlank(projectableNodes)) {
	        res = EMPTY_ARR;
	    }
	    else if (projectableNodes.length < expectedSlotCount) {
	        var givenSlotCount = projectableNodes.length;
	        res = collection_1.ListWrapper.createFixedSize(expectedSlotCount);
	        for (var i = 0; i < expectedSlotCount; i++) {
	            res[i] = (i < givenSlotCount) ? projectableNodes[i] : EMPTY_ARR;
	        }
	    }
	    else {
	        res = projectableNodes;
	    }
	    return res;
	}
	exports.ensureSlotCount = ensureSlotCount;
	exports.MAX_INTERPOLATION_VALUES = 9;
	function interpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
	    switch (valueCount) {
	        case 1:
	            return c0 + _toStringWithNull(a1) + c1;
	        case 2:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;
	        case 3:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3;
	        case 4:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4;
	        case 5:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;
	        case 6:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;
	        case 7:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                c6 + _toStringWithNull(a7) + c7;
	        case 8:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;
	        case 9:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;
	        default:
	            throw new exceptions_1.BaseException("Does not support more than 9 expressions");
	    }
	}
	exports.interpolate = interpolate;
	function _toStringWithNull(v) {
	    return v != null ? v.toString() : '';
	}
	function checkBinding(throwOnChange, oldValue, newValue) {
	    if (throwOnChange) {
	        if (!change_detection_1.devModeEqual(oldValue, newValue)) {
	            throw new exceptions_2.ExpressionChangedAfterItHasBeenCheckedException(oldValue, newValue, null);
	        }
	        return false;
	    }
	    else {
	        return !lang_1.looseIdentical(oldValue, newValue);
	    }
	}
	exports.checkBinding = checkBinding;
	function castByValue(input, value) {
	    return input;
	}
	exports.castByValue = castByValue;
	exports.EMPTY_ARRAY = [];
	exports.EMPTY_MAP = {};
	function pureProxy1(fn) {
	    var result;
	    var v0 = change_detection_util_1.UNINITIALIZED;
	    return function (p0) {
	        if (!lang_1.looseIdentical(v0, p0)) {
	            v0 = p0;
	            result = fn(p0);
	        }
	        return result;
	    };
	}
	exports.pureProxy1 = pureProxy1;
	function pureProxy2(fn) {
	    var result;
	    var v0 = change_detection_util_1.UNINITIALIZED;
	    var v1 = change_detection_util_1.UNINITIALIZED;
	    return function (p0, p1) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1)) {
	            v0 = p0;
	            v1 = p1;
	            result = fn(p0, p1);
	        }
	        return result;
	    };
	}
	exports.pureProxy2 = pureProxy2;
	function pureProxy3(fn) {
	    var result;
	    var v0 = change_detection_util_1.UNINITIALIZED;
	    var v1 = change_detection_util_1.UNINITIALIZED;
	    var v2 = change_detection_util_1.UNINITIALIZED;
	    return function (p0, p1, p2) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            result = fn(p0, p1, p2);
	        }
	        return result;
	    };
	}
	exports.pureProxy3 = pureProxy3;
	function pureProxy4(fn) {
	    var result;
	    var v0, v1, v2, v3;
	    v0 = v1 = v2 = v3 = change_detection_util_1.UNINITIALIZED;
	    return function (p0, p1, p2, p3) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
	            !lang_1.looseIdentical(v3, p3)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            result = fn(p0, p1, p2, p3);
	        }
	        return result;
	    };
	}
	exports.pureProxy4 = pureProxy4;
	function pureProxy5(fn) {
	    var result;
	    var v0, v1, v2, v3, v4;
	    v0 = v1 = v2 = v3 = v4 = change_detection_util_1.UNINITIALIZED;
	    return function (p0, p1, p2, p3, p4) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
	            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            result = fn(p0, p1, p2, p3, p4);
	        }
	        return result;
	    };
	}
	exports.pureProxy5 = pureProxy5;
	function pureProxy6(fn) {
	    var result;
	    var v0, v1, v2, v3, v4, v5;
	    v0 = v1 = v2 = v3 = v4 = v5 = change_detection_util_1.UNINITIALIZED;
	    return function (p0, p1, p2, p3, p4, p5) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
	            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            v5 = p5;
	            result = fn(p0, p1, p2, p3, p4, p5);
	        }
	        return result;
	    };
	}
	exports.pureProxy6 = pureProxy6;
	function pureProxy7(fn) {
	    var result;
	    var v0, v1, v2, v3, v4, v5, v6;
	    v0 = v1 = v2 = v3 = v4 = v5 = v6 = change_detection_util_1.UNINITIALIZED;
	    return function (p0, p1, p2, p3, p4, p5, p6) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
	            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5) ||
	            !lang_1.looseIdentical(v6, p6)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            v5 = p5;
	            v6 = p6;
	            result = fn(p0, p1, p2, p3, p4, p5, p6);
	        }
	        return result;
	    };
	}
	exports.pureProxy7 = pureProxy7;
	function pureProxy8(fn) {
	    var result;
	    var v0, v1, v2, v3, v4, v5, v6, v7;
	    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = change_detection_util_1.UNINITIALIZED;
	    return function (p0, p1, p2, p3, p4, p5, p6, p7) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
	            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5) ||
	            !lang_1.looseIdentical(v6, p6) || !lang_1.looseIdentical(v7, p7)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            v5 = p5;
	            v6 = p6;
	            v7 = p7;
	            result = fn(p0, p1, p2, p3, p4, p5, p6, p7);
	        }
	        return result;
	    };
	}
	exports.pureProxy8 = pureProxy8;
	function pureProxy9(fn) {
	    var result;
	    var v0, v1, v2, v3, v4, v5, v6, v7, v8;
	    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = change_detection_util_1.UNINITIALIZED;
	    return function (p0, p1, p2, p3, p4, p5, p6, p7, p8) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
	            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5) ||
	            !lang_1.looseIdentical(v6, p6) || !lang_1.looseIdentical(v7, p7) || !lang_1.looseIdentical(v8, p8)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            v5 = p5;
	            v6 = p6;
	            v7 = p7;
	            v8 = p8;
	            result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8);
	        }
	        return result;
	    };
	}
	exports.pureProxy9 = pureProxy9;
	function pureProxy10(fn) {
	    var result;
	    var v0, v1, v2, v3, v4, v5, v6, v7, v8, v9;
	    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = v9 = change_detection_util_1.UNINITIALIZED;
	    return function (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) {
	        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
	            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5) ||
	            !lang_1.looseIdentical(v6, p6) || !lang_1.looseIdentical(v7, p7) || !lang_1.looseIdentical(v8, p8) ||
	            !lang_1.looseIdentical(v9, p9)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            v5 = p5;
	            v6 = p6;
	            v7 = p7;
	            v8 = p8;
	            v9 = p9;
	            result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
	        }
	        return result;
	    };
	}
	exports.pureProxy10 = pureProxy10;
	//# sourceMappingURL=view_utils.js.map

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var wtf_impl_1 = __webpack_require__(225);
	/**
	 * True if WTF is enabled.
	 */
	exports.wtfEnabled = wtf_impl_1.detectWTF();
	function noopScope(arg0, arg1) {
	    return null;
	}
	/**
	 * Create trace scope.
	 *
	 * Scopes must be strictly nested and are analogous to stack frames, but
	 * do not have to follow the stack frames. Instead it is recommended that they follow logical
	 * nesting. You may want to use
	 * [Event
	 * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
	 * as they are defined in WTF.
	 *
	 * Used to mark scope entry. The return value is used to leave the scope.
	 *
	 *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
	 *
	 *     someMethod() {
	 *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
	 *        // DO SOME WORK HERE
	 *        return wtfLeave(s, 123); // Return value 123
	 *     }
	 *
	 * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
	 * negatively impact the performance of your application. For this reason we recommend that
	 * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
	 * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
	 * exception, will produce incorrect trace, but presence of exception signifies logic error which
	 * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
	 * an exception is expected during normal execution while profiling.
	 *
	 * @experimental
	 */
	exports.wtfCreateScope = exports.wtfEnabled ? wtf_impl_1.createScope : function (signature, flags) { return noopScope; };
	/**
	 * Used to mark end of Scope.
	 *
	 * - `scope` to end.
	 * - `returnValue` (optional) to be passed to the WTF.
	 *
	 * Returns the `returnValue for easy chaining.
	 * @experimental
	 */
	exports.wtfLeave = exports.wtfEnabled ? wtf_impl_1.leave : function (s, r) { return r; };
	/**
	 * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
	 * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
	 * enabled.
	 *
	 *     someMethod() {
	 *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
	 *        var future = new Future.delay(5).then((_) {
	 *          wtfEndTimeRange(s);
	 *        });
	 *     }
	 * @experimental
	 */
	exports.wtfStartTimeRange = exports.wtfEnabled ? wtf_impl_1.startTimeRange : function (rangeType, action) { return null; };
	/**
	 * Ends a async time range operation.
	 * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
	 * enabled.
	 * @experimental
	 */
	exports.wtfEndTimeRange = exports.wtfEnabled ? wtf_impl_1.endTimeRange : function (r) { return null; };
	//# sourceMappingURL=profile.js.map

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var _nextClassId = 0;
	function extractAnnotation(annotation) {
	    if (lang_1.isFunction(annotation) && annotation.hasOwnProperty('annotation')) {
	        // it is a decorator, extract annotation
	        annotation = annotation.annotation;
	    }
	    return annotation;
	}
	function applyParams(fnOrArray, key) {
	    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||
	        fnOrArray === Number || fnOrArray === Array) {
	        throw new Error("Can not use native " + lang_1.stringify(fnOrArray) + " as constructor");
	    }
	    if (lang_1.isFunction(fnOrArray)) {
	        return fnOrArray;
	    }
	    else if (fnOrArray instanceof Array) {
	        var annotations = fnOrArray;
	        var annoLength = annotations.length - 1;
	        var fn = fnOrArray[annoLength];
	        if (!lang_1.isFunction(fn)) {
	            throw new Error("Last position of Class method array must be Function in key " + key + " was '" + lang_1.stringify(fn) + "'");
	        }
	        if (annoLength != fn.length) {
	            throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + lang_1.stringify(fn));
	        }
	        var paramsAnnotations = [];
	        for (var i = 0, ii = annotations.length - 1; i < ii; i++) {
	            var paramAnnotations = [];
	            paramsAnnotations.push(paramAnnotations);
	            var annotation = annotations[i];
	            if (annotation instanceof Array) {
	                for (var j = 0; j < annotation.length; j++) {
	                    paramAnnotations.push(extractAnnotation(annotation[j]));
	                }
	            }
	            else if (lang_1.isFunction(annotation)) {
	                paramAnnotations.push(extractAnnotation(annotation));
	            }
	            else {
	                paramAnnotations.push(annotation);
	            }
	        }
	        Reflect.defineMetadata('parameters', paramsAnnotations, fn);
	        return fn;
	    }
	    else {
	        throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + lang_1.stringify(fnOrArray) + "'");
	    }
	}
	/**
	 * Provides a way for expressing ES6 classes with parameter annotations in ES5.
	 *
	 * ## Basic Example
	 *
	 * ```
	 * var Greeter = ng.Class({
	 *   constructor: function(name) {
	 *     this.name = name;
	 *   },
	 *
	 *   greet: function() {
	 *     alert('Hello ' + this.name + '!');
	 *   }
	 * });
	 * ```
	 *
	 * is equivalent to ES6:
	 *
	 * ```
	 * class Greeter {
	 *   constructor(name) {
	 *     this.name = name;
	 *   }
	 *
	 *   greet() {
	 *     alert('Hello ' + this.name + '!');
	 *   }
	 * }
	 * ```
	 *
	 * or equivalent to ES5:
	 *
	 * ```
	 * var Greeter = function (name) {
	 *   this.name = name;
	 * }
	 *
	 * Greeter.prototype.greet = function () {
	 *   alert('Hello ' + this.name + '!');
	 * }
	 * ```
	 *
	 * ### Example with parameter annotations
	 *
	 * ```
	 * var MyService = ng.Class({
	 *   constructor: [String, [new Query(), QueryList], function(name, queryList) {
	 *     ...
	 *   }]
	 * });
	 * ```
	 *
	 * is equivalent to ES6:
	 *
	 * ```
	 * class MyService {
	 *   constructor(name: string, @Query() queryList: QueryList) {
	 *     ...
	 *   }
	 * }
	 * ```
	 *
	 * ### Example with inheritance
	 *
	 * ```
	 * var Shape = ng.Class({
	 *   constructor: (color) {
	 *     this.color = color;
	 *   }
	 * });
	 *
	 * var Square = ng.Class({
	 *   extends: Shape,
	 *   constructor: function(color, size) {
	 *     Shape.call(this, color);
	 *     this.size = size;
	 *   }
	 * });
	 * ```
	 * @stable
	 */
	function Class(clsDef) {
	    var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
	    var proto = constructor.prototype;
	    if (clsDef.hasOwnProperty('extends')) {
	        if (lang_1.isFunction(clsDef.extends)) {
	            constructor.prototype = proto =
	                Object.create(clsDef.extends.prototype);
	        }
	        else {
	            throw new Error("Class definition 'extends' property must be a constructor function was: " + lang_1.stringify(clsDef.extends));
	        }
	    }
	    for (var key in clsDef) {
	        if (key != 'extends' && key != 'prototype' && clsDef.hasOwnProperty(key)) {
	            proto[key] = applyParams(clsDef[key], key);
	        }
	    }
	    if (this && this.annotations instanceof Array) {
	        Reflect.defineMetadata('annotations', this.annotations, constructor);
	    }
	    if (!constructor['name']) {
	        constructor['overriddenName'] = "class" + _nextClassId++;
	    }
	    return constructor;
	}
	exports.Class = Class;
	var Reflect = lang_1.global.Reflect;
	// Throw statement at top-level is disallowed by closure compiler in ES6 input.
	// Wrap in an IIFE as a work-around.
	(function checkReflect() {
	    if (!(Reflect && Reflect.getMetadata)) {
	        throw 'reflect-metadata shim is required when using class decorators';
	    }
	})();
	function makeDecorator(annotationCls, chainFn) {
	    if (chainFn === void 0) { chainFn = null; }
	    function DecoratorFactory(objOrType) {
	        var annotationInstance = new annotationCls(objOrType);
	        if (this instanceof annotationCls) {
	            return annotationInstance;
	        }
	        else {
	            var chainAnnotation = lang_1.isFunction(this) && this.annotations instanceof Array ? this.annotations : [];
	            chainAnnotation.push(annotationInstance);
	            var TypeDecorator = function TypeDecorator(cls) {
	                var annotations = Reflect.getOwnMetadata('annotations', cls) || [];
	                annotations.push(annotationInstance);
	                Reflect.defineMetadata('annotations', annotations, cls);
	                return cls;
	            };
	            TypeDecorator.annotations = chainAnnotation;
	            TypeDecorator.Class = Class;
	            if (chainFn)
	                chainFn(TypeDecorator);
	            return TypeDecorator;
	        }
	    }
	    DecoratorFactory.prototype = Object.create(annotationCls.prototype);
	    DecoratorFactory.annotationCls = annotationCls;
	    return DecoratorFactory;
	}
	exports.makeDecorator = makeDecorator;
	function makeParamDecorator(annotationCls) {
	    function ParamDecoratorFactory() {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        var annotationInstance = Object.create(annotationCls.prototype);
	        annotationCls.apply(annotationInstance, args);
	        if (this instanceof annotationCls) {
	            return annotationInstance;
	        }
	        else {
	            ParamDecorator.annotation = annotationInstance;
	            return ParamDecorator;
	        }
	        function ParamDecorator(cls, unusedKey, index) {
	            var parameters = Reflect.getMetadata('parameters', cls) || [];
	            // there might be gaps if some in between parameters do not have annotations.
	            // we pad with nulls.
	            while (parameters.length <= index) {
	                parameters.push(null);
	            }
	            parameters[index] = parameters[index] || [];
	            var annotationsForParam = parameters[index];
	            annotationsForParam.push(annotationInstance);
	            Reflect.defineMetadata('parameters', parameters, cls);
	            return cls;
	        }
	    }
	    ParamDecoratorFactory.prototype = Object.create(annotationCls.prototype);
	    ParamDecoratorFactory.annotationCls = annotationCls;
	    return ParamDecoratorFactory;
	}
	exports.makeParamDecorator = makeParamDecorator;
	function makePropDecorator(annotationCls) {
	    function PropDecoratorFactory() {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        var decoratorInstance = Object.create(annotationCls.prototype);
	        annotationCls.apply(decoratorInstance, args);
	        if (this instanceof annotationCls) {
	            return decoratorInstance;
	        }
	        else {
	            return function PropDecorator(target, name) {
	                var meta = Reflect.getOwnMetadata('propMetadata', target.constructor) || {};
	                meta[name] = meta[name] || [];
	                meta[name].unshift(decoratorInstance);
	                Reflect.defineMetadata('propMetadata', meta, target.constructor);
	            };
	        }
	    }
	    PropDecoratorFactory.prototype = Object.create(annotationCls.prototype);
	    PropDecoratorFactory.annotationCls = annotationCls;
	    return PropDecoratorFactory;
	}
	exports.makePropDecorator = makePropDecorator;
	//# sourceMappingURL=decorators.js.map

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(11);
	var enums_1 = __webpack_require__(18);
	var headers_1 = __webpack_require__(32);
	/**
	 * Creates a response options object to be optionally provided when instantiating a
	 * {@link Response}.
	 *
	 * This class is based on the `ResponseInit` description in the [Fetch
	 * Spec](https://fetch.spec.whatwg.org/#responseinit).
	 *
	 * All values are null by default. Typical defaults can be found in the
	 * {@link BaseResponseOptions} class, which sub-classes `ResponseOptions`.
	 *
	 * This class may be used in tests to build {@link Response Responses} for
	 * mock responses (see {@link MockBackend}).
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/P9Jkk8e8cz6NVzbcxEsD?p=preview))
	 *
	 * ```typescript
	 * import {ResponseOptions, Response} from '@angular/http';
	 *
	 * var options = new ResponseOptions({
	 *   body: '{"name":"Jeff"}'
	 * });
	 * var res = new Response(options);
	 *
	 * console.log('res.json():', res.json()); // Object {name: "Jeff"}
	 * ```
	 *
	 * @experimental
	 */
	var ResponseOptions = (function () {
	    function ResponseOptions(_a) {
	        var _b = _a === void 0 ? {} : _a, body = _b.body, status = _b.status, headers = _b.headers, statusText = _b.statusText, type = _b.type, url = _b.url;
	        this.body = lang_1.isPresent(body) ? body : null;
	        this.status = lang_1.isPresent(status) ? status : null;
	        this.headers = lang_1.isPresent(headers) ? headers : null;
	        this.statusText = lang_1.isPresent(statusText) ? statusText : null;
	        this.type = lang_1.isPresent(type) ? type : null;
	        this.url = lang_1.isPresent(url) ? url : null;
	    }
	    /**
	     * Creates a copy of the `ResponseOptions` instance, using the optional input as values to
	     * override
	     * existing values. This method will not change the values of the instance on which it is being
	     * called.
	     *
	     * This may be useful when sharing a base `ResponseOptions` object inside tests,
	     * where certain properties may change from test to test.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/1lXquqFfgduTFBWjNoRE?p=preview))
	     *
	     * ```typescript
	     * import {ResponseOptions, Response} from '@angular/http';
	     *
	     * var options = new ResponseOptions({
	     *   body: {name: 'Jeff'}
	     * });
	     * var res = new Response(options.merge({
	     *   url: 'https://google.com'
	     * }));
	     * console.log('options.url:', options.url); // null
	     * console.log('res.json():', res.json()); // Object {name: "Jeff"}
	     * console.log('res.url:', res.url); // https://google.com
	     * ```
	     */
	    ResponseOptions.prototype.merge = function (options) {
	        return new ResponseOptions({
	            body: lang_1.isPresent(options) && lang_1.isPresent(options.body) ? options.body : this.body,
	            status: lang_1.isPresent(options) && lang_1.isPresent(options.status) ? options.status : this.status,
	            headers: lang_1.isPresent(options) && lang_1.isPresent(options.headers) ? options.headers : this.headers,
	            statusText: lang_1.isPresent(options) && lang_1.isPresent(options.statusText) ? options.statusText :
	                this.statusText,
	            type: lang_1.isPresent(options) && lang_1.isPresent(options.type) ? options.type : this.type,
	            url: lang_1.isPresent(options) && lang_1.isPresent(options.url) ? options.url : this.url,
	        });
	    };
	    return ResponseOptions;
	}());
	exports.ResponseOptions = ResponseOptions;
	var BaseResponseOptions = (function (_super) {
	    __extends(BaseResponseOptions, _super);
	    function BaseResponseOptions() {
	        _super.call(this, { status: 200, statusText: 'Ok', type: enums_1.ResponseType.Default, headers: new headers_1.Headers() });
	    }
	    /** @nocollapse */
	    BaseResponseOptions.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    BaseResponseOptions.ctorParameters = [];
	    return BaseResponseOptions;
	}(ResponseOptions));
	exports.BaseResponseOptions = BaseResponseOptions;
	//# sourceMappingURL=base_response_options.js.map

/***/ },
/* 60 */
[295, 172, 173, 173],
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var exceptions_1 = __webpack_require__(60);
	var lang_1 = __webpack_require__(11);
	var enums_1 = __webpack_require__(18);
	function normalizeMethodName(method) {
	    if (lang_1.isString(method)) {
	        var originalMethod = method;
	        method = method
	            .replace(/(\w)(\w*)/g, function (g0, g1, g2) { return g1.toUpperCase() + g2.toLowerCase(); });
	        method = enums_1.RequestMethod[method];
	        if (typeof method !== 'number')
	            throw exceptions_1.makeTypeError("Invalid request method. The method \"" + originalMethod + "\" is not supported.");
	    }
	    return method;
	}
	exports.normalizeMethodName = normalizeMethodName;
	exports.isSuccess = function (status) { return (status >= 200 && status < 300); };
	function getResponseURL(xhr) {
	    if ('responseURL' in xhr) {
	        return xhr.responseURL;
	    }
	    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
	        return xhr.getResponseHeader('X-Request-URL');
	    }
	    return;
	}
	exports.getResponseURL = getResponseURL;
	function stringToArrayBuffer(input) {
	    var view = new Uint16Array(input.length);
	    for (var i = 0, strLen = input.length; i < strLen; i++) {
	        view[i] = input.charCodeAt(i);
	    }
	    return view.buffer;
	}
	exports.stringToArrayBuffer = stringToArrayBuffer;
	var lang_2 = __webpack_require__(11);
	exports.isJsObject = lang_2.isJsObject;
	//# sourceMappingURL=http_utils.js.map

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(104);
	var lang_1 = __webpack_require__(11);
	function paramParser(rawParams) {
	    if (rawParams === void 0) { rawParams = ''; }
	    var map = new collection_1.Map();
	    if (rawParams.length > 0) {
	        var params = rawParams.split('&');
	        params.forEach(function (param) {
	            var eqIdx = param.indexOf('=');
	            var _a = eqIdx == -1 ? [param, ''] : [param.slice(0, eqIdx), param.slice(eqIdx + 1)], key = _a[0], val = _a[1];
	            var list = map.get(key) || [];
	            list.push(val);
	            map.set(key, list);
	        });
	    }
	    return map;
	}
	/**
	 * @experimental
	 **/
	var QueryEncoder = (function () {
	    function QueryEncoder() {
	    }
	    QueryEncoder.prototype.encodeKey = function (k) { return standardEncoding(k); };
	    QueryEncoder.prototype.encodeValue = function (v) { return standardEncoding(v); };
	    return QueryEncoder;
	}());
	exports.QueryEncoder = QueryEncoder;
	function standardEncoding(v) {
	    return encodeURIComponent(v)
	        .replace(/%40/gi, '@')
	        .replace(/%3A/gi, ':')
	        .replace(/%24/gi, '$')
	        .replace(/%2C/gi, ',')
	        .replace(/%3B/gi, ';')
	        .replace(/%2B/gi, '+')
	        .replace(/%3D/gi, ';')
	        .replace(/%3F/gi, '?')
	        .replace(/%2F/gi, '/');
	}
	/**
	 * Map-like representation of url search parameters, based on
	 * [URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams) in the url living standard,
	 * with several extensions for merging URLSearchParams objects:
	 *   - setAll()
	 *   - appendAll()
	 *   - replaceAll()
	 *
	 * This class accepts an optional second parameter of ${@link QueryEncoder},
	 * which is used to serialize parameters before making a request. By default,
	 * `QueryEncoder` encodes keys and values of parameters using `encodeURIComponent`,
	 * and then un-encodes certain characters that are allowed to be part of the query
	 * according to IETF RFC 3986: https://tools.ietf.org/html/rfc3986.
	 *
	 * These are the characters that are not encoded: `! $ \' ( ) * + , ; A 9 - . _ ~ ? /`
	 *
	 * If the set of allowed query characters is not acceptable for a particular backend,
	 * `QueryEncoder` can be subclassed and provided as the 2nd argument to URLSearchParams.
	 *
	 * ```
	 * import {URLSearchParams, QueryEncoder} from '@angular/http';
	 * class MyQueryEncoder extends QueryEncoder {
	 *   encodeKey(k: string): string {
	 *     return myEncodingFunction(k);
	 *   }
	 *
	 *   encodeValue(v: string): string {
	 *     return myEncodingFunction(v);
	 *   }
	 * }
	 *
	 * let params = new URLSearchParams('', new MyQueryEncoder());
	 * ```
	 * @experimental
	 */
	var URLSearchParams = (function () {
	    function URLSearchParams(rawParams, queryEncoder) {
	        if (rawParams === void 0) { rawParams = ''; }
	        if (queryEncoder === void 0) { queryEncoder = new QueryEncoder(); }
	        this.rawParams = rawParams;
	        this.queryEncoder = queryEncoder;
	        this.paramsMap = paramParser(rawParams);
	    }
	    URLSearchParams.prototype.clone = function () {
	        var clone = new URLSearchParams('', this.queryEncoder);
	        clone.appendAll(this);
	        return clone;
	    };
	    URLSearchParams.prototype.has = function (param) { return this.paramsMap.has(param); };
	    URLSearchParams.prototype.get = function (param) {
	        var storedParam = this.paramsMap.get(param);
	        if (collection_1.isListLikeIterable(storedParam)) {
	            return collection_1.ListWrapper.first(storedParam);
	        }
	        else {
	            return null;
	        }
	    };
	    URLSearchParams.prototype.getAll = function (param) {
	        var mapParam = this.paramsMap.get(param);
	        return lang_1.isPresent(mapParam) ? mapParam : [];
	    };
	    URLSearchParams.prototype.set = function (param, val) {
	        var mapParam = this.paramsMap.get(param);
	        var list = lang_1.isPresent(mapParam) ? mapParam : [];
	        collection_1.ListWrapper.clear(list);
	        list.push(val);
	        this.paramsMap.set(param, list);
	    };
	    // A merge operation
	    // For each name-values pair in `searchParams`, perform `set(name, values[0])`
	    //
	    // E.g: "a=[1,2,3], c=[8]" + "a=[4,5,6], b=[7]" = "a=[4], c=[8], b=[7]"
	    //
	    // TODO(@caitp): document this better
	    URLSearchParams.prototype.setAll = function (searchParams) {
	        var _this = this;
	        searchParams.paramsMap.forEach(function (value, param) {
	            var mapParam = _this.paramsMap.get(param);
	            var list = lang_1.isPresent(mapParam) ? mapParam : [];
	            collection_1.ListWrapper.clear(list);
	            list.push(value[0]);
	            _this.paramsMap.set(param, list);
	        });
	    };
	    URLSearchParams.prototype.append = function (param, val) {
	        var mapParam = this.paramsMap.get(param);
	        var list = lang_1.isPresent(mapParam) ? mapParam : [];
	        list.push(val);
	        this.paramsMap.set(param, list);
	    };
	    // A merge operation
	    // For each name-values pair in `searchParams`, perform `append(name, value)`
	    // for each value in `values`.
	    //
	    // E.g: "a=[1,2], c=[8]" + "a=[3,4], b=[7]" = "a=[1,2,3,4], c=[8], b=[7]"
	    //
	    // TODO(@caitp): document this better
	    URLSearchParams.prototype.appendAll = function (searchParams) {
	        var _this = this;
	        searchParams.paramsMap.forEach(function (value, param) {
	            var mapParam = _this.paramsMap.get(param);
	            var list = lang_1.isPresent(mapParam) ? mapParam : [];
	            for (var i = 0; i < value.length; ++i) {
	                list.push(value[i]);
	            }
	            _this.paramsMap.set(param, list);
	        });
	    };
	    // A merge operation
	    // For each name-values pair in `searchParams`, perform `delete(name)`,
	    // followed by `set(name, values)`
	    //
	    // E.g: "a=[1,2,3], c=[8]" + "a=[4,5,6], b=[7]" = "a=[4,5,6], c=[8], b=[7]"
	    //
	    // TODO(@caitp): document this better
	    URLSearchParams.prototype.replaceAll = function (searchParams) {
	        var _this = this;
	        searchParams.paramsMap.forEach(function (value, param) {
	            var mapParam = _this.paramsMap.get(param);
	            var list = lang_1.isPresent(mapParam) ? mapParam : [];
	            collection_1.ListWrapper.clear(list);
	            for (var i = 0; i < value.length; ++i) {
	                list.push(value[i]);
	            }
	            _this.paramsMap.set(param, list);
	        });
	    };
	    URLSearchParams.prototype.toString = function () {
	        var _this = this;
	        var paramsList = [];
	        this.paramsMap.forEach(function (values, k) {
	            values.forEach(function (v) { return paramsList.push(_this.queryEncoder.encodeKey(k) + '=' + _this.queryEncoder.encodeValue(v)); });
	        });
	        return paramsList.join('&');
	    };
	    URLSearchParams.prototype.delete = function (param) { this.paramsMap.delete(param); };
	    return URLSearchParams;
	}());
	exports.URLSearchParams = URLSearchParams;
	//# sourceMappingURL=url_search_params.js.map

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var common_1 = __webpack_require__(28);
	var core_1 = __webpack_require__(1);
	var core_private_1 = __webpack_require__(34);
	var animation_driver_1 = __webpack_require__(65);
	var web_animations_driver_1 = __webpack_require__(241);
	var browser_adapter_1 = __webpack_require__(176);
	var browser_platform_location_1 = __webpack_require__(64);
	var testability_1 = __webpack_require__(177);
	var ng_probe_1 = __webpack_require__(178);
	var dom_adapter_1 = __webpack_require__(7);
	var dom_renderer_1 = __webpack_require__(66);
	var dom_tokens_1 = __webpack_require__(35);
	var dom_events_1 = __webpack_require__(106);
	var event_manager_1 = __webpack_require__(23);
	var hammer_gestures_1 = __webpack_require__(107);
	var key_events_1 = __webpack_require__(179);
	var shared_styles_host_1 = __webpack_require__(67);
	var dom_sanitization_service_1 = __webpack_require__(183);
	exports.INTERNAL_BROWSER_PLATFORM_PROVIDERS = [
	    { provide: core_1.PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true },
	    { provide: common_1.PlatformLocation, useClass: browser_platform_location_1.BrowserPlatformLocation }
	];
	/**
	 * A set of providers to initialize the Angular platform in a web browser.
	 *
	 * Used automatically by `bootstrap`, or can be passed to `platform`.
	 *
	 * @deprecated Use `platformBrowser()` or create a custom platform factory via
	 * `createPlatformFactory(platformBrowser, ...)`
	 */
	exports.BROWSER_PLATFORM_PROVIDERS = [core_1.PLATFORM_COMMON_PROVIDERS, exports.INTERNAL_BROWSER_PLATFORM_PROVIDERS];
	/**
	 * @security Replacing built-in sanitization providers exposes the application to XSS risks.
	 * Attacker-controlled data introduced by an unsanitized provider could expose your
	 * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
	 * @experimental
	 */
	exports.BROWSER_SANITIZATION_PROVIDERS = [
	    { provide: core_1.SanitizationService, useExisting: dom_sanitization_service_1.DomSanitizationService },
	    { provide: dom_sanitization_service_1.DomSanitizationService, useClass: dom_sanitization_service_1.DomSanitizationServiceImpl },
	];
	/**
	 * A set of providers to initialize an Angular application in a web browser.
	 *
	 * Used automatically by `bootstrap`, or can be passed to {@link PlatformRef
	 * PlatformRef.application}.
	 *
	 * @deprecated Create a module that includes `BrowserModule` instead. This is empty for backwards
	 * compatibility,
	 * as all of our bootstrap methods add a module implicitly, i.e. keeping this filled would add the
	 * providers 2x.
	 */
	exports.BROWSER_APP_PROVIDERS = [];
	/**
	 * @experimental API related to bootstrapping are still under review.
	 */
	exports.platformBrowser = core_1.createPlatformFactory(core_1.platformCore, 'browser', exports.INTERNAL_BROWSER_PLATFORM_PROVIDERS);
	/**
	 * @deprecated Use {@link platformBrowser} instead
	 */
	exports.browserPlatform = exports.platformBrowser;
	function initDomAdapter() {
	    browser_adapter_1.BrowserDomAdapter.makeCurrent();
	    core_private_1.wtfInit();
	    testability_1.BrowserGetTestability.init();
	}
	exports.initDomAdapter = initDomAdapter;
	function _exceptionHandler() {
	    return new core_1.ExceptionHandler(dom_adapter_1.getDOM());
	}
	exports._exceptionHandler = _exceptionHandler;
	function _document() {
	    return dom_adapter_1.getDOM().defaultDoc();
	}
	exports._document = _document;
	function _resolveDefaultAnimationDriver() {
	    if (dom_adapter_1.getDOM().supportsWebAnimation()) {
	        return new web_animations_driver_1.WebAnimationsDriver();
	    }
	    return animation_driver_1.AnimationDriver.NOOP;
	}
	exports._resolveDefaultAnimationDriver = _resolveDefaultAnimationDriver;
	var BrowserModule = (function () {
	    function BrowserModule() {
	    }
	    /** @nocollapse */
	    BrowserModule.decorators = [
	        { type: core_1.NgModule, args: [{
	                    providers: [
	                        exports.BROWSER_SANITIZATION_PROVIDERS,
	                        { provide: core_1.ExceptionHandler, useFactory: _exceptionHandler, deps: [] },
	                        { provide: dom_tokens_1.DOCUMENT, useFactory: _document, deps: [] },
	                        { provide: event_manager_1.EVENT_MANAGER_PLUGINS, useClass: dom_events_1.DomEventsPlugin, multi: true },
	                        { provide: event_manager_1.EVENT_MANAGER_PLUGINS, useClass: key_events_1.KeyEventsPlugin, multi: true },
	                        { provide: event_manager_1.EVENT_MANAGER_PLUGINS, useClass: hammer_gestures_1.HammerGesturesPlugin, multi: true },
	                        { provide: hammer_gestures_1.HAMMER_GESTURE_CONFIG, useClass: hammer_gestures_1.HammerGestureConfig },
	                        { provide: dom_renderer_1.DomRootRenderer, useClass: dom_renderer_1.DomRootRenderer_ },
	                        { provide: core_1.RootRenderer, useExisting: dom_renderer_1.DomRootRenderer },
	                        { provide: shared_styles_host_1.SharedStylesHost, useExisting: shared_styles_host_1.DomSharedStylesHost },
	                        { provide: animation_driver_1.AnimationDriver, useFactory: _resolveDefaultAnimationDriver }, shared_styles_host_1.DomSharedStylesHost,
	                        core_1.Testability, event_manager_1.EventManager, ng_probe_1.ELEMENT_PROBE_PROVIDERS
	                    ],
	                    exports: [common_1.CommonModule, core_1.ApplicationModule]
	                },] },
	    ];
	    return BrowserModule;
	}());
	exports.BrowserModule = BrowserModule;
	//# sourceMappingURL=browser.js.map

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var common_1 = __webpack_require__(28);
	var core_1 = __webpack_require__(1);
	var dom_adapter_1 = __webpack_require__(7);
	var history_1 = __webpack_require__(235);
	var BrowserPlatformLocation = (function (_super) {
	    __extends(BrowserPlatformLocation, _super);
	    function BrowserPlatformLocation() {
	        _super.call(this);
	        this._init();
	    }
	    // This is moved to its own method so that `MockPlatformLocationStrategy` can overwrite it
	    /** @internal */
	    BrowserPlatformLocation.prototype._init = function () {
	        this._location = dom_adapter_1.getDOM().getLocation();
	        this._history = dom_adapter_1.getDOM().getHistory();
	    };
	    Object.defineProperty(BrowserPlatformLocation.prototype, "location", {
	        /** @internal */
	        get: function () { return this._location; },
	        enumerable: true,
	        configurable: true
	    });
	    BrowserPlatformLocation.prototype.getBaseHrefFromDOM = function () { return dom_adapter_1.getDOM().getBaseHref(); };
	    BrowserPlatformLocation.prototype.onPopState = function (fn) {
	        dom_adapter_1.getDOM().getGlobalEventTarget('window').addEventListener('popstate', fn, false);
	    };
	    BrowserPlatformLocation.prototype.onHashChange = function (fn) {
	        dom_adapter_1.getDOM().getGlobalEventTarget('window').addEventListener('hashchange', fn, false);
	    };
	    Object.defineProperty(BrowserPlatformLocation.prototype, "pathname", {
	        get: function () { return this._location.pathname; },
	        set: function (newPath) { this._location.pathname = newPath; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BrowserPlatformLocation.prototype, "search", {
	        get: function () { return this._location.search; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BrowserPlatformLocation.prototype, "hash", {
	        get: function () { return this._location.hash; },
	        enumerable: true,
	        configurable: true
	    });
	    BrowserPlatformLocation.prototype.pushState = function (state, title, url) {
	        if (history_1.supportsState()) {
	            this._history.pushState(state, title, url);
	        }
	        else {
	            this._location.hash = url;
	        }
	    };
	    BrowserPlatformLocation.prototype.replaceState = function (state, title, url) {
	        if (history_1.supportsState()) {
	            this._history.replaceState(state, title, url);
	        }
	        else {
	            this._location.hash = url;
	        }
	    };
	    BrowserPlatformLocation.prototype.forward = function () { this._history.forward(); };
	    BrowserPlatformLocation.prototype.back = function () { this._history.back(); };
	    /** @nocollapse */
	    BrowserPlatformLocation.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    BrowserPlatformLocation.ctorParameters = [];
	    return BrowserPlatformLocation;
	}(common_1.PlatformLocation));
	exports.BrowserPlatformLocation = BrowserPlatformLocation;
	//# sourceMappingURL=browser_platform_location.js.map

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_private_1 = __webpack_require__(34);
	var _NoOpAnimationDriver = (function () {
	    function _NoOpAnimationDriver() {
	    }
	    _NoOpAnimationDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
	        return new core_private_1.NoOpAnimationPlayer();
	    };
	    return _NoOpAnimationDriver;
	}());
	/**
	 * @experimental
	 */
	var AnimationDriver = (function () {
	    function AnimationDriver() {
	    }
	    AnimationDriver.NOOP = new _NoOpAnimationDriver();
	    return AnimationDriver;
	}());
	exports.AnimationDriver = AnimationDriver;
	//# sourceMappingURL=animation_driver.js.map

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var exceptions_1 = __webpack_require__(19);
	var lang_1 = __webpack_require__(5);
	var animation_driver_1 = __webpack_require__(65);
	var dom_adapter_1 = __webpack_require__(7);
	var dom_tokens_1 = __webpack_require__(35);
	var event_manager_1 = __webpack_require__(23);
	var shared_styles_host_1 = __webpack_require__(67);
	var util_1 = __webpack_require__(180);
	var NAMESPACE_URIS = {
	    'xlink': 'http://www.w3.org/1999/xlink',
	    'svg': 'http://www.w3.org/2000/svg',
	    'xhtml': 'http://www.w3.org/1999/xhtml'
	};
	var TEMPLATE_COMMENT_TEXT = 'template bindings={}';
	var TEMPLATE_BINDINGS_EXP = /^template bindings=(.*)$/;
	var DomRootRenderer = (function () {
	    function DomRootRenderer(document, eventManager, sharedStylesHost, animationDriver) {
	        this.document = document;
	        this.eventManager = eventManager;
	        this.sharedStylesHost = sharedStylesHost;
	        this.animationDriver = animationDriver;
	        this.registeredComponents = new Map();
	    }
	    DomRootRenderer.prototype.renderComponent = function (componentProto) {
	        var renderer = this.registeredComponents.get(componentProto.id);
	        if (lang_1.isBlank(renderer)) {
	            renderer = new DomRenderer(this, componentProto, this.animationDriver);
	            this.registeredComponents.set(componentProto.id, renderer);
	        }
	        return renderer;
	    };
	    return DomRootRenderer;
	}());
	exports.DomRootRenderer = DomRootRenderer;
	var DomRootRenderer_ = (function (_super) {
	    __extends(DomRootRenderer_, _super);
	    function DomRootRenderer_(_document, _eventManager, sharedStylesHost, animationDriver) {
	        _super.call(this, _document, _eventManager, sharedStylesHost, animationDriver);
	    }
	    /** @nocollapse */
	    DomRootRenderer_.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    DomRootRenderer_.ctorParameters = [
	        { type: undefined, decorators: [{ type: core_1.Inject, args: [dom_tokens_1.DOCUMENT,] },] },
	        { type: event_manager_1.EventManager, },
	        { type: shared_styles_host_1.DomSharedStylesHost, },
	        { type: animation_driver_1.AnimationDriver, },
	    ];
	    return DomRootRenderer_;
	}(DomRootRenderer));
	exports.DomRootRenderer_ = DomRootRenderer_;
	var DomRenderer = (function () {
	    function DomRenderer(_rootRenderer, componentProto, _animationDriver) {
	        this._rootRenderer = _rootRenderer;
	        this.componentProto = componentProto;
	        this._animationDriver = _animationDriver;
	        this._styles = _flattenStyles(componentProto.id, componentProto.styles, []);
	        if (componentProto.encapsulation !== core_1.ViewEncapsulation.Native) {
	            this._rootRenderer.sharedStylesHost.addStyles(this._styles);
	        }
	        if (this.componentProto.encapsulation === core_1.ViewEncapsulation.Emulated) {
	            this._contentAttr = _shimContentAttribute(componentProto.id);
	            this._hostAttr = _shimHostAttribute(componentProto.id);
	        }
	        else {
	            this._contentAttr = null;
	            this._hostAttr = null;
	        }
	    }
	    DomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
	        var el;
	        if (lang_1.isString(selectorOrNode)) {
	            el = dom_adapter_1.getDOM().querySelector(this._rootRenderer.document, selectorOrNode);
	            if (lang_1.isBlank(el)) {
	                throw new exceptions_1.BaseException("The selector \"" + selectorOrNode + "\" did not match any elements");
	            }
	        }
	        else {
	            el = selectorOrNode;
	        }
	        dom_adapter_1.getDOM().clearNodes(el);
	        return el;
	    };
	    DomRenderer.prototype.createElement = function (parent, name, debugInfo) {
	        var nsAndName = splitNamespace(name);
	        var el = lang_1.isPresent(nsAndName[0]) ?
	            dom_adapter_1.getDOM().createElementNS(NAMESPACE_URIS[nsAndName[0]], nsAndName[1]) :
	            dom_adapter_1.getDOM().createElement(nsAndName[1]);
	        if (lang_1.isPresent(this._contentAttr)) {
	            dom_adapter_1.getDOM().setAttribute(el, this._contentAttr, '');
	        }
	        if (lang_1.isPresent(parent)) {
	            dom_adapter_1.getDOM().appendChild(parent, el);
	        }
	        return el;
	    };
	    DomRenderer.prototype.createViewRoot = function (hostElement) {
	        var nodesParent;
	        if (this.componentProto.encapsulation === core_1.ViewEncapsulation.Native) {
	            nodesParent = dom_adapter_1.getDOM().createShadowRoot(hostElement);
	            this._rootRenderer.sharedStylesHost.addHost(nodesParent);
	            for (var i = 0; i < this._styles.length; i++) {
	                dom_adapter_1.getDOM().appendChild(nodesParent, dom_adapter_1.getDOM().createStyleElement(this._styles[i]));
	            }
	        }
	        else {
	            if (lang_1.isPresent(this._hostAttr)) {
	                dom_adapter_1.getDOM().setAttribute(hostElement, this._hostAttr, '');
	            }
	            nodesParent = hostElement;
	        }
	        return nodesParent;
	    };
	    DomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
	        var comment = dom_adapter_1.getDOM().createComment(TEMPLATE_COMMENT_TEXT);
	        if (lang_1.isPresent(parentElement)) {
	            dom_adapter_1.getDOM().appendChild(parentElement, comment);
	        }
	        return comment;
	    };
	    DomRenderer.prototype.createText = function (parentElement, value, debugInfo) {
	        var node = dom_adapter_1.getDOM().createTextNode(value);
	        if (lang_1.isPresent(parentElement)) {
	            dom_adapter_1.getDOM().appendChild(parentElement, node);
	        }
	        return node;
	    };
	    DomRenderer.prototype.projectNodes = function (parentElement, nodes) {
	        if (lang_1.isBlank(parentElement))
	            return;
	        appendNodes(parentElement, nodes);
	    };
	    DomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) { moveNodesAfterSibling(node, viewRootNodes); };
	    DomRenderer.prototype.detachView = function (viewRootNodes) {
	        for (var i = 0; i < viewRootNodes.length; i++) {
	            dom_adapter_1.getDOM().remove(viewRootNodes[i]);
	        }
	    };
	    DomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
	        if (this.componentProto.encapsulation === core_1.ViewEncapsulation.Native && lang_1.isPresent(hostElement)) {
	            this._rootRenderer.sharedStylesHost.removeHost(dom_adapter_1.getDOM().getShadowRoot(hostElement));
	        }
	    };
	    DomRenderer.prototype.listen = function (renderElement, name, callback) {
	        return this._rootRenderer.eventManager.addEventListener(renderElement, name, decoratePreventDefault(callback));
	    };
	    DomRenderer.prototype.listenGlobal = function (target, name, callback) {
	        return this._rootRenderer.eventManager.addGlobalEventListener(target, name, decoratePreventDefault(callback));
	    };
	    DomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
	        dom_adapter_1.getDOM().setProperty(renderElement, propertyName, propertyValue);
	    };
	    DomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
	        var attrNs;
	        var nsAndName = splitNamespace(attributeName);
	        if (lang_1.isPresent(nsAndName[0])) {
	            attributeName = nsAndName[0] + ':' + nsAndName[1];
	            attrNs = NAMESPACE_URIS[nsAndName[0]];
	        }
	        if (lang_1.isPresent(attributeValue)) {
	            if (lang_1.isPresent(attrNs)) {
	                dom_adapter_1.getDOM().setAttributeNS(renderElement, attrNs, attributeName, attributeValue);
	            }
	            else {
	                dom_adapter_1.getDOM().setAttribute(renderElement, attributeName, attributeValue);
	            }
	        }
	        else {
	            if (lang_1.isPresent(attrNs)) {
	                dom_adapter_1.getDOM().removeAttributeNS(renderElement, attrNs, nsAndName[1]);
	            }
	            else {
	                dom_adapter_1.getDOM().removeAttribute(renderElement, attributeName);
	            }
	        }
	    };
	    DomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
	        var dashCasedPropertyName = util_1.camelCaseToDashCase(propertyName);
	        if (dom_adapter_1.getDOM().isCommentNode(renderElement)) {
	            var existingBindings = lang_1.StringWrapper.replaceAll(dom_adapter_1.getDOM().getText(renderElement), /\n/g, '')
	                .match(TEMPLATE_BINDINGS_EXP);
	            var parsedBindings = lang_1.Json.parse(existingBindings[1]);
	            parsedBindings[dashCasedPropertyName] = propertyValue;
	            dom_adapter_1.getDOM().setText(renderElement, lang_1.StringWrapper.replace(TEMPLATE_COMMENT_TEXT, '{}', lang_1.Json.stringify(parsedBindings)));
	        }
	        else {
	            this.setElementAttribute(renderElement, propertyName, propertyValue);
	        }
	    };
	    DomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
	        if (isAdd) {
	            dom_adapter_1.getDOM().addClass(renderElement, className);
	        }
	        else {
	            dom_adapter_1.getDOM().removeClass(renderElement, className);
	        }
	    };
	    DomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
	        if (lang_1.isPresent(styleValue)) {
	            dom_adapter_1.getDOM().setStyle(renderElement, styleName, lang_1.stringify(styleValue));
	        }
	        else {
	            dom_adapter_1.getDOM().removeStyle(renderElement, styleName);
	        }
	    };
	    DomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
	        dom_adapter_1.getDOM().invoke(renderElement, methodName, args);
	    };
	    DomRenderer.prototype.setText = function (renderNode, text) { dom_adapter_1.getDOM().setText(renderNode, text); };
	    DomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
	        return this._animationDriver.animate(element, startingStyles, keyframes, duration, delay, easing);
	    };
	    return DomRenderer;
	}());
	exports.DomRenderer = DomRenderer;
	function moveNodesAfterSibling(sibling /** TODO #9100 */, nodes /** TODO #9100 */) {
	    var parent = dom_adapter_1.getDOM().parentElement(sibling);
	    if (nodes.length > 0 && lang_1.isPresent(parent)) {
	        var nextSibling = dom_adapter_1.getDOM().nextSibling(sibling);
	        if (lang_1.isPresent(nextSibling)) {
	            for (var i = 0; i < nodes.length; i++) {
	                dom_adapter_1.getDOM().insertBefore(nextSibling, nodes[i]);
	            }
	        }
	        else {
	            for (var i = 0; i < nodes.length; i++) {
	                dom_adapter_1.getDOM().appendChild(parent, nodes[i]);
	            }
	        }
	    }
	}
	function appendNodes(parent /** TODO #9100 */, nodes /** TODO #9100 */) {
	    for (var i = 0; i < nodes.length; i++) {
	        dom_adapter_1.getDOM().appendChild(parent, nodes[i]);
	    }
	}
	function decoratePreventDefault(eventHandler) {
	    return function (event /** TODO #9100 */) {
	        var allowDefaultBehavior = eventHandler(event);
	        if (allowDefaultBehavior === false) {
	            // TODO(tbosch): move preventDefault into event plugins...
	            dom_adapter_1.getDOM().preventDefault(event);
	        }
	    };
	}
	var COMPONENT_REGEX = /%COMP%/g;
	exports.COMPONENT_VARIABLE = '%COMP%';
	exports.HOST_ATTR = "_nghost-" + exports.COMPONENT_VARIABLE;
	exports.CONTENT_ATTR = "_ngcontent-" + exports.COMPONENT_VARIABLE;
	function _shimContentAttribute(componentShortId) {
	    return lang_1.StringWrapper.replaceAll(exports.CONTENT_ATTR, COMPONENT_REGEX, componentShortId);
	}
	function _shimHostAttribute(componentShortId) {
	    return lang_1.StringWrapper.replaceAll(exports.HOST_ATTR, COMPONENT_REGEX, componentShortId);
	}
	function _flattenStyles(compId, styles, target) {
	    for (var i = 0; i < styles.length; i++) {
	        var style = styles[i];
	        if (lang_1.isArray(style)) {
	            _flattenStyles(compId, style, target);
	        }
	        else {
	            style = lang_1.StringWrapper.replaceAll(style, COMPONENT_REGEX, compId);
	            target.push(style);
	        }
	    }
	    return target;
	}
	var NS_PREFIX_RE = /^:([^:]+):(.+)$/;
	function splitNamespace(name) {
	    if (name[0] != ':') {
	        return [null, name];
	    }
	    var match = name.match(NS_PREFIX_RE);
	    return [match[1], match[2]];
	}
	//# sourceMappingURL=dom_renderer.js.map

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(8);
	var dom_adapter_1 = __webpack_require__(7);
	var dom_tokens_1 = __webpack_require__(35);
	var SharedStylesHost = (function () {
	    function SharedStylesHost() {
	        /** @internal */
	        this._styles = [];
	        /** @internal */
	        this._stylesSet = new Set();
	    }
	    SharedStylesHost.prototype.addStyles = function (styles) {
	        var _this = this;
	        var additions = [];
	        styles.forEach(function (style) {
	            if (!collection_1.SetWrapper.has(_this._stylesSet, style)) {
	                _this._stylesSet.add(style);
	                _this._styles.push(style);
	                additions.push(style);
	            }
	        });
	        this.onStylesAdded(additions);
	    };
	    SharedStylesHost.prototype.onStylesAdded = function (additions) { };
	    SharedStylesHost.prototype.getAllStyles = function () { return this._styles; };
	    /** @nocollapse */
	    SharedStylesHost.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    SharedStylesHost.ctorParameters = [];
	    return SharedStylesHost;
	}());
	exports.SharedStylesHost = SharedStylesHost;
	var DomSharedStylesHost = (function (_super) {
	    __extends(DomSharedStylesHost, _super);
	    function DomSharedStylesHost(doc) {
	        _super.call(this);
	        this._hostNodes = new Set();
	        this._hostNodes.add(doc.head);
	    }
	    /** @internal */
	    DomSharedStylesHost.prototype._addStylesToHost = function (styles, host) {
	        for (var i = 0; i < styles.length; i++) {
	            var style = styles[i];
	            dom_adapter_1.getDOM().appendChild(host, dom_adapter_1.getDOM().createStyleElement(style));
	        }
	    };
	    DomSharedStylesHost.prototype.addHost = function (hostNode) {
	        this._addStylesToHost(this._styles, hostNode);
	        this._hostNodes.add(hostNode);
	    };
	    DomSharedStylesHost.prototype.removeHost = function (hostNode) { collection_1.SetWrapper.delete(this._hostNodes, hostNode); };
	    DomSharedStylesHost.prototype.onStylesAdded = function (additions) {
	        var _this = this;
	        this._hostNodes.forEach(function (hostNode) { _this._addStylesToHost(additions, hostNode); });
	    };
	    /** @nocollapse */
	    DomSharedStylesHost.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    DomSharedStylesHost.ctorParameters = [
	        { type: undefined, decorators: [{ type: core_1.Inject, args: [dom_tokens_1.DOCUMENT,] },] },
	    ];
	    return DomSharedStylesHost;
	}(SharedStylesHost));
	exports.DomSharedStylesHost = DomSharedStylesHost;
	//# sourceMappingURL=shared_styles_host.js.map

/***/ },
/* 68 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * All channels used by angular's WebWorker components are listed here.
	 * You should not use these channels in your application code.
	 */
	exports.RENDERER_CHANNEL = 'ng-Renderer';
	exports.EVENT_CHANNEL = 'ng-Events';
	exports.ROUTER_CHANNEL = 'ng-Router';
	//# sourceMappingURL=messaging_api.js.map

/***/ },
/* 69 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var HalResourceFactory = exports.HalResourceFactory = function HalResourceFactory() {
	  _classCallCheck(this, HalResourceFactory);
	};

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(10);
	var lang_1 = __webpack_require__(3);
	var _CASE_DEFAULT = new Object();
	// TODO: remove when fully deprecated
	var _warned = false;
	var SwitchView = (function () {
	    function SwitchView(_viewContainerRef, _templateRef) {
	        this._viewContainerRef = _viewContainerRef;
	        this._templateRef = _templateRef;
	    }
	    SwitchView.prototype.create = function () { this._viewContainerRef.createEmbeddedView(this._templateRef); };
	    SwitchView.prototype.destroy = function () { this._viewContainerRef.clear(); };
	    return SwitchView;
	}());
	exports.SwitchView = SwitchView;
	var NgSwitch = (function () {
	    function NgSwitch() {
	        this._useDefault = false;
	        this._valueViews = new Map();
	        this._activeViews = [];
	    }
	    Object.defineProperty(NgSwitch.prototype, "ngSwitch", {
	        set: function (value) {
	            // Empty the currently active ViewContainers
	            this._emptyAllActiveViews();
	            // Add the ViewContainers matching the value (with a fallback to default)
	            this._useDefault = false;
	            var views = this._valueViews.get(value);
	            if (lang_1.isBlank(views)) {
	                this._useDefault = true;
	                views = lang_1.normalizeBlank(this._valueViews.get(_CASE_DEFAULT));
	            }
	            this._activateViews(views);
	            this._switchValue = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** @internal */
	    NgSwitch.prototype._onCaseValueChanged = function (oldCase, newCase, view) {
	        this._deregisterView(oldCase, view);
	        this._registerView(newCase, view);
	        if (oldCase === this._switchValue) {
	            view.destroy();
	            collection_1.ListWrapper.remove(this._activeViews, view);
	        }
	        else if (newCase === this._switchValue) {
	            if (this._useDefault) {
	                this._useDefault = false;
	                this._emptyAllActiveViews();
	            }
	            view.create();
	            this._activeViews.push(view);
	        }
	        // Switch to default when there is no more active ViewContainers
	        if (this._activeViews.length === 0 && !this._useDefault) {
	            this._useDefault = true;
	            this._activateViews(this._valueViews.get(_CASE_DEFAULT));
	        }
	    };
	    /** @internal */
	    NgSwitch.prototype._emptyAllActiveViews = function () {
	        var activeContainers = this._activeViews;
	        for (var i = 0; i < activeContainers.length; i++) {
	            activeContainers[i].destroy();
	        }
	        this._activeViews = [];
	    };
	    /** @internal */
	    NgSwitch.prototype._activateViews = function (views) {
	        // TODO(vicb): assert(this._activeViews.length === 0);
	        if (lang_1.isPresent(views)) {
	            for (var i = 0; i < views.length; i++) {
	                views[i].create();
	            }
	            this._activeViews = views;
	        }
	    };
	    /** @internal */
	    NgSwitch.prototype._registerView = function (value, view) {
	        var views = this._valueViews.get(value);
	        if (lang_1.isBlank(views)) {
	            views = [];
	            this._valueViews.set(value, views);
	        }
	        views.push(view);
	    };
	    /** @internal */
	    NgSwitch.prototype._deregisterView = function (value, view) {
	        // `_CASE_DEFAULT` is used a marker for non-registered cases
	        if (value === _CASE_DEFAULT)
	            return;
	        var views = this._valueViews.get(value);
	        if (views.length == 1) {
	            this._valueViews.delete(value);
	        }
	        else {
	            collection_1.ListWrapper.remove(views, view);
	        }
	    };
	    /** @nocollapse */
	    NgSwitch.decorators = [
	        { type: core_1.Directive, args: [{ selector: '[ngSwitch]' },] },
	    ];
	    /** @nocollapse */
	    NgSwitch.propDecorators = {
	        'ngSwitch': [{ type: core_1.Input },],
	    };
	    return NgSwitch;
	}());
	exports.NgSwitch = NgSwitch;
	var NgSwitchCase = (function () {
	    function NgSwitchCase(viewContainer, templateRef, ngSwitch) {
	        // `_CASE_DEFAULT` is used as a marker for a not yet initialized value
	        /** @internal */
	        this._value = _CASE_DEFAULT;
	        this._switch = ngSwitch;
	        this._view = new SwitchView(viewContainer, templateRef);
	    }
	    Object.defineProperty(NgSwitchCase.prototype, "ngSwitchCase", {
	        set: function (value) {
	            this._switch._onCaseValueChanged(this._value, value, this._view);
	            this._value = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgSwitchCase.prototype, "ngSwitchWhen", {
	        set: function (value) {
	            if (!_warned) {
	                _warned = true;
	                console.warn('*ngSwitchWhen is deprecated and will be removed. Use *ngSwitchCase instead');
	            }
	            this._switch._onCaseValueChanged(this._value, value, this._view);
	            this._value = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** @nocollapse */
	    NgSwitchCase.decorators = [
	        { type: core_1.Directive, args: [{ selector: '[ngSwitchCase],[ngSwitchWhen]' },] },
	    ];
	    /** @nocollapse */
	    NgSwitchCase.ctorParameters = [
	        { type: core_1.ViewContainerRef, },
	        { type: core_1.TemplateRef, },
	        { type: NgSwitch, decorators: [{ type: core_1.Host },] },
	    ];
	    /** @nocollapse */
	    NgSwitchCase.propDecorators = {
	        'ngSwitchCase': [{ type: core_1.Input },],
	        'ngSwitchWhen': [{ type: core_1.Input },],
	    };
	    return NgSwitchCase;
	}());
	exports.NgSwitchCase = NgSwitchCase;
	var NgSwitchDefault = (function () {
	    function NgSwitchDefault(viewContainer, templateRef, sswitch) {
	        sswitch._registerView(_CASE_DEFAULT, new SwitchView(viewContainer, templateRef));
	    }
	    /** @nocollapse */
	    NgSwitchDefault.decorators = [
	        { type: core_1.Directive, args: [{ selector: '[ngSwitchDefault]' },] },
	    ];
	    /** @nocollapse */
	    NgSwitchDefault.ctorParameters = [
	        { type: core_1.ViewContainerRef, },
	        { type: core_1.TemplateRef, },
	        { type: NgSwitch, decorators: [{ type: core_1.Host },] },
	    ];
	    return NgSwitchDefault;
	}());
	exports.NgSwitchDefault = NgSwitchDefault;
	//# sourceMappingURL=ng_switch.js.map

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var exceptions_1 = __webpack_require__(20);
	var lang_1 = __webpack_require__(3);
	/**
	 * Base class for control directives.
	 *
	 * Only used internally in the forms module.
	 *
	 * @experimental
	 */
	var AbstractControlDirective = (function () {
	    function AbstractControlDirective() {
	    }
	    Object.defineProperty(AbstractControlDirective.prototype, "control", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControlDirective.prototype, "value", {
	        get: function () { return lang_1.isPresent(this.control) ? this.control.value : null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControlDirective.prototype, "valid", {
	        get: function () { return lang_1.isPresent(this.control) ? this.control.valid : null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControlDirective.prototype, "errors", {
	        get: function () {
	            return lang_1.isPresent(this.control) ? this.control.errors : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControlDirective.prototype, "pristine", {
	        get: function () { return lang_1.isPresent(this.control) ? this.control.pristine : null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControlDirective.prototype, "dirty", {
	        get: function () { return lang_1.isPresent(this.control) ? this.control.dirty : null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControlDirective.prototype, "touched", {
	        get: function () { return lang_1.isPresent(this.control) ? this.control.touched : null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControlDirective.prototype, "untouched", {
	        get: function () { return lang_1.isPresent(this.control) ? this.control.untouched : null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControlDirective.prototype, "path", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    return AbstractControlDirective;
	}());
	exports.AbstractControlDirective = AbstractControlDirective;
	//# sourceMappingURL=abstract_control_directive.js.map

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var validators_1 = __webpack_require__(15);
	var control_container_1 = __webpack_require__(29);
	var shared_1 = __webpack_require__(26);
	exports.controlGroupProvider = {
	    provide: control_container_1.ControlContainer,
	    useExisting: core_1.forwardRef(function () { return NgControlGroup; })
	};
	var NgControlGroup = (function (_super) {
	    __extends(NgControlGroup, _super);
	    function NgControlGroup(parent, _validators, _asyncValidators) {
	        _super.call(this);
	        this._validators = _validators;
	        this._asyncValidators = _asyncValidators;
	        this._parent = parent;
	    }
	    NgControlGroup.prototype.ngOnInit = function () { this.formDirective.addControlGroup(this); };
	    NgControlGroup.prototype.ngOnDestroy = function () { this.formDirective.removeControlGroup(this); };
	    Object.defineProperty(NgControlGroup.prototype, "control", {
	        /**
	         * Get the {@link ControlGroup} backing this binding.
	         */
	        get: function () { return this.formDirective.getControlGroup(this); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlGroup.prototype, "path", {
	        /**
	         * Get the path to this control group.
	         */
	        get: function () { return shared_1.controlPath(this.name, this._parent); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlGroup.prototype, "formDirective", {
	        /**
	         * Get the {@link Form} to which this group belongs.
	         */
	        get: function () { return this._parent.formDirective; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlGroup.prototype, "validator", {
	        get: function () { return shared_1.composeValidators(this._validators); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlGroup.prototype, "asyncValidator", {
	        get: function () { return shared_1.composeAsyncValidators(this._asyncValidators); },
	        enumerable: true,
	        configurable: true
	    });
	    /** @nocollapse */
	    NgControlGroup.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: '[ngControlGroup]',
	                    providers: [exports.controlGroupProvider],
	                    inputs: ['name: ngControlGroup'],
	                    exportAs: 'ngForm'
	                },] },
	    ];
	    /** @nocollapse */
	    NgControlGroup.ctorParameters = [
	        { type: control_container_1.ControlContainer, decorators: [{ type: core_1.Host }, { type: core_1.SkipSelf },] },
	        { type: Array, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_VALIDATORS,] },] },
	        { type: Array, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_ASYNC_VALIDATORS,] },] },
	    ];
	    return NgControlGroup;
	}(control_container_1.ControlContainer));
	exports.NgControlGroup = NgControlGroup;
	//# sourceMappingURL=ng_control_group.js.map

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var async_1 = __webpack_require__(25);
	var validators_1 = __webpack_require__(15);
	var control_container_1 = __webpack_require__(29);
	var control_value_accessor_1 = __webpack_require__(13);
	var ng_control_1 = __webpack_require__(21);
	var shared_1 = __webpack_require__(26);
	exports.controlNameBinding = {
	    provide: ng_control_1.NgControl,
	    useExisting: core_1.forwardRef(function () { return NgControlName; })
	};
	var NgControlName = (function (_super) {
	    __extends(NgControlName, _super);
	    function NgControlName(_parent, _validators, _asyncValidators, valueAccessors) {
	        _super.call(this);
	        this._parent = _parent;
	        this._validators = _validators;
	        this._asyncValidators = _asyncValidators;
	        /** @internal */
	        this.update = new async_1.EventEmitter();
	        this._added = false;
	        this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);
	    }
	    NgControlName.prototype.ngOnChanges = function (changes) {
	        if (!this._added) {
	            this.formDirective.addControl(this);
	            this._added = true;
	        }
	        if (shared_1.isPropertyUpdated(changes, this.viewModel)) {
	            this.viewModel = this.model;
	            this.formDirective.updateModel(this, this.model);
	        }
	    };
	    NgControlName.prototype.ngOnDestroy = function () { this.formDirective.removeControl(this); };
	    NgControlName.prototype.viewToModelUpdate = function (newValue) {
	        this.viewModel = newValue;
	        this.update.emit(newValue);
	    };
	    Object.defineProperty(NgControlName.prototype, "path", {
	        get: function () { return shared_1.controlPath(this.name, this._parent); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlName.prototype, "formDirective", {
	        get: function () { return this._parent.formDirective; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlName.prototype, "validator", {
	        get: function () { return shared_1.composeValidators(this._validators); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlName.prototype, "asyncValidator", {
	        get: function () {
	            return shared_1.composeAsyncValidators(this._asyncValidators);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlName.prototype, "control", {
	        get: function () { return this.formDirective.getControl(this); },
	        enumerable: true,
	        configurable: true
	    });
	    /** @nocollapse */
	    NgControlName.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: '[ngControl]',
	                    providers: [exports.controlNameBinding],
	                    inputs: ['name: ngControl', 'model: ngModel'],
	                    outputs: ['update: ngModelChange'],
	                    exportAs: 'ngForm'
	                },] },
	    ];
	    /** @nocollapse */
	    NgControlName.ctorParameters = [
	        { type: control_container_1.ControlContainer, decorators: [{ type: core_1.Host }, { type: core_1.SkipSelf },] },
	        { type: Array, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_VALIDATORS,] },] },
	        { type: Array, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_ASYNC_VALIDATORS,] },] },
	        { type: Array, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [control_value_accessor_1.NG_VALUE_ACCESSOR,] },] },
	    ];
	    return NgControlName;
	}(ng_control_1.NgControl));
	exports.NgControlName = NgControlName;
	//# sourceMappingURL=ng_control_name.js.map

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(3);
	var ng_control_1 = __webpack_require__(21);
	var NgControlStatus = (function () {
	    function NgControlStatus(cd) {
	        this._cd = cd;
	    }
	    Object.defineProperty(NgControlStatus.prototype, "ngClassUntouched", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.untouched : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlStatus.prototype, "ngClassTouched", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.touched : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlStatus.prototype, "ngClassPristine", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.pristine : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlStatus.prototype, "ngClassDirty", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.dirty : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlStatus.prototype, "ngClassValid", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.valid : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlStatus.prototype, "ngClassInvalid", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? !this._cd.control.valid : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** @nocollapse */
	    NgControlStatus.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: '[ngControl],[ngModel],[ngFormControl]',
	                    host: {
	                        '[class.ng-untouched]': 'ngClassUntouched',
	                        '[class.ng-touched]': 'ngClassTouched',
	                        '[class.ng-pristine]': 'ngClassPristine',
	                        '[class.ng-dirty]': 'ngClassDirty',
	                        '[class.ng-valid]': 'ngClassValid',
	                        '[class.ng-invalid]': 'ngClassInvalid'
	                    }
	                },] },
	    ];
	    /** @nocollapse */
	    NgControlStatus.ctorParameters = [
	        { type: ng_control_1.NgControl, decorators: [{ type: core_1.Self },] },
	    ];
	    return NgControlStatus;
	}());
	exports.NgControlStatus = NgControlStatus;
	//# sourceMappingURL=ng_control_status.js.map

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var async_1 = __webpack_require__(25);
	var collection_1 = __webpack_require__(10);
	var lang_1 = __webpack_require__(3);
	var model_1 = __webpack_require__(45);
	var validators_1 = __webpack_require__(15);
	var control_container_1 = __webpack_require__(29);
	var shared_1 = __webpack_require__(26);
	exports.formDirectiveProvider = {
	    provide: control_container_1.ControlContainer,
	    useExisting: core_1.forwardRef(function () { return NgForm; })
	};
	var _formWarningDisplayed = false;
	var resolvedPromise = Promise.resolve(null);
	var NgForm = (function (_super) {
	    __extends(NgForm, _super);
	    function NgForm(validators, asyncValidators) {
	        _super.call(this);
	        this._submitted = false;
	        this.ngSubmit = new async_1.EventEmitter();
	        this._displayWarning();
	        this.form = new model_1.ControlGroup({}, null, shared_1.composeValidators(validators), shared_1.composeAsyncValidators(asyncValidators));
	    }
	    NgForm.prototype._displayWarning = function () {
	        // TODO(kara): Update this when the new forms module becomes the default
	        if (!_formWarningDisplayed) {
	            _formWarningDisplayed = true;
	            console.warn("\n      *It looks like you're using the old forms module. This will be opt-in in the next RC, and\n      will eventually be removed in favor of the new forms module. For more information, see:\n      https://docs.google.com/document/d/1RIezQqE4aEhBRmArIAS1mRIZtWFf6JxN_7B4meyWK0Y/preview\n    ");
	        }
	    };
	    Object.defineProperty(NgForm.prototype, "submitted", {
	        get: function () { return this._submitted; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgForm.prototype, "formDirective", {
	        get: function () { return this; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgForm.prototype, "control", {
	        get: function () { return this.form; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgForm.prototype, "path", {
	        get: function () { return []; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgForm.prototype, "controls", {
	        get: function () { return this.form.controls; },
	        enumerable: true,
	        configurable: true
	    });
	    NgForm.prototype.addControl = function (dir) {
	        var _this = this;
	        resolvedPromise.then(function () {
	            var container = _this._findContainer(dir.path);
	            var ctrl = new model_1.Control();
	            shared_1.setUpControl(ctrl, dir);
	            container.registerControl(dir.name, ctrl);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	        });
	    };
	    NgForm.prototype.getControl = function (dir) { return this.form.find(dir.path); };
	    NgForm.prototype.removeControl = function (dir) {
	        var _this = this;
	        resolvedPromise.then(function () {
	            var container = _this._findContainer(dir.path);
	            if (lang_1.isPresent(container)) {
	                container.removeControl(dir.name);
	            }
	        });
	    };
	    NgForm.prototype.addControlGroup = function (dir) {
	        var _this = this;
	        resolvedPromise.then(function () {
	            var container = _this._findContainer(dir.path);
	            var group = new model_1.ControlGroup({});
	            shared_1.setUpControlGroup(group, dir);
	            container.registerControl(dir.name, group);
	            group.updateValueAndValidity({ emitEvent: false });
	        });
	    };
	    NgForm.prototype.removeControlGroup = function (dir) {
	        var _this = this;
	        resolvedPromise.then(function () {
	            var container = _this._findContainer(dir.path);
	            if (lang_1.isPresent(container)) {
	                container.removeControl(dir.name);
	            }
	        });
	    };
	    NgForm.prototype.getControlGroup = function (dir) {
	        return this.form.find(dir.path);
	    };
	    NgForm.prototype.updateModel = function (dir, value) {
	        var _this = this;
	        resolvedPromise.then(function () {
	            var ctrl = _this.form.find(dir.path);
	            ctrl.updateValue(value);
	        });
	    };
	    NgForm.prototype.onSubmit = function () {
	        this._submitted = true;
	        this.ngSubmit.emit(null);
	        return false;
	    };
	    /** @internal */
	    NgForm.prototype._findContainer = function (path) {
	        path.pop();
	        return collection_1.ListWrapper.isEmpty(path) ? this.form : this.form.find(path);
	    };
	    /** @nocollapse */
	    NgForm.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'form:not([ngNoForm]):not([ngFormModel]),ngForm,[ngForm]',
	                    providers: [exports.formDirectiveProvider],
	                    host: {
	                        '(submit)': 'onSubmit()',
	                    },
	                    outputs: ['ngSubmit'],
	                    exportAs: 'ngForm'
	                },] },
	    ];
	    /** @nocollapse */
	    NgForm.ctorParameters = [
	        { type: Array, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_VALIDATORS,] },] },
	        { type: Array, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_ASYNC_VALIDATORS,] },] },
	    ];
	    return NgForm;
	}(control_container_1.ControlContainer));
	exports.NgForm = NgForm;
	//# sourceMappingURL=ng_form.js.map

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var async_1 = __webpack_require__(25);
	var collection_1 = __webpack_require__(10);
	var validators_1 = __webpack_require__(15);
	var control_value_accessor_1 = __webpack_require__(13);
	var ng_control_1 = __webpack_require__(21);
	var shared_1 = __webpack_require__(26);
	exports.formControlBinding = {
	    provide: ng_control_1.NgControl,
	    useExisting: core_1.forwardRef(function () { return NgFormControl; })
	};
	var NgFormControl = (function (_super) {
	    __extends(NgFormControl, _super);
	    function NgFormControl(_validators, _asyncValidators, valueAccessors) {
	        _super.call(this);
	        this._validators = _validators;
	        this._asyncValidators = _asyncValidators;
	        this.update = new async_1.EventEmitter();
	        this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);
	    }
	    NgFormControl.prototype.ngOnChanges = function (changes) {
	        if (this._isControlChanged(changes)) {
	            shared_1.setUpControl(this.form, this);
	            this.form.updateValueAndValidity({ emitEvent: false });
	        }
	        if (shared_1.isPropertyUpdated(changes, this.viewModel)) {
	            this.form.updateValue(this.model);
	            this.viewModel = this.model;
	        }
	    };
	    Object.defineProperty(NgFormControl.prototype, "path", {
	        get: function () { return []; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgFormControl.prototype, "validator", {
	        get: function () { return shared_1.composeValidators(this._validators); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgFormControl.prototype, "asyncValidator", {
	        get: function () {
	            return shared_1.composeAsyncValidators(this._asyncValidators);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgFormControl.prototype, "control", {
	        get: function () { return this.form; },
	        enumerable: true,
	        configurable: true
	    });
	    NgFormControl.prototype.viewToModelUpdate = function (newValue) {
	        this.viewModel = newValue;
	        this.update.emit(newValue);
	    };
	    NgFormControl.prototype._isControlChanged = function (changes) {
	        return collection_1.StringMapWrapper.contains(changes, 'form');
	    };
	    /** @nocollapse */
	    NgFormControl.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: '[ngFormControl]',
	                    providers: [exports.formControlBinding],
	                    inputs: ['form: ngFormControl', 'model: ngModel'],
	                    outputs: ['update: ngModelChange'],
	                    exportAs: 'ngForm'
	                },] },
	    ];
	    /** @nocollapse */
	    NgFormControl.ctorParameters = [
	        { type: Array, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_VALIDATORS,] },] },
	        { type: Array, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_ASYNC_VALIDATORS,] },] },
	        { type: Array, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [control_value_accessor_1.NG_VALUE_ACCESSOR,] },] },
	    ];
	    return NgFormControl;
	}(ng_control_1.NgControl));
	exports.NgFormControl = NgFormControl;
	//# sourceMappingURL=ng_form_control.js.map

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var async_1 = __webpack_require__(25);
	var collection_1 = __webpack_require__(10);
	var exceptions_1 = __webpack_require__(20);
	var lang_1 = __webpack_require__(3);
	var validators_1 = __webpack_require__(15);
	var control_container_1 = __webpack_require__(29);
	var shared_1 = __webpack_require__(26);
	exports.formDirectiveProvider = {
	    provide: control_container_1.ControlContainer,
	    useExisting: core_1.forwardRef(function () { return NgFormModel; })
	};
	var _formModelWarningDisplayed = false;
	var NgFormModel = (function (_super) {
	    __extends(NgFormModel, _super);
	    function NgFormModel(_validators, _asyncValidators) {
	        _super.call(this);
	        this._validators = _validators;
	        this._asyncValidators = _asyncValidators;
	        this._submitted = false;
	        this.form = null;
	        this.directives = [];
	        this.ngSubmit = new async_1.EventEmitter();
	        this._displayWarning();
	    }
	    NgFormModel.prototype._displayWarning = function () {
	        // TODO(kara): Update this when the new forms module becomes the default
	        if (!_formModelWarningDisplayed) {
	            _formModelWarningDisplayed = true;
	            console.warn("\n      *It looks like you're using the old forms module. This will be opt-in in the next RC, and\n      will eventually be removed in favor of the new forms module. For more information, see:\n      https://docs.google.com/document/d/1RIezQqE4aEhBRmArIAS1mRIZtWFf6JxN_7B4meyWK0Y/preview\n    ");
	        }
	    };
	    NgFormModel.prototype.ngOnChanges = function (changes) {
	        this._checkFormPresent();
	        if (collection_1.StringMapWrapper.contains(changes, 'form')) {
	            var sync = shared_1.composeValidators(this._validators);
	            this.form.validator = validators_1.Validators.compose([this.form.validator, sync]);
	            var async = shared_1.composeAsyncValidators(this._asyncValidators);
	            this.form.asyncValidator = validators_1.Validators.composeAsync([this.form.asyncValidator, async]);
	            this.form.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        }
	        this._updateDomValue();
	    };
	    Object.defineProperty(NgFormModel.prototype, "submitted", {
	        get: function () { return this._submitted; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgFormModel.prototype, "formDirective", {
	        get: function () { return this; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgFormModel.prototype, "control", {
	        get: function () { return this.form; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgFormModel.prototype, "path", {
	        get: function () { return []; },
	        enumerable: true,
	        configurable: true
	    });
	    NgFormModel.prototype.addControl = function (dir) {
	        var ctrl = this.form.find(dir.path);
	        shared_1.setUpControl(ctrl, dir);
	        ctrl.updateValueAndValidity({ emitEvent: false });
	        this.directives.push(dir);
	    };
	    NgFormModel.prototype.getControl = function (dir) { return this.form.find(dir.path); };
	    NgFormModel.prototype.removeControl = function (dir) { collection_1.ListWrapper.remove(this.directives, dir); };
	    NgFormModel.prototype.addControlGroup = function (dir) {
	        var ctrl = this.form.find(dir.path);
	        shared_1.setUpControlGroup(ctrl, dir);
	        ctrl.updateValueAndValidity({ emitEvent: false });
	    };
	    NgFormModel.prototype.removeControlGroup = function (dir) { };
	    NgFormModel.prototype.getControlGroup = function (dir) {
	        return this.form.find(dir.path);
	    };
	    NgFormModel.prototype.updateModel = function (dir, value) {
	        var ctrl = this.form.find(dir.path);
	        ctrl.updateValue(value);
	    };
	    NgFormModel.prototype.onSubmit = function () {
	        this._submitted = true;
	        this.ngSubmit.emit(null);
	        return false;
	    };
	    /** @internal */
	    NgFormModel.prototype._updateDomValue = function () {
	        var _this = this;
	        this.directives.forEach(function (dir) {
	            var ctrl = _this.form.find(dir.path);
	            dir.valueAccessor.writeValue(ctrl.value);
	        });
	    };
	    NgFormModel.prototype._checkFormPresent = function () {
	        if (lang_1.isBlank(this.form)) {
	            throw new exceptions_1.BaseException("ngFormModel expects a form. Please pass one in. Example: <form [ngFormModel]=\"myCoolForm\">");
	        }
	    };
	    /** @nocollapse */
	    NgFormModel.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: '[ngFormModel]',
	                    providers: [exports.formDirectiveProvider],
	                    inputs: ['form: ngFormModel'],
	                    host: { '(submit)': 'onSubmit()' },
	                    outputs: ['ngSubmit'],
	                    exportAs: 'ngForm'
	                },] },
	    ];
	    /** @nocollapse */
	    NgFormModel.ctorParameters = [
	        { type: Array, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_VALIDATORS,] },] },
	        { type: Array, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_ASYNC_VALIDATORS,] },] },
	    ];
	    return NgFormModel;
	}(control_container_1.ControlContainer));
	exports.NgFormModel = NgFormModel;
	//# sourceMappingURL=ng_form_model.js.map

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var async_1 = __webpack_require__(25);
	var model_1 = __webpack_require__(45);
	var validators_1 = __webpack_require__(15);
	var control_value_accessor_1 = __webpack_require__(13);
	var ng_control_1 = __webpack_require__(21);
	var shared_1 = __webpack_require__(26);
	exports.formControlBinding = {
	    provide: ng_control_1.NgControl,
	    useExisting: core_1.forwardRef(function () { return NgModel; })
	};
	var NgModel = (function (_super) {
	    __extends(NgModel, _super);
	    function NgModel(_validators, _asyncValidators, valueAccessors) {
	        _super.call(this);
	        this._validators = _validators;
	        this._asyncValidators = _asyncValidators;
	        /** @internal */
	        this._control = new model_1.Control();
	        /** @internal */
	        this._added = false;
	        this.update = new async_1.EventEmitter();
	        this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);
	    }
	    NgModel.prototype.ngOnChanges = function (changes) {
	        if (!this._added) {
	            shared_1.setUpControl(this._control, this);
	            this._control.updateValueAndValidity({ emitEvent: false });
	            this._added = true;
	        }
	        if (shared_1.isPropertyUpdated(changes, this.viewModel)) {
	            this._control.updateValue(this.model);
	            this.viewModel = this.model;
	        }
	    };
	    Object.defineProperty(NgModel.prototype, "control", {
	        get: function () { return this._control; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgModel.prototype, "path", {
	        get: function () { return []; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgModel.prototype, "validator", {
	        get: function () { return shared_1.composeValidators(this._validators); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgModel.prototype, "asyncValidator", {
	        get: function () {
	            return shared_1.composeAsyncValidators(this._asyncValidators);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    NgModel.prototype.viewToModelUpdate = function (newValue) {
	        this.viewModel = newValue;
	        this.update.emit(newValue);
	    };
	    /** @nocollapse */
	    NgModel.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: '[ngModel]:not([ngControl]):not([ngFormControl])',
	                    providers: [exports.formControlBinding],
	                    inputs: ['model: ngModel'],
	                    outputs: ['update: ngModelChange'],
	                    exportAs: 'ngForm'
	                },] },
	    ];
	    /** @nocollapse */
	    NgModel.ctorParameters = [
	        { type: Array, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_VALIDATORS,] },] },
	        { type: Array, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_ASYNC_VALIDATORS,] },] },
	        { type: Array, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [control_value_accessor_1.NG_VALUE_ACCESSOR,] },] },
	    ];
	    return NgModel;
	}(ng_control_1.NgControl));
	exports.NgModel = NgModel;
	//# sourceMappingURL=ng_model.js.map

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(3);
	var control_value_accessor_1 = __webpack_require__(13);
	exports.NUMBER_VALUE_ACCESSOR = {
	    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
	    useExisting: core_1.forwardRef(function () { return NumberValueAccessor; }),
	    multi: true
	};
	var NumberValueAccessor = (function () {
	    function NumberValueAccessor(_renderer, _elementRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this.onChange = function (_) { };
	        this.onTouched = function () { };
	    }
	    NumberValueAccessor.prototype.writeValue = function (value) {
	        // The value needs to be normalized for IE9, otherwise it is set to 'null' when null
	        var normalizedValue = lang_1.isBlank(value) ? '' : value;
	        this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
	    };
	    NumberValueAccessor.prototype.registerOnChange = function (fn) {
	        this.onChange = function (value) { fn(value == '' ? null : lang_1.NumberWrapper.parseFloat(value)); };
	    };
	    NumberValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    /** @nocollapse */
	    NumberValueAccessor.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'input[type=number][ngControl],input[type=number][ngFormControl],input[type=number][ngModel]',
	                    host: {
	                        '(change)': 'onChange($event.target.value)',
	                        '(input)': 'onChange($event.target.value)',
	                        '(blur)': 'onTouched()'
	                    },
	                    providers: [exports.NUMBER_VALUE_ACCESSOR]
	                },] },
	    ];
	    /** @nocollapse */
	    NumberValueAccessor.ctorParameters = [
	        { type: core_1.Renderer, },
	        { type: core_1.ElementRef, },
	    ];
	    return NumberValueAccessor;
	}());
	exports.NumberValueAccessor = NumberValueAccessor;
	//# sourceMappingURL=number_value_accessor.js.map

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(10);
	var lang_1 = __webpack_require__(3);
	var control_value_accessor_1 = __webpack_require__(13);
	exports.SELECT_MULTIPLE_VALUE_ACCESSOR = {
	    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
	    useExisting: core_1.forwardRef(function () { return SelectMultipleControlValueAccessor; }),
	    multi: true
	};
	function _buildValueString(id, value) {
	    if (lang_1.isBlank(id))
	        return "" + value;
	    if (lang_1.isString(value))
	        value = "'" + value + "'";
	    if (!lang_1.isPrimitive(value))
	        value = 'Object';
	    return lang_1.StringWrapper.slice(id + ": " + value, 0, 50);
	}
	function _extractId(valueString) {
	    return valueString.split(':')[0];
	}
	/** Mock interface for HTMLCollection */
	var HTMLCollection = (function () {
	    function HTMLCollection() {
	    }
	    return HTMLCollection;
	}());
	var SelectMultipleControlValueAccessor = (function () {
	    function SelectMultipleControlValueAccessor() {
	        /** @internal */
	        this._optionMap = new Map();
	        /** @internal */
	        this._idCounter = 0;
	        this.onChange = function (_) { };
	        this.onTouched = function () { };
	    }
	    SelectMultipleControlValueAccessor.prototype.writeValue = function (value) {
	        var _this = this;
	        this.value = value;
	        if (value == null)
	            return;
	        var values = value;
	        // convert values to ids
	        var ids = values.map(function (v) { return _this._getOptionId(v); });
	        this._optionMap.forEach(function (opt, o) { opt._setSelected(ids.indexOf(o.toString()) > -1); });
	    };
	    SelectMultipleControlValueAccessor.prototype.registerOnChange = function (fn) {
	        var _this = this;
	        this.onChange = function (_) {
	            var selected = [];
	            if (_.hasOwnProperty('selectedOptions')) {
	                var options = _.selectedOptions;
	                for (var i = 0; i < options.length; i++) {
	                    var opt = options.item(i);
	                    var val = _this._getOptionValue(opt.value);
	                    selected.push(val);
	                }
	            }
	            else {
	                var options = _.options;
	                for (var i = 0; i < options.length; i++) {
	                    var opt = options.item(i);
	                    if (opt.selected) {
	                        var val = _this._getOptionValue(opt.value);
	                        selected.push(val);
	                    }
	                }
	            }
	            fn(selected);
	        };
	    };
	    SelectMultipleControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    /** @internal */
	    SelectMultipleControlValueAccessor.prototype._registerOption = function (value) {
	        var id = (this._idCounter++).toString();
	        this._optionMap.set(id, value);
	        return id;
	    };
	    /** @internal */
	    SelectMultipleControlValueAccessor.prototype._getOptionId = function (value) {
	        for (var _i = 0, _a = collection_1.MapWrapper.keys(this._optionMap); _i < _a.length; _i++) {
	            var id = _a[_i];
	            if (lang_1.looseIdentical(this._optionMap.get(id)._value, value))
	                return id;
	        }
	        return null;
	    };
	    /** @internal */
	    SelectMultipleControlValueAccessor.prototype._getOptionValue = function (valueString) {
	        var opt = this._optionMap.get(_extractId(valueString));
	        return lang_1.isPresent(opt) ? opt._value : valueString;
	    };
	    /** @nocollapse */
	    SelectMultipleControlValueAccessor.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'select[multiple][ngControl],select[multiple][ngFormControl],select[multiple][ngModel]',
	                    host: { '(change)': 'onChange($event.target)', '(blur)': 'onTouched()' },
	                    providers: [exports.SELECT_MULTIPLE_VALUE_ACCESSOR]
	                },] },
	    ];
	    /** @nocollapse */
	    SelectMultipleControlValueAccessor.ctorParameters = [];
	    return SelectMultipleControlValueAccessor;
	}());
	exports.SelectMultipleControlValueAccessor = SelectMultipleControlValueAccessor;
	var NgSelectMultipleOption = (function () {
	    function NgSelectMultipleOption(_element, _renderer, _select) {
	        this._element = _element;
	        this._renderer = _renderer;
	        this._select = _select;
	        if (lang_1.isPresent(this._select)) {
	            this.id = this._select._registerOption(this);
	        }
	    }
	    Object.defineProperty(NgSelectMultipleOption.prototype, "ngValue", {
	        set: function (value) {
	            if (this._select == null)
	                return;
	            this._value = value;
	            this._setElementValue(_buildValueString(this.id, value));
	            this._select.writeValue(this._select.value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgSelectMultipleOption.prototype, "value", {
	        set: function (value) {
	            if (lang_1.isPresent(this._select)) {
	                this._value = value;
	                this._setElementValue(_buildValueString(this.id, value));
	                this._select.writeValue(this._select.value);
	            }
	            else {
	                this._setElementValue(value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** @internal */
	    NgSelectMultipleOption.prototype._setElementValue = function (value) {
	        this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
	    };
	    /** @internal */
	    NgSelectMultipleOption.prototype._setSelected = function (selected) {
	        this._renderer.setElementProperty(this._element.nativeElement, 'selected', selected);
	    };
	    NgSelectMultipleOption.prototype.ngOnDestroy = function () {
	        if (lang_1.isPresent(this._select)) {
	            this._select._optionMap.delete(this.id);
	            this._select.writeValue(this._select.value);
	        }
	    };
	    /** @nocollapse */
	    NgSelectMultipleOption.decorators = [
	        { type: core_1.Directive, args: [{ selector: 'option' },] },
	    ];
	    /** @nocollapse */
	    NgSelectMultipleOption.ctorParameters = [
	        { type: core_1.ElementRef, },
	        { type: core_1.Renderer, },
	        { type: SelectMultipleControlValueAccessor, decorators: [{ type: core_1.Optional }, { type: core_1.Host },] },
	    ];
	    /** @nocollapse */
	    NgSelectMultipleOption.propDecorators = {
	        'ngValue': [{ type: core_1.Input, args: ['ngValue',] },],
	        'value': [{ type: core_1.Input, args: ['value',] },],
	    };
	    return NgSelectMultipleOption;
	}());
	exports.NgSelectMultipleOption = NgSelectMultipleOption;
	exports.SELECT_DIRECTIVES = [SelectMultipleControlValueAccessor, NgSelectMultipleOption];
	//# sourceMappingURL=select_multiple_control_value_accessor.js.map

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(3);
	var validators_1 = __webpack_require__(15);
	exports.REQUIRED = validators_1.Validators.required;
	exports.REQUIRED_VALIDATOR = {
	    provide: validators_1.NG_VALIDATORS,
	    useValue: exports.REQUIRED,
	    multi: true
	};
	var RequiredValidator = (function () {
	    function RequiredValidator() {
	    }
	    /** @nocollapse */
	    RequiredValidator.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: '[required][ngControl],[required][ngFormControl],[required][ngModel]',
	                    providers: [exports.REQUIRED_VALIDATOR]
	                },] },
	    ];
	    return RequiredValidator;
	}());
	exports.RequiredValidator = RequiredValidator;
	/**
	 * Provivder which adds {@link MinLengthValidator} to {@link NG_VALIDATORS}.
	 *
	 * ## Example:
	 *
	 * {@example common/forms/ts/validators/validators.ts region='min'}
	 */
	exports.MIN_LENGTH_VALIDATOR = {
	    provide: validators_1.NG_VALIDATORS,
	    useExisting: core_1.forwardRef(function () { return MinLengthValidator; }),
	    multi: true
	};
	var MinLengthValidator = (function () {
	    function MinLengthValidator(minLength) {
	        this._validator = validators_1.Validators.minLength(lang_1.NumberWrapper.parseInt(minLength, 10));
	    }
	    MinLengthValidator.prototype.validate = function (c) { return this._validator(c); };
	    /** @nocollapse */
	    MinLengthValidator.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: '[minlength][ngControl],[minlength][ngFormControl],[minlength][ngModel]',
	                    providers: [exports.MIN_LENGTH_VALIDATOR]
	                },] },
	    ];
	    /** @nocollapse */
	    MinLengthValidator.ctorParameters = [
	        { type: undefined, decorators: [{ type: core_1.Attribute, args: ['minlength',] },] },
	    ];
	    return MinLengthValidator;
	}());
	exports.MinLengthValidator = MinLengthValidator;
	/**
	 * Provider which adds {@link MaxLengthValidator} to {@link NG_VALIDATORS}.
	 *
	 * ## Example:
	 *
	 * {@example common/forms/ts/validators/validators.ts region='max'}
	 */
	exports.MAX_LENGTH_VALIDATOR = {
	    provide: validators_1.NG_VALIDATORS,
	    useExisting: core_1.forwardRef(function () { return MaxLengthValidator; }),
	    multi: true
	};
	var MaxLengthValidator = (function () {
	    function MaxLengthValidator(maxLength) {
	        this._validator = validators_1.Validators.maxLength(lang_1.NumberWrapper.parseInt(maxLength, 10));
	    }
	    MaxLengthValidator.prototype.validate = function (c) { return this._validator(c); };
	    /** @nocollapse */
	    MaxLengthValidator.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: '[maxlength][ngControl],[maxlength][ngFormControl],[maxlength][ngModel]',
	                    providers: [exports.MAX_LENGTH_VALIDATOR]
	                },] },
	    ];
	    /** @nocollapse */
	    MaxLengthValidator.ctorParameters = [
	        { type: undefined, decorators: [{ type: core_1.Attribute, args: ['maxlength',] },] },
	    ];
	    return MaxLengthValidator;
	}());
	exports.MaxLengthValidator = MaxLengthValidator;
	exports.PATTERN_VALIDATOR = {
	    provide: validators_1.NG_VALIDATORS,
	    useExisting: core_1.forwardRef(function () { return PatternValidator; }),
	    multi: true
	};
	var PatternValidator = (function () {
	    function PatternValidator(pattern) {
	        this._validator = validators_1.Validators.pattern(pattern);
	    }
	    PatternValidator.prototype.validate = function (c) { return this._validator(c); };
	    /** @nocollapse */
	    PatternValidator.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: '[pattern][ngControl],[pattern][ngFormControl],[pattern][ngModel]',
	                    providers: [exports.PATTERN_VALIDATOR]
	                },] },
	    ];
	    /** @nocollapse */
	    PatternValidator.ctorParameters = [
	        { type: undefined, decorators: [{ type: core_1.Attribute, args: ['pattern',] },] },
	    ];
	    return PatternValidator;
	}());
	exports.PatternValidator = PatternValidator;
	//# sourceMappingURL=validators.js.map

/***/ },
/* 82 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * @experimental
	 */
	var NgLocalization = (function () {
	    function NgLocalization() {
	    }
	    return NgLocalization;
	}());
	exports.NgLocalization = NgLocalization;
	/**
	 * Returns the plural category for a given value.
	 * - "=value" when the case exists,
	 * - the plural category otherwise
	 *
	 * @internal
	 */
	function getPluralCategory(value, cases, ngLocalization) {
	    var nbCase = "=" + value;
	    return cases.indexOf(nbCase) > -1 ? nbCase : ngLocalization.getPluralCategory(value);
	}
	exports.getPluralCategory = getPluralCategory;
	//# sourceMappingURL=localization.js.map

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var location_strategy_1 = __webpack_require__(46);
	var Location = (function () {
	    function Location(platformStrategy) {
	        var _this = this;
	        /** @internal */
	        this._subject = new core_1.EventEmitter();
	        this._platformStrategy = platformStrategy;
	        var browserBaseHref = this._platformStrategy.getBaseHref();
	        this._baseHref = Location.stripTrailingSlash(_stripIndexHtml(browserBaseHref));
	        this._platformStrategy.onPopState(function (ev) { _this._subject.emit({ 'url': _this.path(true), 'pop': true, 'type': ev.type }); });
	    }
	    /**
	     * Returns the normalized URL path.
	     */
	    // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is
	    // removed.
	    Location.prototype.path = function (includeHash) {
	        if (includeHash === void 0) { includeHash = false; }
	        return this.normalize(this._platformStrategy.path(includeHash));
	    };
	    /**
	     * Normalizes the given path and compares to the current normalized path.
	     */
	    Location.prototype.isCurrentPathEqualTo = function (path, query) {
	        if (query === void 0) { query = ''; }
	        return this.path() == this.normalize(path + Location.normalizeQueryParams(query));
	    };
	    /**
	     * Given a string representing a URL, returns the normalized URL path without leading or
	     * trailing slashes
	     */
	    Location.prototype.normalize = function (url) {
	        return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
	    };
	    /**
	     * Given a string representing a URL, returns the platform-specific external URL path.
	     * If the given URL doesn't begin with a leading slash (`'/'`), this method adds one
	     * before normalizing. This method will also add a hash if `HashLocationStrategy` is
	     * used, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
	     */
	    Location.prototype.prepareExternalUrl = function (url) {
	        if (url.length > 0 && !url.startsWith('/')) {
	            url = '/' + url;
	        }
	        return this._platformStrategy.prepareExternalUrl(url);
	    };
	    // TODO: rename this method to pushState
	    /**
	     * Changes the browsers URL to the normalized version of the given URL, and pushes a
	     * new item onto the platform's history.
	     */
	    Location.prototype.go = function (path, query) {
	        if (query === void 0) { query = ''; }
	        this._platformStrategy.pushState(null, '', path, query);
	    };
	    /**
	     * Changes the browsers URL to the normalized version of the given URL, and replaces
	     * the top item on the platform's history stack.
	     */
	    Location.prototype.replaceState = function (path, query) {
	        if (query === void 0) { query = ''; }
	        this._platformStrategy.replaceState(null, '', path, query);
	    };
	    /**
	     * Navigates forward in the platform's history.
	     */
	    Location.prototype.forward = function () { this._platformStrategy.forward(); };
	    /**
	     * Navigates back in the platform's history.
	     */
	    Location.prototype.back = function () { this._platformStrategy.back(); };
	    /**
	     * Subscribe to the platform's `popState` events.
	     */
	    Location.prototype.subscribe = function (onNext, onThrow, onReturn) {
	        if (onThrow === void 0) { onThrow = null; }
	        if (onReturn === void 0) { onReturn = null; }
	        return this._subject.subscribe({ next: onNext, error: onThrow, complete: onReturn });
	    };
	    /**
	     * Given a string of url parameters, prepend with '?' if needed, otherwise return parameters as
	     * is.
	     */
	    Location.normalizeQueryParams = function (params) {
	        return (params.length > 0 && params.substring(0, 1) != '?') ? ('?' + params) : params;
	    };
	    /**
	     * Given 2 parts of a url, join them with a slash if needed.
	     */
	    Location.joinWithSlash = function (start, end) {
	        if (start.length == 0) {
	            return end;
	        }
	        if (end.length == 0) {
	            return start;
	        }
	        var slashes = 0;
	        if (start.endsWith('/')) {
	            slashes++;
	        }
	        if (end.startsWith('/')) {
	            slashes++;
	        }
	        if (slashes == 2) {
	            return start + end.substring(1);
	        }
	        if (slashes == 1) {
	            return start + end;
	        }
	        return start + '/' + end;
	    };
	    /**
	     * If url has a trailing slash, remove it, otherwise return url as is.
	     */
	    Location.stripTrailingSlash = function (url) {
	        if (/\/$/g.test(url)) {
	            url = url.substring(0, url.length - 1);
	        }
	        return url;
	    };
	    /** @nocollapse */
	    Location.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    Location.ctorParameters = [
	        { type: location_strategy_1.LocationStrategy, },
	    ];
	    return Location;
	}());
	exports.Location = Location;
	function _stripBaseHref(baseHref, url) {
	    if (baseHref.length > 0 && url.startsWith(baseHref)) {
	        return url.substring(baseHref.length);
	    }
	    return url;
	}
	function _stripIndexHtml(url) {
	    if (/\/index.html$/g.test(url)) {
	        // '/index.html'.length == 11
	        return url.substring(0, url.length - 11);
	    }
	    return url;
	}
	//# sourceMappingURL=location.js.map

/***/ },
/* 84 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * This class should not be used directly by an application developer. Instead, use
	 * {@link Location}.
	 *
	 * `PlatformLocation` encapsulates all calls to DOM apis, which allows the Router to be platform
	 * agnostic.
	 * This means that we can have different implementation of `PlatformLocation` for the different
	 * platforms
	 * that angular supports. For example, the default `PlatformLocation` is {@link
	 * BrowserPlatformLocation},
	 * however when you run your app in a WebWorker you use {@link WebWorkerPlatformLocation}.
	 *
	 * The `PlatformLocation` class is used directly by all implementations of {@link LocationStrategy}
	 * when
	 * they need to interact with the DOM apis like pushState, popState, etc...
	 *
	 * {@link LocationStrategy} in turn is used by the {@link Location} service which is used directly
	 * by
	 * the {@link Router} in order to navigate between routes. Since all interactions between {@link
	 * Router} /
	 * {@link Location} / {@link LocationStrategy} and DOM apis flow through the `PlatformLocation`
	 * class
	 * they are all platform independent.
	 *
	 * @stable
	 */
	var PlatformLocation = (function () {
	    function PlatformLocation() {
	    }
	    Object.defineProperty(PlatformLocation.prototype, "pathname", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PlatformLocation.prototype, "search", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PlatformLocation.prototype, "hash", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    return PlatformLocation;
	}());
	exports.PlatformLocation = PlatformLocation;
	//# sourceMappingURL=platform_location.js.map

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	/**
	 * @experimental Animation support is experimental.
	 */
	var AnimationPlayer = (function () {
	    function AnimationPlayer() {
	    }
	    Object.defineProperty(AnimationPlayer.prototype, "parentPlayer", {
	        get: function () { throw new exceptions_1.BaseException('NOT IMPLEMENTED: Base Class'); },
	        set: function (player) {
	            throw new exceptions_1.BaseException('NOT IMPLEMENTED: Base Class');
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return AnimationPlayer;
	}());
	exports.AnimationPlayer = AnimationPlayer;
	var NoOpAnimationPlayer = (function () {
	    function NoOpAnimationPlayer() {
	        var _this = this;
	        this._subscriptions = [];
	        this._started = false;
	        this.parentPlayer = null;
	        lang_1.scheduleMicroTask(function () { return _this._onFinish(); });
	    }
	    /** @internal */
	    NoOpAnimationPlayer.prototype._onFinish = function () {
	        this._subscriptions.forEach(function (entry) { entry(); });
	        this._subscriptions = [];
	    };
	    NoOpAnimationPlayer.prototype.onDone = function (fn) { this._subscriptions.push(fn); };
	    NoOpAnimationPlayer.prototype.hasStarted = function () { return this._started; };
	    NoOpAnimationPlayer.prototype.init = function () { };
	    NoOpAnimationPlayer.prototype.play = function () { this._started = true; };
	    NoOpAnimationPlayer.prototype.pause = function () { };
	    NoOpAnimationPlayer.prototype.restart = function () { };
	    NoOpAnimationPlayer.prototype.finish = function () { this._onFinish(); };
	    NoOpAnimationPlayer.prototype.destroy = function () { };
	    NoOpAnimationPlayer.prototype.reset = function () { };
	    NoOpAnimationPlayer.prototype.setPosition = function (p /** TODO #9100 */) { };
	    NoOpAnimationPlayer.prototype.getPosition = function () { return 0; };
	    return NoOpAnimationPlayer;
	}());
	exports.NoOpAnimationPlayer = NoOpAnimationPlayer;
	//# sourceMappingURL=animation_player.js.map

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var di_1 = __webpack_require__(12);
	/**
	 * A function that will be executed when an application is initialized.
	 * @experimental
	 */
	exports.APP_INITIALIZER = new di_1.OpaqueToken('Application Initializer');
	var ApplicationInitStatus = (function () {
	    function ApplicationInitStatus(appInits) {
	        var _this = this;
	        this._done = false;
	        var asyncInitPromises = [];
	        if (appInits) {
	            for (var i = 0; i < appInits.length; i++) {
	                var initResult = appInits[i]();
	                if (lang_1.isPromise(initResult)) {
	                    asyncInitPromises.push(initResult);
	                }
	            }
	        }
	        this._donePromise = Promise.all(asyncInitPromises).then(function () { _this._done = true; });
	        if (asyncInitPromises.length === 0) {
	            this._done = true;
	        }
	    }
	    Object.defineProperty(ApplicationInitStatus.prototype, "done", {
	        get: function () { return this._done; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ApplicationInitStatus.prototype, "donePromise", {
	        get: function () { return this._donePromise; },
	        enumerable: true,
	        configurable: true
	    });
	    /** @nocollapse */
	    ApplicationInitStatus.decorators = [
	        { type: di_1.Injectable },
	    ];
	    /** @nocollapse */
	    ApplicationInitStatus.ctorParameters = [
	        { type: Array, decorators: [{ type: di_1.Inject, args: [exports.APP_INITIALIZER,] }, { type: di_1.Optional },] },
	    ];
	    return ApplicationInitStatus;
	}());
	exports.ApplicationInitStatus = ApplicationInitStatus;
	//# sourceMappingURL=application_init.js.map

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	var application_init_1 = __webpack_require__(86);
	var application_tokens_1 = __webpack_require__(47);
	var console_1 = __webpack_require__(51);
	var di_1 = __webpack_require__(12);
	var compiler_1 = __webpack_require__(31);
	var component_factory_1 = __webpack_require__(150);
	var component_factory_resolver_1 = __webpack_require__(54);
	var profile_1 = __webpack_require__(57);
	var testability_1 = __webpack_require__(100);
	var ng_zone_1 = __webpack_require__(101);
	var _devMode = true;
	var _runModeLocked = false;
	var _platform;
	/**
	 * Disable Angular's development mode, which turns off assertions and other
	 * checks within the framework.
	 *
	 * One important assertion this disables verifies that a change detection pass
	 * does not result in additional changes to any bindings (also known as
	 * unidirectional data flow).
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function enableProdMode() {
	    if (_runModeLocked) {
	        // Cannot use BaseException as that ends up importing from facade/lang.
	        throw new exceptions_1.BaseException('Cannot enable prod mode after platform setup.');
	    }
	    _devMode = false;
	}
	exports.enableProdMode = enableProdMode;
	/**
	 * Locks the run mode of Angular. After this has been called,
	 * it can't be changed any more. I.e. `isDevMode()` will always
	 * return the same value.
	 *
	 * @deprecated This is a noop now. {@link isDevMode} automatically locks the run mode on first call.
	 */
	function lockRunMode() {
	    console.warn('lockRunMode() is deprecated and not needed any more.');
	}
	exports.lockRunMode = lockRunMode;
	/**
	 * Returns whether Angular is in development mode. After called once,
	 * the value is locked and won't change any more.
	 *
	 * By default, this is true, unless a user calls `enableProdMode` before calling this.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function isDevMode() {
	    _runModeLocked = true;
	    return _devMode;
	}
	exports.isDevMode = isDevMode;
	/**
	 * Creates a platform.
	 * Platforms have to be eagerly created via this function.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function createPlatform(injector) {
	    if (lang_1.isPresent(_platform) && !_platform.disposed) {
	        throw new exceptions_1.BaseException('There can be only one platform. Destroy the previous one to create a new one.');
	    }
	    _platform = injector.get(PlatformRef);
	    var inits = injector.get(application_tokens_1.PLATFORM_INITIALIZER, null);
	    if (lang_1.isPresent(inits))
	        inits.forEach(function (init) { return init(); });
	    return _platform;
	}
	exports.createPlatform = createPlatform;
	/**
	 * Creates a factory for a platform
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function createPlatformFactory(parentPlaformFactory, name, providers) {
	    if (providers === void 0) { providers = []; }
	    var marker = new di_1.OpaqueToken("Platform: " + name);
	    return function (extraProviders) {
	        if (extraProviders === void 0) { extraProviders = []; }
	        if (!getPlatform()) {
	            if (parentPlaformFactory) {
	                parentPlaformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));
	            }
	            else {
	                createPlatform(di_1.ReflectiveInjector.resolveAndCreate(providers.concat(extraProviders).concat({ provide: marker, useValue: true })));
	            }
	        }
	        return assertPlatform(marker);
	    };
	}
	exports.createPlatformFactory = createPlatformFactory;
	/**
	 * Checks that there currently is a platform
	 * which contains the given token as a provider.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function assertPlatform(requiredToken) {
	    var platform = getPlatform();
	    if (lang_1.isBlank(platform)) {
	        throw new exceptions_1.BaseException('No platform exists!');
	    }
	    if (lang_1.isPresent(platform) && lang_1.isBlank(platform.injector.get(requiredToken, null))) {
	        throw new exceptions_1.BaseException('A platform with a different configuration has been created. Please destroy it first.');
	    }
	    return platform;
	}
	exports.assertPlatform = assertPlatform;
	/**
	 * Dispose the existing platform.
	 *
	 * @deprecated Use `destroyPlatform` instead
	 */
	function disposePlatform() {
	    destroyPlatform();
	}
	exports.disposePlatform = disposePlatform;
	/**
	 * Destroy the existing platform.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function destroyPlatform() {
	    if (lang_1.isPresent(_platform) && !_platform.destroyed) {
	        _platform.destroy();
	    }
	}
	exports.destroyPlatform = destroyPlatform;
	/**
	 * Returns the current platform.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function getPlatform() {
	    return lang_1.isPresent(_platform) && !_platform.disposed ? _platform : null;
	}
	exports.getPlatform = getPlatform;
	/**
	 * Shortcut for ApplicationRef.bootstrap.
	 * Requires a platform to be created first.
	 *
	 * @deprecated Use {@link bootstrapModuleFactory} instead.
	 */
	function coreBootstrap(componentFactory, injector) {
	    throw new exceptions_1.BaseException('coreBootstrap is deprecated. Use bootstrapModuleFactory instead.');
	}
	exports.coreBootstrap = coreBootstrap;
	/**
	 * Resolves the componentFactory for the given component,
	 * waits for asynchronous initializers and bootstraps the component.
	 * Requires a platform to be created first.
	 *
	 * @deprecated Use {@link bootstrapModule} instead.
	 */
	function coreLoadAndBootstrap(componentType, injector) {
	    throw new exceptions_1.BaseException('coreLoadAndBootstrap is deprecated. Use bootstrapModule instead.');
	}
	exports.coreLoadAndBootstrap = coreLoadAndBootstrap;
	/**
	 * The Angular platform is the entry point for Angular on a web page. Each page
	 * has exactly one platform, and services (such as reflection) which are common
	 * to every Angular application running on the page are bound in its scope.
	 *
	 * A page's platform is initialized implicitly when {@link bootstrap}() is called, or
	 * explicitly by calling {@link createPlatform}().
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	var PlatformRef = (function () {
	    function PlatformRef() {
	    }
	    /**
	     * Creates an instance of an `@NgModule` for the given platform
	     * for offline compilation.
	     *
	     * ## Simple Example
	     *
	     * ```typescript
	     * my_module.ts:
	     *
	     * @NgModule({
	     *   imports: [BrowserModule]
	     * })
	     * class MyModule {}
	     *
	     * main.ts:
	     * import {MyModuleNgFactory} from './my_module.ngfactory';
	     * import {browserPlatform} from '@angular/platform-browser';
	     *
	     * let moduleRef = browserPlatform().bootstrapModuleFactory(MyModuleNgFactory);
	     * ```
	     *
	     * @experimental APIs related to application bootstrap are currently under review.
	     */
	    PlatformRef.prototype.bootstrapModuleFactory = function (moduleFactory) {
	        throw exceptions_1.unimplemented();
	    };
	    /**
	     * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.
	     *
	     * ## Simple Example
	     *
	     * ```typescript
	     * @NgModule({
	     *   imports: [BrowserModule]
	     * })
	     * class MyModule {}
	     *
	     * let moduleRef = browserPlatform().bootstrapModule(MyModule);
	     * ```
	     * @stable
	     */
	    PlatformRef.prototype.bootstrapModule = function (moduleType, compilerOptions) {
	        if (compilerOptions === void 0) { compilerOptions = []; }
	        throw exceptions_1.unimplemented();
	    };
	    Object.defineProperty(PlatformRef.prototype, "injector", {
	        /**
	         * Retrieve the platform {@link Injector}, which is the parent injector for
	         * every Angular application on the page and provides singleton providers.
	         */
	        get: function () { throw exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(PlatformRef.prototype, "disposed", {
	        /**
	         * @deprecated Use `destroyed` instead
	         */
	        get: function () { throw exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PlatformRef.prototype, "destroyed", {
	        get: function () { throw exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    return PlatformRef;
	}());
	exports.PlatformRef = PlatformRef;
	function _callAndReportToExceptionHandler(exceptionHandler, callback) {
	    try {
	        var result = callback();
	        if (lang_1.isPromise(result)) {
	            return result.catch(function (e) {
	                exceptionHandler.call(e);
	                // rethrow as the exception handler might not do it
	                throw e;
	            });
	        }
	        else {
	            return result;
	        }
	    }
	    catch (e) {
	        exceptionHandler.call(e);
	        // rethrow as the exception handler might not do it
	        throw e;
	    }
	}
	var PlatformRef_ = (function (_super) {
	    __extends(PlatformRef_, _super);
	    function PlatformRef_(_injector) {
	        _super.call(this);
	        this._injector = _injector;
	        this._modules = [];
	        this._destroyListeners = [];
	        this._destroyed = false;
	    }
	    /**
	     * @deprecated
	     */
	    PlatformRef_.prototype.registerDisposeListener = function (dispose) { this.onDestroy(dispose); };
	    PlatformRef_.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
	    Object.defineProperty(PlatformRef_.prototype, "injector", {
	        get: function () { return this._injector; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PlatformRef_.prototype, "disposed", {
	        /**
	         * @deprecated
	         */
	        get: function () { return this.destroyed; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PlatformRef_.prototype, "destroyed", {
	        get: function () { return this._destroyed; },
	        enumerable: true,
	        configurable: true
	    });
	    PlatformRef_.prototype.destroy = function () {
	        if (this._destroyed) {
	            throw new exceptions_1.BaseException('The platform has already been destroyed!');
	        }
	        collection_1.ListWrapper.clone(this._modules).forEach(function (app) { return app.destroy(); });
	        this._destroyListeners.forEach(function (dispose) { return dispose(); });
	        this._destroyed = true;
	    };
	    /**
	     * @deprecated
	     */
	    PlatformRef_.prototype.dispose = function () { this.destroy(); };
	    PlatformRef_.prototype.bootstrapModuleFactory = function (moduleFactory) {
	        return this._bootstrapModuleFactoryWithZone(moduleFactory, null);
	    };
	    PlatformRef_.prototype._bootstrapModuleFactoryWithZone = function (moduleFactory, ngZone) {
	        var _this = this;
	        // Note: We need to create the NgZone _before_ we instantiate the module,
	        // as instantiating the module creates some providers eagerly.
	        // So we create a mini parent injector that just contains the new NgZone and
	        // pass that as parent to the NgModuleFactory.
	        if (!ngZone)
	            ngZone = new ng_zone_1.NgZone({ enableLongStackTrace: isDevMode() });
	        // Attention: Don't use ApplicationRef.run here,
	        // as we want to be sure that all possible constructor calls are inside `ngZone.run`!
	        return ngZone.run(function () {
	            var ngZoneInjector = di_1.ReflectiveInjector.resolveAndCreate([{ provide: ng_zone_1.NgZone, useValue: ngZone }], _this.injector);
	            var moduleRef = moduleFactory.create(ngZoneInjector);
	            var exceptionHandler = moduleRef.injector.get(exceptions_1.ExceptionHandler, null);
	            if (!exceptionHandler) {
	                throw new Error('No ExceptionHandler. Is platform module (BrowserModule) included?');
	            }
	            moduleRef.onDestroy(function () { return collection_1.ListWrapper.remove(_this._modules, moduleRef); });
	            ngZone.onError.subscribe({
	                next: function (error) { exceptionHandler.call(error.error, error.stackTrace); }
	            });
	            return _callAndReportToExceptionHandler(exceptionHandler, function () {
	                var initStatus = moduleRef.injector.get(application_init_1.ApplicationInitStatus);
	                return initStatus.donePromise.then(function () {
	                    _this._moduleDoBootstrap(moduleRef);
	                    return moduleRef;
	                });
	            });
	        });
	    };
	    PlatformRef_.prototype.bootstrapModule = function (moduleType, compilerOptions) {
	        if (compilerOptions === void 0) { compilerOptions = []; }
	        return this._bootstrapModuleWithZone(moduleType, compilerOptions, null);
	    };
	    PlatformRef_.prototype._bootstrapModuleWithZone = function (moduleType, compilerOptions, ngZone) {
	        var _this = this;
	        if (compilerOptions === void 0) { compilerOptions = []; }
	        var compilerFactory = this.injector.get(compiler_1.CompilerFactory);
	        var compiler = compilerFactory.createCompiler(compilerOptions instanceof Array ? compilerOptions : [compilerOptions]);
	        return compiler.compileModuleAsync(moduleType)
	            .then(function (moduleFactory) { return _this._bootstrapModuleFactoryWithZone(moduleFactory, ngZone); });
	    };
	    PlatformRef_.prototype._moduleDoBootstrap = function (moduleRef) {
	        var appRef = moduleRef.injector.get(ApplicationRef);
	        if (moduleRef.bootstrapFactories.length > 0) {
	            moduleRef.bootstrapFactories.forEach(function (compFactory) { return appRef.bootstrap(compFactory); });
	        }
	        else if (moduleRef.instance.ngDoBootstrap) {
	            moduleRef.instance.ngDoBootstrap(appRef);
	        }
	        else {
	            throw new exceptions_1.BaseException(("The module " + lang_1.stringify(moduleRef.instance.constructor) + " was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. ") +
	                "Please define one of these.");
	        }
	    };
	    /** @nocollapse */
	    PlatformRef_.decorators = [
	        { type: di_1.Injectable },
	    ];
	    /** @nocollapse */
	    PlatformRef_.ctorParameters = [
	        { type: di_1.Injector, },
	    ];
	    return PlatformRef_;
	}(PlatformRef));
	exports.PlatformRef_ = PlatformRef_;
	/**
	 * A reference to an Angular application running on a page.
	 *
	 * For more about Angular applications, see the documentation for {@link bootstrap}.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	var ApplicationRef = (function () {
	    function ApplicationRef() {
	    }
	    Object.defineProperty(ApplicationRef.prototype, "injector", {
	        /**
	         * Retrieve the application {@link Injector}.
	         *
	         * @deprecated inject an {@link Injector} directly where needed or use {@link
	         * NgModuleRef}.injector.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(ApplicationRef.prototype, "zone", {
	        /**
	         * Retrieve the application {@link NgZone}.
	         *
	         * @deprecated inject {@link NgZone} instead of calling this getter.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(ApplicationRef.prototype, "componentTypes", {
	        /**
	         * Get a list of component types registered to this application.
	         * This list is populated even before the component is created.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(ApplicationRef.prototype, "components", {
	        /**
	         * Get a list of components registered to this application.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    return ApplicationRef;
	}());
	exports.ApplicationRef = ApplicationRef;
	var ApplicationRef_ = (function (_super) {
	    __extends(ApplicationRef_, _super);
	    function ApplicationRef_(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus, _testabilityRegistry, _testability) {
	        var _this = this;
	        _super.call(this);
	        this._zone = _zone;
	        this._console = _console;
	        this._injector = _injector;
	        this._exceptionHandler = _exceptionHandler;
	        this._componentFactoryResolver = _componentFactoryResolver;
	        this._initStatus = _initStatus;
	        this._testabilityRegistry = _testabilityRegistry;
	        this._testability = _testability;
	        this._bootstrapListeners = [];
	        /**
	         * @deprecated
	         */
	        this._disposeListeners = [];
	        this._rootComponents = [];
	        this._rootComponentTypes = [];
	        this._changeDetectorRefs = [];
	        this._runningTick = false;
	        this._enforceNoNewChanges = false;
	        this._enforceNoNewChanges = isDevMode();
	        this._zone.onMicrotaskEmpty.subscribe({ next: function () { _this._zone.run(function () { _this.tick(); }); } });
	    }
	    /**
	     * @deprecated
	     */
	    ApplicationRef_.prototype.registerBootstrapListener = function (listener) {
	        this._bootstrapListeners.push(listener);
	    };
	    /**
	     * @deprecated
	     */
	    ApplicationRef_.prototype.registerDisposeListener = function (dispose) { this._disposeListeners.push(dispose); };
	    ApplicationRef_.prototype.registerChangeDetector = function (changeDetector) {
	        this._changeDetectorRefs.push(changeDetector);
	    };
	    ApplicationRef_.prototype.unregisterChangeDetector = function (changeDetector) {
	        collection_1.ListWrapper.remove(this._changeDetectorRefs, changeDetector);
	    };
	    /**
	     * @deprecated
	     */
	    ApplicationRef_.prototype.waitForAsyncInitializers = function () { return this._initStatus.donePromise; };
	    /**
	     * @deprecated
	     */
	    ApplicationRef_.prototype.run = function (callback) {
	        var _this = this;
	        return this._zone.run(function () { return _callAndReportToExceptionHandler(_this._exceptionHandler, callback); });
	    };
	    ApplicationRef_.prototype.bootstrap = function (componentOrFactory) {
	        var _this = this;
	        if (!this._initStatus.done) {
	            throw new exceptions_1.BaseException('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');
	        }
	        var componentFactory;
	        if (componentOrFactory instanceof component_factory_1.ComponentFactory) {
	            componentFactory = componentOrFactory;
	        }
	        else {
	            componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);
	        }
	        this._rootComponentTypes.push(componentFactory.componentType);
	        var compRef = componentFactory.create(this._injector, [], componentFactory.selector);
	        compRef.onDestroy(function () { _this._unloadComponent(compRef); });
	        var testability = compRef.injector.get(testability_1.Testability, null);
	        if (lang_1.isPresent(testability)) {
	            compRef.injector.get(testability_1.TestabilityRegistry)
	                .registerApplication(compRef.location.nativeElement, testability);
	        }
	        this._loadComponent(compRef);
	        if (isDevMode()) {
	            this._console.log("Angular 2 is running in the development mode. Call enableProdMode() to enable the production mode.");
	        }
	        return compRef;
	    };
	    /** @internal */
	    ApplicationRef_.prototype._loadComponent = function (componentRef) {
	        this._changeDetectorRefs.push(componentRef.changeDetectorRef);
	        this.tick();
	        this._rootComponents.push(componentRef);
	        // Get the listeners lazily to prevent DI cycles.
	        var listeners = this._injector.get(application_tokens_1.APP_BOOTSTRAP_LISTENER, [])
	            .concat(this._bootstrapListeners);
	        listeners.forEach(function (listener) { return listener(componentRef); });
	    };
	    /** @internal */
	    ApplicationRef_.prototype._unloadComponent = function (componentRef) {
	        if (!collection_1.ListWrapper.contains(this._rootComponents, componentRef)) {
	            return;
	        }
	        this.unregisterChangeDetector(componentRef.changeDetectorRef);
	        collection_1.ListWrapper.remove(this._rootComponents, componentRef);
	    };
	    Object.defineProperty(ApplicationRef_.prototype, "injector", {
	        /**
	         * @deprecated
	         */
	        get: function () { return this._injector; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ApplicationRef_.prototype, "zone", {
	        /**
	         * @deprecated
	         */
	        get: function () { return this._zone; },
	        enumerable: true,
	        configurable: true
	    });
	    ApplicationRef_.prototype.tick = function () {
	        if (this._runningTick) {
	            throw new exceptions_1.BaseException('ApplicationRef.tick is called recursively');
	        }
	        var s = ApplicationRef_._tickScope();
	        try {
	            this._runningTick = true;
	            this._changeDetectorRefs.forEach(function (detector) { return detector.detectChanges(); });
	            if (this._enforceNoNewChanges) {
	                this._changeDetectorRefs.forEach(function (detector) { return detector.checkNoChanges(); });
	            }
	        }
	        finally {
	            this._runningTick = false;
	            profile_1.wtfLeave(s);
	        }
	    };
	    ApplicationRef_.prototype.ngOnDestroy = function () {
	        // TODO(alxhub): Dispose of the NgZone.
	        collection_1.ListWrapper.clone(this._rootComponents).forEach(function (ref) { return ref.destroy(); });
	        this._disposeListeners.forEach(function (dispose) { return dispose(); });
	    };
	    /**
	     * @deprecated
	     */
	    ApplicationRef_.prototype.dispose = function () { this.ngOnDestroy(); };
	    Object.defineProperty(ApplicationRef_.prototype, "componentTypes", {
	        get: function () { return this._rootComponentTypes; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ApplicationRef_.prototype, "components", {
	        get: function () { return this._rootComponents; },
	        enumerable: true,
	        configurable: true
	    });
	    /** @internal */
	    ApplicationRef_._tickScope = profile_1.wtfCreateScope('ApplicationRef#tick()');
	    /** @nocollapse */
	    ApplicationRef_.decorators = [
	        { type: di_1.Injectable },
	    ];
	    /** @nocollapse */
	    ApplicationRef_.ctorParameters = [
	        { type: ng_zone_1.NgZone, },
	        { type: console_1.Console, },
	        { type: di_1.Injector, },
	        { type: exceptions_1.ExceptionHandler, },
	        { type: component_factory_resolver_1.ComponentFactoryResolver, },
	        { type: application_init_1.ApplicationInitStatus, },
	        { type: testability_1.TestabilityRegistry, decorators: [{ type: di_1.Optional },] },
	        { type: testability_1.Testability, decorators: [{ type: di_1.Optional },] },
	    ];
	    return ApplicationRef_;
	}(ApplicationRef));
	exports.ApplicationRef_ = ApplicationRef_;
	//# sourceMappingURL=application_ref.js.map

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	var DefaultIterableDifferFactory = (function () {
	    function DefaultIterableDifferFactory() {
	    }
	    DefaultIterableDifferFactory.prototype.supports = function (obj) { return collection_1.isListLikeIterable(obj); };
	    DefaultIterableDifferFactory.prototype.create = function (cdRef, trackByFn) {
	        return new DefaultIterableDiffer(trackByFn);
	    };
	    return DefaultIterableDifferFactory;
	}());
	exports.DefaultIterableDifferFactory = DefaultIterableDifferFactory;
	var trackByIdentity = function (index, item) { return item; };
	/**
	 * @stable
	 */
	var DefaultIterableDiffer = (function () {
	    function DefaultIterableDiffer(_trackByFn) {
	        this._trackByFn = _trackByFn;
	        this._length = null;
	        this._collection = null;
	        // Keeps track of the used records at any point in time (during & across `_check()` calls)
	        this._linkedRecords = null;
	        // Keeps track of the removed records at any point in time during `_check()` calls.
	        this._unlinkedRecords = null;
	        this._previousItHead = null;
	        this._itHead = null;
	        this._itTail = null;
	        this._additionsHead = null;
	        this._additionsTail = null;
	        this._movesHead = null;
	        this._movesTail = null;
	        this._removalsHead = null;
	        this._removalsTail = null;
	        // Keeps track of records where custom track by is the same, but item identity has changed
	        this._identityChangesHead = null;
	        this._identityChangesTail = null;
	        this._trackByFn = lang_1.isPresent(this._trackByFn) ? this._trackByFn : trackByIdentity;
	    }
	    Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
	        get: function () { return this._collection; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
	        get: function () { return this._length; },
	        enumerable: true,
	        configurable: true
	    });
	    DefaultIterableDiffer.prototype.forEachItem = function (fn) {
	        var record;
	        for (record = this._itHead; record !== null; record = record._next) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.forEachOperation = function (fn) {
	        var nextIt = this._itHead;
	        var nextRemove = this._removalsHead;
	        var addRemoveOffset = 0;
	        var moveOffsets = null;
	        while (nextIt || nextRemove) {
	            // Figure out which is the next record to process
	            // Order: remove, add, move
	            var record = !nextRemove ||
	                nextIt &&
	                    nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?
	                nextIt :
	                nextRemove;
	            var adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
	            var currentIndex = record.currentIndex;
	            // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary
	            if (record === nextRemove) {
	                addRemoveOffset--;
	                nextRemove = nextRemove._nextRemoved;
	            }
	            else {
	                nextIt = nextIt._next;
	                if (record.previousIndex == null) {
	                    addRemoveOffset++;
	                }
	                else {
	                    // INVARIANT:  currentIndex < previousIndex
	                    if (!moveOffsets)
	                        moveOffsets = [];
	                    var localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
	                    var localCurrentIndex = currentIndex - addRemoveOffset;
	                    if (localMovePreviousIndex != localCurrentIndex) {
	                        for (var i = 0; i < localMovePreviousIndex; i++) {
	                            var offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);
	                            var index = offset + i;
	                            if (localCurrentIndex <= index && index < localMovePreviousIndex) {
	                                moveOffsets[i] = offset + 1;
	                            }
	                        }
	                        var previousIndex = record.previousIndex;
	                        moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
	                    }
	                }
	            }
	            if (adjPreviousIndex !== currentIndex) {
	                fn(record, adjPreviousIndex, currentIndex);
	            }
	        }
	    };
	    DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {
	        var record;
	        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {
	        var record;
	        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {
	        var record;
	        for (record = this._movesHead; record !== null; record = record._nextMoved) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {
	        var record;
	        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.forEachIdentityChange = function (fn) {
	        var record;
	        for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.diff = function (collection) {
	        if (lang_1.isBlank(collection))
	            collection = [];
	        if (!collection_1.isListLikeIterable(collection)) {
	            throw new exceptions_1.BaseException("Error trying to diff '" + collection + "'");
	        }
	        if (this.check(collection)) {
	            return this;
	        }
	        else {
	            return null;
	        }
	    };
	    DefaultIterableDiffer.prototype.onDestroy = function () { };
	    // todo(vicb): optim for UnmodifiableListView (frozen arrays)
	    DefaultIterableDiffer.prototype.check = function (collection) {
	        var _this = this;
	        this._reset();
	        var record = this._itHead;
	        var mayBeDirty = false;
	        var index;
	        var item;
	        var itemTrackBy;
	        if (lang_1.isArray(collection)) {
	            var list = collection;
	            this._length = collection.length;
	            for (index = 0; index < this._length; index++) {
	                item = list[index];
	                itemTrackBy = this._trackByFn(index, item);
	                if (record === null || !lang_1.looseIdentical(record.trackById, itemTrackBy)) {
	                    record = this._mismatch(record, item, itemTrackBy, index);
	                    mayBeDirty = true;
	                }
	                else {
	                    if (mayBeDirty) {
	                        // TODO(misko): can we limit this to duplicates only?
	                        record = this._verifyReinsertion(record, item, itemTrackBy, index);
	                    }
	                    if (!lang_1.looseIdentical(record.item, item))
	                        this._addIdentityChange(record, item);
	                }
	                record = record._next;
	            }
	        }
	        else {
	            index = 0;
	            collection_1.iterateListLike(collection, function (item /** TODO #9100 */) {
	                itemTrackBy = _this._trackByFn(index, item);
	                if (record === null || !lang_1.looseIdentical(record.trackById, itemTrackBy)) {
	                    record = _this._mismatch(record, item, itemTrackBy, index);
	                    mayBeDirty = true;
	                }
	                else {
	                    if (mayBeDirty) {
	                        // TODO(misko): can we limit this to duplicates only?
	                        record = _this._verifyReinsertion(record, item, itemTrackBy, index);
	                    }
	                    if (!lang_1.looseIdentical(record.item, item))
	                        _this._addIdentityChange(record, item);
	                }
	                record = record._next;
	                index++;
	            });
	            this._length = index;
	        }
	        this._truncate(record);
	        this._collection = collection;
	        return this.isDirty;
	    };
	    Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
	        /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
	         * changes.
	         */
	        get: function () {
	            return this._additionsHead !== null || this._movesHead !== null ||
	                this._removalsHead !== null || this._identityChangesHead !== null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Reset the state of the change objects to show no changes. This means set previousKey to
	     * currentKey, and clear all of the queues (additions, moves, removals).
	     * Set the previousIndexes of moved and added items to their currentIndexes
	     * Reset the list of additions, moves and removals
	     *
	     * @internal
	     */
	    DefaultIterableDiffer.prototype._reset = function () {
	        if (this.isDirty) {
	            var record;
	            var nextRecord;
	            for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
	                record._nextPrevious = record._next;
	            }
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                record.previousIndex = record.currentIndex;
	            }
	            this._additionsHead = this._additionsTail = null;
	            for (record = this._movesHead; record !== null; record = nextRecord) {
	                record.previousIndex = record.currentIndex;
	                nextRecord = record._nextMoved;
	            }
	            this._movesHead = this._movesTail = null;
	            this._removalsHead = this._removalsTail = null;
	            this._identityChangesHead = this._identityChangesTail = null;
	        }
	    };
	    /**
	     * This is the core function which handles differences between collections.
	     *
	     * - `record` is the record which we saw at this position last time. If null then it is a new
	     *   item.
	     * - `item` is the current item in the collection
	     * - `index` is the position of the item in the collection
	     *
	     * @internal
	     */
	    DefaultIterableDiffer.prototype._mismatch = function (record, item, itemTrackBy, index) {
	        // The previous record after which we will append the current one.
	        var previousRecord;
	        if (record === null) {
	            previousRecord = this._itTail;
	        }
	        else {
	            previousRecord = record._prev;
	            // Remove the record from the collection since we know it does not match the item.
	            this._remove(record);
	        }
	        // Attempt to see if we have seen the item before.
	        record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
	        if (record !== null) {
	            // We have seen this before, we need to move it forward in the collection.
	            // But first we need to check if identity changed, so we can update in view if necessary
	            if (!lang_1.looseIdentical(record.item, item))
	                this._addIdentityChange(record, item);
	            this._moveAfter(record, previousRecord, index);
	        }
	        else {
	            // Never seen it, check evicted list.
	            record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
	            if (record !== null) {
	                // It is an item which we have evicted earlier: reinsert it back into the list.
	                // But first we need to check if identity changed, so we can update in view if necessary
	                if (!lang_1.looseIdentical(record.item, item))
	                    this._addIdentityChange(record, item);
	                this._reinsertAfter(record, previousRecord, index);
	            }
	            else {
	                // It is a new item: add it.
	                record =
	                    this._addAfter(new CollectionChangeRecord(item, itemTrackBy), previousRecord, index);
	            }
	        }
	        return record;
	    };
	    /**
	     * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
	     *
	     * Use case: `[a, a]` => `[b, a, a]`
	     *
	     * If we did not have this check then the insertion of `b` would:
	     *   1) evict first `a`
	     *   2) insert `b` at `0` index.
	     *   3) leave `a` at index `1` as is. <-- this is wrong!
	     *   3) reinsert `a` at index 2. <-- this is wrong!
	     *
	     * The correct behavior is:
	     *   1) evict first `a`
	     *   2) insert `b` at `0` index.
	     *   3) reinsert `a` at index 1.
	     *   3) move `a` at from `1` to `2`.
	     *
	     *
	     * Double check that we have not evicted a duplicate item. We need to check if the item type may
	     * have already been removed:
	     * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
	     * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
	     * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
	     * at the end.
	     *
	     * @internal
	     */
	    DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, itemTrackBy, index) {
	        var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
	        if (reinsertRecord !== null) {
	            record = this._reinsertAfter(reinsertRecord, record._prev, index);
	        }
	        else if (record.currentIndex != index) {
	            record.currentIndex = index;
	            this._addToMoves(record, index);
	        }
	        return record;
	    };
	    /**
	     * Get rid of any excess {@link CollectionChangeRecord}s from the previous collection
	     *
	     * - `record` The first excess {@link CollectionChangeRecord}.
	     *
	     * @internal
	     */
	    DefaultIterableDiffer.prototype._truncate = function (record) {
	        // Anything after that needs to be removed;
	        while (record !== null) {
	            var nextRecord = record._next;
	            this._addToRemovals(this._unlink(record));
	            record = nextRecord;
	        }
	        if (this._unlinkedRecords !== null) {
	            this._unlinkedRecords.clear();
	        }
	        if (this._additionsTail !== null) {
	            this._additionsTail._nextAdded = null;
	        }
	        if (this._movesTail !== null) {
	            this._movesTail._nextMoved = null;
	        }
	        if (this._itTail !== null) {
	            this._itTail._next = null;
	        }
	        if (this._removalsTail !== null) {
	            this._removalsTail._nextRemoved = null;
	        }
	        if (this._identityChangesTail !== null) {
	            this._identityChangesTail._nextIdentityChange = null;
	        }
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {
	        if (this._unlinkedRecords !== null) {
	            this._unlinkedRecords.remove(record);
	        }
	        var prev = record._prevRemoved;
	        var next = record._nextRemoved;
	        if (prev === null) {
	            this._removalsHead = next;
	        }
	        else {
	            prev._nextRemoved = next;
	        }
	        if (next === null) {
	            this._removalsTail = prev;
	        }
	        else {
	            next._prevRemoved = prev;
	        }
	        this._insertAfter(record, prevRecord, index);
	        this._addToMoves(record, index);
	        return record;
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {
	        this._unlink(record);
	        this._insertAfter(record, prevRecord, index);
	        this._addToMoves(record, index);
	        return record;
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {
	        this._insertAfter(record, prevRecord, index);
	        if (this._additionsTail === null) {
	            // todo(vicb)
	            // assert(this._additionsHead === null);
	            this._additionsTail = this._additionsHead = record;
	        }
	        else {
	            // todo(vicb)
	            // assert(_additionsTail._nextAdded === null);
	            // assert(record._nextAdded === null);
	            this._additionsTail = this._additionsTail._nextAdded = record;
	        }
	        return record;
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {
	        // todo(vicb)
	        // assert(record != prevRecord);
	        // assert(record._next === null);
	        // assert(record._prev === null);
	        var next = prevRecord === null ? this._itHead : prevRecord._next;
	        // todo(vicb)
	        // assert(next != record);
	        // assert(prevRecord != record);
	        record._next = next;
	        record._prev = prevRecord;
	        if (next === null) {
	            this._itTail = record;
	        }
	        else {
	            next._prev = record;
	        }
	        if (prevRecord === null) {
	            this._itHead = record;
	        }
	        else {
	            prevRecord._next = record;
	        }
	        if (this._linkedRecords === null) {
	            this._linkedRecords = new _DuplicateMap();
	        }
	        this._linkedRecords.put(record);
	        record.currentIndex = index;
	        return record;
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._remove = function (record) {
	        return this._addToRemovals(this._unlink(record));
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._unlink = function (record) {
	        if (this._linkedRecords !== null) {
	            this._linkedRecords.remove(record);
	        }
	        var prev = record._prev;
	        var next = record._next;
	        // todo(vicb)
	        // assert((record._prev = null) === null);
	        // assert((record._next = null) === null);
	        if (prev === null) {
	            this._itHead = next;
	        }
	        else {
	            prev._next = next;
	        }
	        if (next === null) {
	            this._itTail = prev;
	        }
	        else {
	            next._prev = prev;
	        }
	        return record;
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {
	        // todo(vicb)
	        // assert(record._nextMoved === null);
	        if (record.previousIndex === toIndex) {
	            return record;
	        }
	        if (this._movesTail === null) {
	            // todo(vicb)
	            // assert(_movesHead === null);
	            this._movesTail = this._movesHead = record;
	        }
	        else {
	            // todo(vicb)
	            // assert(_movesTail._nextMoved === null);
	            this._movesTail = this._movesTail._nextMoved = record;
	        }
	        return record;
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._addToRemovals = function (record) {
	        if (this._unlinkedRecords === null) {
	            this._unlinkedRecords = new _DuplicateMap();
	        }
	        this._unlinkedRecords.put(record);
	        record.currentIndex = null;
	        record._nextRemoved = null;
	        if (this._removalsTail === null) {
	            // todo(vicb)
	            // assert(_removalsHead === null);
	            this._removalsTail = this._removalsHead = record;
	            record._prevRemoved = null;
	        }
	        else {
	            // todo(vicb)
	            // assert(_removalsTail._nextRemoved === null);
	            // assert(record._nextRemoved === null);
	            record._prevRemoved = this._removalsTail;
	            this._removalsTail = this._removalsTail._nextRemoved = record;
	        }
	        return record;
	    };
	    /** @internal */
	    DefaultIterableDiffer.prototype._addIdentityChange = function (record, item) {
	        record.item = item;
	        if (this._identityChangesTail === null) {
	            this._identityChangesTail = this._identityChangesHead = record;
	        }
	        else {
	            this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
	        }
	        return record;
	    };
	    DefaultIterableDiffer.prototype.toString = function () {
	        var list = [];
	        this.forEachItem(function (record /** TODO #9100 */) { return list.push(record); });
	        var previous = [];
	        this.forEachPreviousItem(function (record /** TODO #9100 */) { return previous.push(record); });
	        var additions = [];
	        this.forEachAddedItem(function (record /** TODO #9100 */) { return additions.push(record); });
	        var moves = [];
	        this.forEachMovedItem(function (record /** TODO #9100 */) { return moves.push(record); });
	        var removals = [];
	        this.forEachRemovedItem(function (record /** TODO #9100 */) { return removals.push(record); });
	        var identityChanges = [];
	        this.forEachIdentityChange(function (record /** TODO #9100 */) { return identityChanges.push(record); });
	        return 'collection: ' + list.join(', ') + '\n' +
	            'previous: ' + previous.join(', ') + '\n' +
	            'additions: ' + additions.join(', ') + '\n' +
	            'moves: ' + moves.join(', ') + '\n' +
	            'removals: ' + removals.join(', ') + '\n' +
	            'identityChanges: ' + identityChanges.join(', ') + '\n';
	    };
	    return DefaultIterableDiffer;
	}());
	exports.DefaultIterableDiffer = DefaultIterableDiffer;
	/**
	 * @stable
	 */
	var CollectionChangeRecord = (function () {
	    function CollectionChangeRecord(item, trackById) {
	        this.item = item;
	        this.trackById = trackById;
	        this.currentIndex = null;
	        this.previousIndex = null;
	        /** @internal */
	        this._nextPrevious = null;
	        /** @internal */
	        this._prev = null;
	        /** @internal */
	        this._next = null;
	        /** @internal */
	        this._prevDup = null;
	        /** @internal */
	        this._nextDup = null;
	        /** @internal */
	        this._prevRemoved = null;
	        /** @internal */
	        this._nextRemoved = null;
	        /** @internal */
	        this._nextAdded = null;
	        /** @internal */
	        this._nextMoved = null;
	        /** @internal */
	        this._nextIdentityChange = null;
	    }
	    CollectionChangeRecord.prototype.toString = function () {
	        return this.previousIndex === this.currentIndex ? lang_1.stringify(this.item) :
	            lang_1.stringify(this.item) + '[' +
	                lang_1.stringify(this.previousIndex) + '->' + lang_1.stringify(this.currentIndex) + ']';
	    };
	    return CollectionChangeRecord;
	}());
	exports.CollectionChangeRecord = CollectionChangeRecord;
	// A linked list of CollectionChangeRecords with the same CollectionChangeRecord.item
	var _DuplicateItemRecordList = (function () {
	    function _DuplicateItemRecordList() {
	        /** @internal */
	        this._head = null;
	        /** @internal */
	        this._tail = null;
	    }
	    /**
	     * Append the record to the list of duplicates.
	     *
	     * Note: by design all records in the list of duplicates hold the same value in record.item.
	     */
	    _DuplicateItemRecordList.prototype.add = function (record) {
	        if (this._head === null) {
	            this._head = this._tail = record;
	            record._nextDup = null;
	            record._prevDup = null;
	        }
	        else {
	            // todo(vicb)
	            // assert(record.item ==  _head.item ||
	            //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
	            this._tail._nextDup = record;
	            record._prevDup = this._tail;
	            record._nextDup = null;
	            this._tail = record;
	        }
	    };
	    // Returns a CollectionChangeRecord having CollectionChangeRecord.trackById == trackById and
	    // CollectionChangeRecord.currentIndex >= afterIndex
	    _DuplicateItemRecordList.prototype.get = function (trackById, afterIndex) {
	        var record;
	        for (record = this._head; record !== null; record = record._nextDup) {
	            if ((afterIndex === null || afterIndex < record.currentIndex) &&
	                lang_1.looseIdentical(record.trackById, trackById)) {
	                return record;
	            }
	        }
	        return null;
	    };
	    /**
	     * Remove one {@link CollectionChangeRecord} from the list of duplicates.
	     *
	     * Returns whether the list of duplicates is empty.
	     */
	    _DuplicateItemRecordList.prototype.remove = function (record) {
	        // todo(vicb)
	        // assert(() {
	        //  // verify that the record being removed is in the list.
	        //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {
	        //    if (identical(cursor, record)) return true;
	        //  }
	        //  return false;
	        //});
	        var prev = record._prevDup;
	        var next = record._nextDup;
	        if (prev === null) {
	            this._head = next;
	        }
	        else {
	            prev._nextDup = next;
	        }
	        if (next === null) {
	            this._tail = prev;
	        }
	        else {
	            next._prevDup = prev;
	        }
	        return this._head === null;
	    };
	    return _DuplicateItemRecordList;
	}());
	var _DuplicateMap = (function () {
	    function _DuplicateMap() {
	        this.map = new Map();
	    }
	    _DuplicateMap.prototype.put = function (record) {
	        // todo(vicb) handle corner cases
	        var key = lang_1.getMapKey(record.trackById);
	        var duplicates = this.map.get(key);
	        if (!lang_1.isPresent(duplicates)) {
	            duplicates = new _DuplicateItemRecordList();
	            this.map.set(key, duplicates);
	        }
	        duplicates.add(record);
	    };
	    /**
	     * Retrieve the `value` using key. Because the CollectionChangeRecord value may be one which we
	     * have already iterated over, we use the afterIndex to pretend it is not there.
	     *
	     * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
	     * have any more `a`s needs to return the last `a` not the first or second.
	     */
	    _DuplicateMap.prototype.get = function (trackById, afterIndex) {
	        if (afterIndex === void 0) { afterIndex = null; }
	        var key = lang_1.getMapKey(trackById);
	        var recordList = this.map.get(key);
	        return lang_1.isBlank(recordList) ? null : recordList.get(trackById, afterIndex);
	    };
	    /**
	     * Removes a {@link CollectionChangeRecord} from the list of duplicates.
	     *
	     * The list of duplicates also is removed from the map if it gets empty.
	     */
	    _DuplicateMap.prototype.remove = function (record) {
	        var key = lang_1.getMapKey(record.trackById);
	        // todo(vicb)
	        // assert(this.map.containsKey(key));
	        var recordList = this.map.get(key);
	        // Remove the list of duplicates when it gets empty
	        if (recordList.remove(record)) {
	            this.map.delete(key);
	        }
	        return record;
	    };
	    Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
	        get: function () { return this.map.size === 0; },
	        enumerable: true,
	        configurable: true
	    });
	    _DuplicateMap.prototype.clear = function () { this.map.clear(); };
	    _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + lang_1.stringify(this.map) + ')'; };
	    return _DuplicateMap;
	}());
	function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
	    var previousIndex = item.previousIndex;
	    if (previousIndex === null)
	        return previousIndex;
	    var moveOffset = 0;
	    if (moveOffsets && previousIndex < moveOffsets.length) {
	        moveOffset = moveOffsets[previousIndex];
	    }
	    return previousIndex + addRemoveOffset + moveOffset;
	}
	//# sourceMappingURL=default_iterable_differ.js.map

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	/**
	 * Describes how the {@link Injector} should instantiate a given token.
	 *
	 * See {@link provide}.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/GNAyj6K6PfYg2NBzgwZ5?p%3Dpreview&p=preview))
	 *
	 * ```javascript
	 * var injector = Injector.resolveAndCreate([
	 *   new Provider("message", { useValue: 'Hello' })
	 * ]);
	 *
	 * expect(injector.get("message")).toEqual('Hello');
	 * ```
	 * @deprecated
	 */
	var Provider = (function () {
	    function Provider(token, _a) {
	        var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
	        this.token = token;
	        this.useClass = useClass;
	        this.useValue = useValue;
	        this.useExisting = useExisting;
	        this.useFactory = useFactory;
	        this.dependencies = deps;
	        this._multi = multi;
	    }
	    Object.defineProperty(Provider.prototype, "multi", {
	        // TODO: Provide a full working example after alpha38 is released.
	        /**
	         * Creates multiple providers matching the same token (a multi-provider).
	         *
	         * Multi-providers are used for creating pluggable service, where the system comes
	         * with some default providers, and the user can register additional providers.
	         * The combination of the default providers and the additional providers will be
	         * used to drive the behavior of the system.
	         *
	         * ### Example
	         *
	         * ```typescript
	         * var injector = Injector.resolveAndCreate([
	         *   new Provider("Strings", { useValue: "String1", multi: true}),
	         *   new Provider("Strings", { useValue: "String2", multi: true})
	         * ]);
	         *
	         * expect(injector.get("Strings")).toEqual(["String1", "String2"]);
	         * ```
	         *
	         * Multi-providers and regular providers cannot be mixed. The following
	         * will throw an exception:
	         *
	         * ```typescript
	         * var injector = Injector.resolveAndCreate([
	         *   new Provider("Strings", { useValue: "String1", multi: true }),
	         *   new Provider("Strings", { useValue: "String2"})
	         * ]);
	         * ```
	         */
	        get: function () { return lang_1.normalizeBool(this._multi); },
	        enumerable: true,
	        configurable: true
	    });
	    return Provider;
	}());
	exports.Provider = Provider;
	/**
	 * See {@link Provider} instead.
	 *
	 * @deprecated
	 */
	var Binding = (function (_super) {
	    __extends(Binding, _super);
	    function Binding(token, _a) {
	        var toClass = _a.toClass, toValue = _a.toValue, toAlias = _a.toAlias, toFactory = _a.toFactory, deps = _a.deps, multi = _a.multi;
	        _super.call(this, token, {
	            useClass: toClass,
	            useValue: toValue,
	            useExisting: toAlias,
	            useFactory: toFactory,
	            deps: deps,
	            multi: multi
	        });
	    }
	    Object.defineProperty(Binding.prototype, "toClass", {
	        /**
	         * @deprecated
	         */
	        get: function () { return this.useClass; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Binding.prototype, "toAlias", {
	        /**
	         * @deprecated
	         */
	        get: function () { return this.useExisting; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Binding.prototype, "toFactory", {
	        /**
	         * @deprecated
	         */
	        get: function () { return this.useFactory; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Binding.prototype, "toValue", {
	        /**
	         * @deprecated
	         */
	        get: function () { return this.useValue; },
	        enumerable: true,
	        configurable: true
	    });
	    return Binding;
	}(Provider));
	exports.Binding = Binding;
	/**
	 * Creates a {@link Provider}.
	 *
	 * To construct a {@link Provider}, bind a `token` to either a class, a value, a factory function,
	 * or
	 * to an existing `token`.
	 * See {@link ProviderBuilder} for more details.
	 *
	 * The `token` is most commonly a class or {@link OpaqueToken}.
	 *
	 * @deprecated
	 */
	function bind(token) {
	    return new ProviderBuilder(token);
	}
	exports.bind = bind;
	/**
	 * Helper class for the {@link bind} function.
	 * @deprecated
	 */
	var ProviderBuilder = (function () {
	    function ProviderBuilder(token) {
	        this.token = token;
	    }
	    /**
	     * Binds a DI token to a class.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/ZpBCSYqv6e2ud5KXLdxQ?p=preview))
	     *
	     * Because `toAlias` and `toClass` are often confused, the example contains
	     * both use cases for easy comparison.
	     *
	     * ```typescript
	     * class Vehicle {}
	     *
	     * class Car extends Vehicle {}
	     *
	     * var injectorClass = Injector.resolveAndCreate([
	     *   Car,
	     *   {provide: Vehicle, useClass: Car}
	     * ]);
	     * var injectorAlias = Injector.resolveAndCreate([
	     *   Car,
	     *   {provide: Vehicle, useExisting: Car}
	     * ]);
	     *
	     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
	     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
	     *
	     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
	     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
	     * ```
	     */
	    ProviderBuilder.prototype.toClass = function (type) {
	        if (!lang_1.isType(type)) {
	            throw new exceptions_1.BaseException("Trying to create a class provider but \"" + lang_1.stringify(type) + "\" is not a class!");
	        }
	        return new Provider(this.token, { useClass: type });
	    };
	    /**
	     * Binds a DI token to a value.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/G024PFHmDL0cJFgfZK8O?p=preview))
	     *
	     * ```typescript
	     * var injector = Injector.resolveAndCreate([
	     *   {provide: 'message', useValue: 'Hello'}
	     * ]);
	     *
	     * expect(injector.get('message')).toEqual('Hello');
	     * ```
	     */
	    ProviderBuilder.prototype.toValue = function (value) { return new Provider(this.token, { useValue: value }); };
	    /**
	     * Binds a DI token to an existing token.
	     *
	     * Angular will return the same instance as if the provided token was used. (This is
	     * in contrast to `useClass` where a separate instance of `useClass` will be returned.)
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/uBaoF2pN5cfc5AfZapNw?p=preview))
	     *
	     * Because `toAlias` and `toClass` are often confused, the example contains
	     * both use cases for easy comparison.
	     *
	     * ```typescript
	     * class Vehicle {}
	     *
	     * class Car extends Vehicle {}
	     *
	     * var injectorAlias = Injector.resolveAndCreate([
	     *   Car,
	     *   {provide: Vehicle, useExisting: Car}
	     * ]);
	     * var injectorClass = Injector.resolveAndCreate([
	     *   Car,
	     *   {provide: Vehicle, useClass: Car})
	     * ]);
	     *
	     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
	     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
	     *
	     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
	     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
	     * ```
	     */
	    ProviderBuilder.prototype.toAlias = function (aliasToken) {
	        if (lang_1.isBlank(aliasToken)) {
	            throw new exceptions_1.BaseException("Can not alias " + lang_1.stringify(this.token) + " to a blank value!");
	        }
	        return new Provider(this.token, { useExisting: aliasToken });
	    };
	    /**
	     * Binds a DI token to a function which computes the value.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/OejNIfTT3zb1iBxaIYOb?p=preview))
	     *
	     * ```typescript
	     * var injector = Injector.resolveAndCreate([
	     *   {provide: Number, useFactory: () => { return 1+2; }},
	     *   {provide: String, useFactory: (v) => { return "Value: " + v; }, deps: [Number]}
	     * ]);
	     *
	     * expect(injector.get(Number)).toEqual(3);
	     * expect(injector.get(String)).toEqual('Value: 3');
	     * ```
	     */
	    ProviderBuilder.prototype.toFactory = function (factory, dependencies) {
	        if (!lang_1.isFunction(factory)) {
	            throw new exceptions_1.BaseException("Trying to create a factory provider but \"" + lang_1.stringify(factory) + "\" is not a function!");
	        }
	        return new Provider(this.token, { useFactory: factory, deps: dependencies });
	    };
	    return ProviderBuilder;
	}());
	exports.ProviderBuilder = ProviderBuilder;
	/**
	 * Creates a {@link Provider}.
	 *
	 * See {@link Provider} for more details.
	 *
	 * <!-- TODO: improve the docs -->
	 * @deprecated
	 */
	function provide(token, _a) {
	    var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
	    return new Provider(token, {
	        useClass: useClass,
	        useValue: useValue,
	        useExisting: useExisting,
	        useFactory: useFactory,
	        deps: deps,
	        multi: multi
	    });
	}
	exports.provide = provide;
	//# sourceMappingURL=provider.js.map

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	function findFirstClosedCycle(keys) {
	    var res = [];
	    for (var i = 0; i < keys.length; ++i) {
	        if (collection_1.ListWrapper.contains(res, keys[i])) {
	            res.push(keys[i]);
	            return res;
	        }
	        res.push(keys[i]);
	    }
	    return res;
	}
	function constructResolvingPath(keys) {
	    if (keys.length > 1) {
	        var reversed = findFirstClosedCycle(collection_1.ListWrapper.reversed(keys));
	        var tokenStrs = reversed.map(function (k) { return lang_1.stringify(k.token); });
	        return ' (' + tokenStrs.join(' -> ') + ')';
	    }
	    return '';
	}
	/**
	 * Base class for all errors arising from misconfigured providers.
	 * @stable
	 */
	var AbstractProviderError = (function (_super) {
	    __extends(AbstractProviderError, _super);
	    function AbstractProviderError(injector, key, constructResolvingMessage) {
	        _super.call(this, 'DI Exception');
	        this.keys = [key];
	        this.injectors = [injector];
	        this.constructResolvingMessage = constructResolvingMessage;
	        this.message = this.constructResolvingMessage(this.keys);
	    }
	    AbstractProviderError.prototype.addKey = function (injector, key) {
	        this.injectors.push(injector);
	        this.keys.push(key);
	        this.message = this.constructResolvingMessage(this.keys);
	    };
	    Object.defineProperty(AbstractProviderError.prototype, "context", {
	        get: function () { return this.injectors[this.injectors.length - 1].debugContext(); },
	        enumerable: true,
	        configurable: true
	    });
	    return AbstractProviderError;
	}(exceptions_1.BaseException));
	exports.AbstractProviderError = AbstractProviderError;
	/**
	 * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the
	 * {@link Injector} does not have a {@link Provider} for the given key.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))
	 *
	 * ```typescript
	 * class A {
	 *   constructor(b:B) {}
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	 * ```
	 * @stable
	 */
	var NoProviderError = (function (_super) {
	    __extends(NoProviderError, _super);
	    function NoProviderError(injector, key) {
	        _super.call(this, injector, key, function (keys) {
	            var first = lang_1.stringify(collection_1.ListWrapper.first(keys).token);
	            return "No provider for " + first + "!" + constructResolvingPath(keys);
	        });
	    }
	    return NoProviderError;
	}(AbstractProviderError));
	exports.NoProviderError = NoProviderError;
	/**
	 * Thrown when dependencies form a cycle.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))
	 *
	 * ```typescript
	 * var injector = Injector.resolveAndCreate([
	 *   {provide: "one", useFactory: (two) => "two", deps: [[new Inject("two")]]},
	 *   {provide: "two", useFactory: (one) => "one", deps: [[new Inject("one")]]}
	 * ]);
	 *
	 * expect(() => injector.get("one")).toThrowError();
	 * ```
	 *
	 * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
	 * @stable
	 */
	var CyclicDependencyError = (function (_super) {
	    __extends(CyclicDependencyError, _super);
	    function CyclicDependencyError(injector, key) {
	        _super.call(this, injector, key, function (keys) {
	            return "Cannot instantiate cyclic dependency!" + constructResolvingPath(keys);
	        });
	    }
	    return CyclicDependencyError;
	}(AbstractProviderError));
	exports.CyclicDependencyError = CyclicDependencyError;
	/**
	 * Thrown when a constructing type returns with an Error.
	 *
	 * The `InstantiationError` class contains the original error plus the dependency graph which caused
	 * this object to be instantiated.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))
	 *
	 * ```typescript
	 * class A {
	 *   constructor() {
	 *     throw new Error('message');
	 *   }
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([A]);

	 * try {
	 *   injector.get(A);
	 * } catch (e) {
	 *   expect(e instanceof InstantiationError).toBe(true);
	 *   expect(e.originalException.message).toEqual("message");
	 *   expect(e.originalStack).toBeDefined();
	 * }
	 * ```
	 * @stable
	 */
	var InstantiationError = (function (_super) {
	    __extends(InstantiationError, _super);
	    function InstantiationError(injector, originalException, originalStack, key) {
	        _super.call(this, 'DI Exception', originalException, originalStack, null);
	        this.keys = [key];
	        this.injectors = [injector];
	    }
	    InstantiationError.prototype.addKey = function (injector, key) {
	        this.injectors.push(injector);
	        this.keys.push(key);
	    };
	    Object.defineProperty(InstantiationError.prototype, "wrapperMessage", {
	        get: function () {
	            var first = lang_1.stringify(collection_1.ListWrapper.first(this.keys).token);
	            return "Error during instantiation of " + first + "!" + constructResolvingPath(this.keys) + ".";
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(InstantiationError.prototype, "causeKey", {
	        get: function () { return this.keys[0]; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(InstantiationError.prototype, "context", {
	        get: function () { return this.injectors[this.injectors.length - 1].debugContext(); },
	        enumerable: true,
	        configurable: true
	    });
	    return InstantiationError;
	}(exceptions_1.WrappedException));
	exports.InstantiationError = InstantiationError;
	/**
	 * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}
	 * creation.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))
	 *
	 * ```typescript
	 * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
	 * ```
	 * @stable
	 */
	var InvalidProviderError = (function (_super) {
	    __extends(InvalidProviderError, _super);
	    function InvalidProviderError(provider) {
	        _super.call(this, "Invalid provider - only instances of Provider and Type are allowed, got: " + provider);
	    }
	    return InvalidProviderError;
	}(exceptions_1.BaseException));
	exports.InvalidProviderError = InvalidProviderError;
	/**
	 * Thrown when the class has no annotation information.
	 *
	 * Lack of annotation information prevents the {@link Injector} from determining which dependencies
	 * need to be injected into the constructor.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))
	 *
	 * ```typescript
	 * class A {
	 *   constructor(b) {}
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	 * ```
	 *
	 * This error is also thrown when the class not marked with {@link Injectable} has parameter types.
	 *
	 * ```typescript
	 * class B {}
	 *
	 * class A {
	 *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
	 * ```
	 * @stable
	 */
	var NoAnnotationError = (function (_super) {
	    __extends(NoAnnotationError, _super);
	    function NoAnnotationError(typeOrFunc, params) {
	        _super.call(this, NoAnnotationError._genMessage(typeOrFunc, params));
	    }
	    NoAnnotationError._genMessage = function (typeOrFunc, params) {
	        var signature = [];
	        for (var i = 0, ii = params.length; i < ii; i++) {
	            var parameter = params[i];
	            if (lang_1.isBlank(parameter) || parameter.length == 0) {
	                signature.push('?');
	            }
	            else {
	                signature.push(parameter.map(lang_1.stringify).join(' '));
	            }
	        }
	        return 'Cannot resolve all parameters for \'' + lang_1.stringify(typeOrFunc) + '\'(' +
	            signature.join(', ') + '). ' +
	            'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \'' +
	            lang_1.stringify(typeOrFunc) + '\' is decorated with Injectable.';
	    };
	    return NoAnnotationError;
	}(exceptions_1.BaseException));
	exports.NoAnnotationError = NoAnnotationError;
	/**
	 * Thrown when getting an object by index.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))
	 *
	 * ```typescript
	 * class A {}
	 *
	 * var injector = Injector.resolveAndCreate([A]);
	 *
	 * expect(() => injector.getAt(100)).toThrowError();
	 * ```
	 * @stable
	 */
	var OutOfBoundsError = (function (_super) {
	    __extends(OutOfBoundsError, _super);
	    function OutOfBoundsError(index) {
	        _super.call(this, "Index " + index + " is out-of-bounds.");
	    }
	    return OutOfBoundsError;
	}(exceptions_1.BaseException));
	exports.OutOfBoundsError = OutOfBoundsError;
	// TODO: add a working example after alpha38 is released
	/**
	 * Thrown when a multi provider and a regular provider are bound to the same token.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * expect(() => Injector.resolveAndCreate([
	 *   new Provider("Strings", {useValue: "string1", multi: true}),
	 *   new Provider("Strings", {useValue: "string2", multi: false})
	 * ])).toThrowError();
	 * ```
	 */
	var MixingMultiProvidersWithRegularProvidersError = (function (_super) {
	    __extends(MixingMultiProvidersWithRegularProvidersError, _super);
	    function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
	        _super.call(this, 'Cannot mix multi providers and regular providers, got: ' + provider1.toString() + ' ' +
	            provider2.toString());
	    }
	    return MixingMultiProvidersWithRegularProvidersError;
	}(exceptions_1.BaseException));
	exports.MixingMultiProvidersWithRegularProvidersError = MixingMultiProvidersWithRegularProvidersError;
	//# sourceMappingURL=reflective_exceptions.js.map

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	var forward_ref_1 = __webpack_require__(52);
	/**
	 * A unique object used for retrieving items from the {@link ReflectiveInjector}.
	 *
	 * Keys have:
	 * - a system-wide unique `id`.
	 * - a `token`.
	 *
	 * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows
	 * the
	 * injector to store created objects in a more efficient way.
	 *
	 * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when
	 * resolving
	 * providers.
	 * @experimental
	 */
	var ReflectiveKey = (function () {
	    /**
	     * Private
	     */
	    function ReflectiveKey(token, id) {
	        this.token = token;
	        this.id = id;
	        if (lang_1.isBlank(token)) {
	            throw new exceptions_1.BaseException('Token must be defined!');
	        }
	    }
	    Object.defineProperty(ReflectiveKey.prototype, "displayName", {
	        /**
	         * Returns a stringified token.
	         */
	        get: function () { return lang_1.stringify(this.token); },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Retrieves a `Key` for a token.
	     */
	    ReflectiveKey.get = function (token) {
	        return _globalKeyRegistry.get(forward_ref_1.resolveForwardRef(token));
	    };
	    Object.defineProperty(ReflectiveKey, "numberOfKeys", {
	        /**
	         * @returns the number of keys registered in the system.
	         */
	        get: function () { return _globalKeyRegistry.numberOfKeys; },
	        enumerable: true,
	        configurable: true
	    });
	    return ReflectiveKey;
	}());
	exports.ReflectiveKey = ReflectiveKey;
	/**
	 * @internal
	 */
	var KeyRegistry = (function () {
	    function KeyRegistry() {
	        this._allKeys = new Map();
	    }
	    KeyRegistry.prototype.get = function (token) {
	        if (token instanceof ReflectiveKey)
	            return token;
	        if (this._allKeys.has(token)) {
	            return this._allKeys.get(token);
	        }
	        var newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
	        this._allKeys.set(token, newKey);
	        return newKey;
	    };
	    Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
	        get: function () { return this._allKeys.size; },
	        enumerable: true,
	        configurable: true
	    });
	    return KeyRegistry;
	}());
	exports.KeyRegistry = KeyRegistry;
	var _globalKeyRegistry = new KeyRegistry();
	//# sourceMappingURL=reflective_key.js.map

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var lang_1 = __webpack_require__(2);
	var reflection_1 = __webpack_require__(97);
	var forward_ref_1 = __webpack_require__(52);
	var metadata_1 = __webpack_require__(22);
	var provider_1 = __webpack_require__(89);
	var provider_util_1 = __webpack_require__(147);
	var reflective_exceptions_1 = __webpack_require__(90);
	var reflective_key_1 = __webpack_require__(91);
	/**
	 * `Dependency` is used by the framework to extend DI.
	 * This is internal to Angular and should not be used directly.
	 */
	var ReflectiveDependency = (function () {
	    function ReflectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {
	        this.key = key;
	        this.optional = optional;
	        this.lowerBoundVisibility = lowerBoundVisibility;
	        this.upperBoundVisibility = upperBoundVisibility;
	        this.properties = properties;
	    }
	    ReflectiveDependency.fromKey = function (key) {
	        return new ReflectiveDependency(key, false, null, null, []);
	    };
	    return ReflectiveDependency;
	}());
	exports.ReflectiveDependency = ReflectiveDependency;
	var _EMPTY_LIST = [];
	var ResolvedReflectiveProvider_ = (function () {
	    function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {
	        this.key = key;
	        this.resolvedFactories = resolvedFactories;
	        this.multiProvider = multiProvider;
	    }
	    Object.defineProperty(ResolvedReflectiveProvider_.prototype, "resolvedFactory", {
	        get: function () { return this.resolvedFactories[0]; },
	        enumerable: true,
	        configurable: true
	    });
	    return ResolvedReflectiveProvider_;
	}());
	exports.ResolvedReflectiveProvider_ = ResolvedReflectiveProvider_;
	/**
	 * An internal resolved representation of a factory function created by resolving {@link Provider}.
	 * @experimental
	 */
	var ResolvedReflectiveFactory = (function () {
	    function ResolvedReflectiveFactory(
	        /**
	         * Factory function which can return an instance of an object represented by a key.
	         */
	        factory, 
	        /**
	         * Arguments (dependencies) to the `factory` function.
	         */
	        dependencies) {
	        this.factory = factory;
	        this.dependencies = dependencies;
	    }
	    return ResolvedReflectiveFactory;
	}());
	exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;
	/**
	 * Resolve a single provider.
	 */
	function resolveReflectiveFactory(provider) {
	    var factoryFn;
	    var resolvedDeps;
	    if (lang_1.isPresent(provider.useClass)) {
	        var useClass = forward_ref_1.resolveForwardRef(provider.useClass);
	        factoryFn = reflection_1.reflector.factory(useClass);
	        resolvedDeps = _dependenciesFor(useClass);
	    }
	    else if (lang_1.isPresent(provider.useExisting)) {
	        factoryFn = function (aliasInstance) { return aliasInstance; };
	        resolvedDeps = [ReflectiveDependency.fromKey(reflective_key_1.ReflectiveKey.get(provider.useExisting))];
	    }
	    else if (lang_1.isPresent(provider.useFactory)) {
	        factoryFn = provider.useFactory;
	        resolvedDeps = constructDependencies(provider.useFactory, provider.dependencies);
	    }
	    else {
	        factoryFn = function () { return provider.useValue; };
	        resolvedDeps = _EMPTY_LIST;
	    }
	    return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
	}
	exports.resolveReflectiveFactory = resolveReflectiveFactory;
	/**
	 * Converts the {@link Provider} into {@link ResolvedProvider}.
	 *
	 * {@link Injector} internally only uses {@link ResolvedProvider}, {@link Provider} contains
	 * convenience provider syntax.
	 */
	function resolveReflectiveProvider(provider) {
	    return new ResolvedReflectiveProvider_(reflective_key_1.ReflectiveKey.get(provider.token), [resolveReflectiveFactory(provider)], provider.multi);
	}
	exports.resolveReflectiveProvider = resolveReflectiveProvider;
	/**
	 * Resolve a list of Providers.
	 */
	function resolveReflectiveProviders(providers) {
	    var normalized = _normalizeProviders(providers, []);
	    var resolved = normalized.map(resolveReflectiveProvider);
	    return collection_1.MapWrapper.values(mergeResolvedReflectiveProviders(resolved, new Map()));
	}
	exports.resolveReflectiveProviders = resolveReflectiveProviders;
	/**
	 * Merges a list of ResolvedProviders into a list where
	 * each key is contained exactly once and multi providers
	 * have been merged.
	 */
	function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
	    for (var i = 0; i < providers.length; i++) {
	        var provider = providers[i];
	        var existing = normalizedProvidersMap.get(provider.key.id);
	        if (lang_1.isPresent(existing)) {
	            if (provider.multiProvider !== existing.multiProvider) {
	                throw new reflective_exceptions_1.MixingMultiProvidersWithRegularProvidersError(existing, provider);
	            }
	            if (provider.multiProvider) {
	                for (var j = 0; j < provider.resolvedFactories.length; j++) {
	                    existing.resolvedFactories.push(provider.resolvedFactories[j]);
	                }
	            }
	            else {
	                normalizedProvidersMap.set(provider.key.id, provider);
	            }
	        }
	        else {
	            var resolvedProvider;
	            if (provider.multiProvider) {
	                resolvedProvider = new ResolvedReflectiveProvider_(provider.key, collection_1.ListWrapper.clone(provider.resolvedFactories), provider.multiProvider);
	            }
	            else {
	                resolvedProvider = provider;
	            }
	            normalizedProvidersMap.set(provider.key.id, resolvedProvider);
	        }
	    }
	    return normalizedProvidersMap;
	}
	exports.mergeResolvedReflectiveProviders = mergeResolvedReflectiveProviders;
	function _normalizeProviders(providers, res) {
	    providers.forEach(function (b) {
	        if (b instanceof lang_1.Type) {
	            res.push(provider_1.provide(b, { useClass: b }));
	        }
	        else if (b instanceof provider_1.Provider) {
	            res.push(b);
	        }
	        else if (provider_util_1.isProviderLiteral(b)) {
	            res.push(provider_util_1.createProvider(b));
	        }
	        else if (b instanceof Array) {
	            _normalizeProviders(b, res);
	        }
	        else if (b instanceof provider_1.ProviderBuilder) {
	            throw new reflective_exceptions_1.InvalidProviderError(b.token);
	        }
	        else {
	            throw new reflective_exceptions_1.InvalidProviderError(b);
	        }
	    });
	    return res;
	}
	function constructDependencies(typeOrFunc, dependencies) {
	    if (lang_1.isBlank(dependencies)) {
	        return _dependenciesFor(typeOrFunc);
	    }
	    else {
	        var params = dependencies.map(function (t) { return [t]; });
	        return dependencies.map(function (t) { return _extractToken(typeOrFunc, t, params); });
	    }
	}
	exports.constructDependencies = constructDependencies;
	function _dependenciesFor(typeOrFunc) {
	    var params = reflection_1.reflector.parameters(typeOrFunc);
	    if (lang_1.isBlank(params))
	        return [];
	    if (params.some(lang_1.isBlank)) {
	        throw new reflective_exceptions_1.NoAnnotationError(typeOrFunc, params);
	    }
	    return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });
	}
	function _extractToken(typeOrFunc /** TODO #9100 */, metadata /** TODO #9100 */ /*any[] | any*/, params) {
	    var depProps = [];
	    var token = null;
	    var optional = false;
	    if (!lang_1.isArray(metadata)) {
	        if (metadata instanceof metadata_1.InjectMetadata) {
	            return _createDependency(metadata.token, optional, null, null, depProps);
	        }
	        else {
	            return _createDependency(metadata, optional, null, null, depProps);
	        }
	    }
	    var lowerBoundVisibility = null;
	    var upperBoundVisibility = null;
	    for (var i = 0; i < metadata.length; ++i) {
	        var paramMetadata = metadata[i];
	        if (paramMetadata instanceof lang_1.Type) {
	            token = paramMetadata;
	        }
	        else if (paramMetadata instanceof metadata_1.InjectMetadata) {
	            token = paramMetadata.token;
	        }
	        else if (paramMetadata instanceof metadata_1.OptionalMetadata) {
	            optional = true;
	        }
	        else if (paramMetadata instanceof metadata_1.SelfMetadata) {
	            upperBoundVisibility = paramMetadata;
	        }
	        else if (paramMetadata instanceof metadata_1.HostMetadata) {
	            upperBoundVisibility = paramMetadata;
	        }
	        else if (paramMetadata instanceof metadata_1.SkipSelfMetadata) {
	            lowerBoundVisibility = paramMetadata;
	        }
	        else if (paramMetadata instanceof metadata_1.DependencyMetadata) {
	            if (lang_1.isPresent(paramMetadata.token)) {
	                token = paramMetadata.token;
	            }
	            depProps.push(paramMetadata);
	        }
	    }
	    token = forward_ref_1.resolveForwardRef(token);
	    if (lang_1.isPresent(token)) {
	        return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);
	    }
	    else {
	        throw new reflective_exceptions_1.NoAnnotationError(typeOrFunc, params);
	    }
	}
	function _createDependency(token /** TODO #9100 */, optional /** TODO #9100 */, lowerBoundVisibility /** TODO #9100 */, upperBoundVisibility /** TODO #9100 */, depProps /** TODO #9100 */) {
	    return new ReflectiveDependency(reflective_key_1.ReflectiveKey.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);
	}
	//# sourceMappingURL=reflective_provider.js.map

/***/ },
/* 93 */
25,
/* 94 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * Low-level service for loading {@link ComponentFactory}s, which
	 * can later be used to create and render a Component instance.
	 *
	 * @deprecated Use {@link ComponentFactoryResolver} together with {@link
	 * NgModule}.entryComponents}/{@link Component}.entryComponents or
	 * {@link ANALYZE_FOR_ENTRY_COMPONENTS} provider for dynamic component creation.
	 * Use {@link NgModuleFactoryLoader} for lazy loading.
	 */
	var ComponentResolver = (function () {
	    function ComponentResolver() {
	    }
	    ComponentResolver.DynamicCompilationDeprecationMsg = 'ComponentResolver is deprecated for dynamic compilation. Use ComponentFactoryResolver together with @NgModule/@Component.entryComponents or ANALYZE_FOR_ENTRY_COMPONENTS provider instead. For runtime compile only, you can also use Compiler.compileComponentSync/Async.';
	    ComponentResolver.LazyLoadingDeprecationMsg = 'ComponentResolver is deprecated for lazy loading. Use NgModuleFactoryLoader instead.';
	    return ComponentResolver;
	}());
	exports.ComponentResolver = ComponentResolver;
	//# sourceMappingURL=component_resolver.js.map

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	var element_ref_1 = __webpack_require__(153);
	var view_container_ref_1 = __webpack_require__(156);
	var view_type_1 = __webpack_require__(55);
	/**
	 * An AppElement is created for elements that have a ViewContainerRef,
	 * a nested component or a <template> element to keep data around
	 * that is needed for later instantiations.
	 */
	var AppElement = (function () {
	    function AppElement(index, parentIndex, parentView, nativeElement) {
	        this.index = index;
	        this.parentIndex = parentIndex;
	        this.parentView = parentView;
	        this.nativeElement = nativeElement;
	        this.nestedViews = null;
	        this.componentView = null;
	    }
	    Object.defineProperty(AppElement.prototype, "elementRef", {
	        get: function () { return new element_ref_1.ElementRef(this.nativeElement); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AppElement.prototype, "vcRef", {
	        get: function () { return new view_container_ref_1.ViewContainerRef_(this); },
	        enumerable: true,
	        configurable: true
	    });
	    AppElement.prototype.initComponent = function (component, componentConstructorViewQueries, view) {
	        this.component = component;
	        this.componentConstructorViewQueries = componentConstructorViewQueries;
	        this.componentView = view;
	    };
	    Object.defineProperty(AppElement.prototype, "parentInjector", {
	        get: function () { return this.parentView.injector(this.parentIndex); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AppElement.prototype, "injector", {
	        get: function () { return this.parentView.injector(this.index); },
	        enumerable: true,
	        configurable: true
	    });
	    AppElement.prototype.mapNestedViews = function (nestedViewClass, callback) {
	        var result = [];
	        if (lang_1.isPresent(this.nestedViews)) {
	            this.nestedViews.forEach(function (nestedView) {
	                if (nestedView.clazz === nestedViewClass) {
	                    result.push(callback(nestedView));
	                }
	            });
	        }
	        return result;
	    };
	    AppElement.prototype.moveView = function (view, currentIndex) {
	        var previousIndex = this.nestedViews.indexOf(view);
	        if (view.type === view_type_1.ViewType.COMPONENT) {
	            throw new exceptions_1.BaseException("Component views can't be moved!");
	        }
	        var nestedViews = this.nestedViews;
	        if (nestedViews == null) {
	            nestedViews = [];
	            this.nestedViews = nestedViews;
	        }
	        collection_1.ListWrapper.removeAt(nestedViews, previousIndex);
	        collection_1.ListWrapper.insert(nestedViews, currentIndex, view);
	        var refRenderNode;
	        if (currentIndex > 0) {
	            var prevView = nestedViews[currentIndex - 1];
	            refRenderNode = prevView.lastRootNode;
	        }
	        else {
	            refRenderNode = this.nativeElement;
	        }
	        if (lang_1.isPresent(refRenderNode)) {
	            view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);
	        }
	        view.markContentChildAsMoved(this);
	    };
	    AppElement.prototype.attachView = function (view, viewIndex) {
	        if (view.type === view_type_1.ViewType.COMPONENT) {
	            throw new exceptions_1.BaseException("Component views can't be moved!");
	        }
	        var nestedViews = this.nestedViews;
	        if (nestedViews == null) {
	            nestedViews = [];
	            this.nestedViews = nestedViews;
	        }
	        collection_1.ListWrapper.insert(nestedViews, viewIndex, view);
	        var refRenderNode;
	        if (viewIndex > 0) {
	            var prevView = nestedViews[viewIndex - 1];
	            refRenderNode = prevView.lastRootNode;
	        }
	        else {
	            refRenderNode = this.nativeElement;
	        }
	        if (lang_1.isPresent(refRenderNode)) {
	            view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);
	        }
	        view.addToContentChildren(this);
	    };
	    AppElement.prototype.detachView = function (viewIndex) {
	        var view = collection_1.ListWrapper.removeAt(this.nestedViews, viewIndex);
	        if (view.type === view_type_1.ViewType.COMPONENT) {
	            throw new exceptions_1.BaseException("Component views can't be moved!");
	        }
	        view.detach();
	        view.removeFromContentChildren(this);
	        return view;
	    };
	    return AppElement;
	}());
	exports.AppElement = AppElement;
	//# sourceMappingURL=element.js.map

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var change_detection_util_1 = __webpack_require__(49);
	var exceptions_1 = __webpack_require__(4);
	/**
	 * An error thrown if application changes model breaking the top-down data flow.
	 *
	 * This exception is only thrown in dev mode.
	 *
	 * <!-- TODO: Add a link once the dev mode option is configurable -->
	 *
	 * ### Example
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'parent',
	 *   template: `
	 *     <child [prop]="parentProp"></child>
	 *   `,
	 *   directives: [forwardRef(() => Child)]
	 * })
	 * class Parent {
	 *   parentProp = "init";
	 * }
	 *
	 * @Directive({selector: 'child', inputs: ['prop']})
	 * class Child {
	 *   constructor(public parent: Parent) {}
	 *
	 *   set prop(v) {
	 *     // this updates the parent property, which is disallowed during change detection
	 *     // this will result in ExpressionChangedAfterItHasBeenCheckedException
	 *     this.parent.parentProp = "updated";
	 *   }
	 * }
	 * ```
	 * @stable
	 */
	var ExpressionChangedAfterItHasBeenCheckedException = (function (_super) {
	    __extends(ExpressionChangedAfterItHasBeenCheckedException, _super);
	    function ExpressionChangedAfterItHasBeenCheckedException(oldValue, currValue, context) {
	        var msg = "Expression has changed after it was checked. Previous value: '" + oldValue + "'. Current value: '" + currValue + "'.";
	        if (oldValue === change_detection_util_1.UNINITIALIZED) {
	            msg +=
	                " It seems like the view has been created after its parent and its children have been dirty checked." +
	                    " Has it been created in a change detection hook ?";
	        }
	        _super.call(this, msg);
	    }
	    return ExpressionChangedAfterItHasBeenCheckedException;
	}(exceptions_1.BaseException));
	exports.ExpressionChangedAfterItHasBeenCheckedException = ExpressionChangedAfterItHasBeenCheckedException;
	/**
	 * Thrown when an exception was raised during view creation, change detection or destruction.
	 *
	 * This error wraps the original exception to attach additional contextual information that can
	 * be useful for debugging.
	 * @stable
	 */
	var ViewWrappedException = (function (_super) {
	    __extends(ViewWrappedException, _super);
	    function ViewWrappedException(originalException, originalStack, context) {
	        _super.call(this, "Error in " + context.source, originalException, originalStack, context);
	    }
	    return ViewWrappedException;
	}(exceptions_1.WrappedException));
	exports.ViewWrappedException = ViewWrappedException;
	/**
	 * Thrown when a destroyed view is used.
	 *
	 * This error indicates a bug in the framework.
	 *
	 * This is an internal Angular error.
	 * @stable
	 */
	var ViewDestroyedException = (function (_super) {
	    __extends(ViewDestroyedException, _super);
	    function ViewDestroyedException(details) {
	        _super.call(this, "Attempt to use a destroyed view: " + details);
	    }
	    return ViewDestroyedException;
	}(exceptions_1.BaseException));
	exports.ViewDestroyedException = ViewDestroyedException;
	//# sourceMappingURL=exceptions.js.map

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var reflection_capabilities_1 = __webpack_require__(164);
	var reflector_1 = __webpack_require__(165);
	var reflector_2 = __webpack_require__(165);
	exports.ReflectionInfo = reflector_2.ReflectionInfo;
	exports.Reflector = reflector_2.Reflector;
	/**
	 * The {@link Reflector} used internally in Angular to access metadata
	 * about symbols.
	 */
	exports.reflector = new reflector_1.Reflector(new reflection_capabilities_1.ReflectionCapabilities());
	//# sourceMappingURL=reflection.js.map

/***/ },
/* 98 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * Provides read-only access to reflection data about symbols. Used internally by Angular
	 * to power dependency injection and compilation.
	 */
	var ReflectorReader = (function () {
	    function ReflectorReader() {
	    }
	    return ReflectorReader;
	}());
	exports.ReflectorReader = ReflectorReader;
	//# sourceMappingURL=reflector_reader.js.map

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var exceptions_1 = __webpack_require__(4);
	/**
	 * @experimental
	 */
	// TODO (matsko): add typing for the animation function
	var RenderComponentType = (function () {
	    function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles, animations) {
	        this.id = id;
	        this.templateUrl = templateUrl;
	        this.slotCount = slotCount;
	        this.encapsulation = encapsulation;
	        this.styles = styles;
	        this.animations = animations;
	    }
	    return RenderComponentType;
	}());
	exports.RenderComponentType = RenderComponentType;
	var RenderDebugInfo = (function () {
	    function RenderDebugInfo() {
	    }
	    Object.defineProperty(RenderDebugInfo.prototype, "injector", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RenderDebugInfo.prototype, "component", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RenderDebugInfo.prototype, "providerTokens", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RenderDebugInfo.prototype, "references", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RenderDebugInfo.prototype, "context", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RenderDebugInfo.prototype, "source", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    return RenderDebugInfo;
	}());
	exports.RenderDebugInfo = RenderDebugInfo;
	/**
	 * @experimental
	 */
	var Renderer = (function () {
	    function Renderer() {
	    }
	    return Renderer;
	}());
	exports.Renderer = Renderer;
	/**
	 * Injectable service that provides a low-level interface for modifying the UI.
	 *
	 * Use this service to bypass Angular's templating and make custom UI changes that can't be
	 * expressed declaratively. For example if you need to set a property or an attribute whose name is
	 * not statically known, use {@link #setElementProperty} or {@link #setElementAttribute}
	 * respectively.
	 *
	 * If you are implementing a custom renderer, you must implement this interface.
	 *
	 * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
	 * @experimental
	 */
	var RootRenderer = (function () {
	    function RootRenderer() {
	    }
	    return RootRenderer;
	}());
	exports.RootRenderer = RootRenderer;
	//# sourceMappingURL=api.js.map

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var decorators_1 = __webpack_require__(30);
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	var ng_zone_1 = __webpack_require__(101);
	var Testability = (function () {
	    function Testability(_ngZone) {
	        this._ngZone = _ngZone;
	        /** @internal */
	        this._pendingCount = 0;
	        /** @internal */
	        this._isZoneStable = true;
	        /**
	         * Whether any work was done since the last 'whenStable' callback. This is
	         * useful to detect if this could have potentially destabilized another
	         * component while it is stabilizing.
	         * @internal
	         */
	        this._didWork = false;
	        /** @internal */
	        this._callbacks = [];
	        this._watchAngularEvents();
	    }
	    /** @internal */
	    Testability.prototype._watchAngularEvents = function () {
	        var _this = this;
	        this._ngZone.onUnstable.subscribe({
	            next: function () {
	                _this._didWork = true;
	                _this._isZoneStable = false;
	            }
	        });
	        this._ngZone.runOutsideAngular(function () {
	            _this._ngZone.onStable.subscribe({
	                next: function () {
	                    ng_zone_1.NgZone.assertNotInAngularZone();
	                    lang_1.scheduleMicroTask(function () {
	                        _this._isZoneStable = true;
	                        _this._runCallbacksIfReady();
	                    });
	                }
	            });
	        });
	    };
	    Testability.prototype.increasePendingRequestCount = function () {
	        this._pendingCount += 1;
	        this._didWork = true;
	        return this._pendingCount;
	    };
	    Testability.prototype.decreasePendingRequestCount = function () {
	        this._pendingCount -= 1;
	        if (this._pendingCount < 0) {
	            throw new exceptions_1.BaseException('pending async requests below zero');
	        }
	        this._runCallbacksIfReady();
	        return this._pendingCount;
	    };
	    Testability.prototype.isStable = function () {
	        return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;
	    };
	    /** @internal */
	    Testability.prototype._runCallbacksIfReady = function () {
	        var _this = this;
	        if (this.isStable()) {
	            // Schedules the call backs in a new frame so that it is always async.
	            lang_1.scheduleMicroTask(function () {
	                while (_this._callbacks.length !== 0) {
	                    (_this._callbacks.pop())(_this._didWork);
	                }
	                _this._didWork = false;
	            });
	        }
	        else {
	            // Not Ready
	            this._didWork = true;
	        }
	    };
	    Testability.prototype.whenStable = function (callback) {
	        this._callbacks.push(callback);
	        this._runCallbacksIfReady();
	    };
	    Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };
	    Testability.prototype.findBindings = function (using, provider, exactMatch) {
	        // TODO(juliemr): implement.
	        return [];
	    };
	    Testability.prototype.findProviders = function (using, provider, exactMatch) {
	        // TODO(juliemr): implement.
	        return [];
	    };
	    /** @nocollapse */
	    Testability.decorators = [
	        { type: decorators_1.Injectable },
	    ];
	    /** @nocollapse */
	    Testability.ctorParameters = [
	        { type: ng_zone_1.NgZone, },
	    ];
	    return Testability;
	}());
	exports.Testability = Testability;
	var TestabilityRegistry = (function () {
	    function TestabilityRegistry() {
	        /** @internal */
	        this._applications = new collection_1.Map();
	        _testabilityGetter.addToWindow(this);
	    }
	    TestabilityRegistry.prototype.registerApplication = function (token, testability) {
	        this._applications.set(token, testability);
	    };
	    TestabilityRegistry.prototype.getTestability = function (elem) { return this._applications.get(elem); };
	    TestabilityRegistry.prototype.getAllTestabilities = function () { return collection_1.MapWrapper.values(this._applications); };
	    TestabilityRegistry.prototype.getAllRootElements = function () { return collection_1.MapWrapper.keys(this._applications); };
	    TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {
	        if (findInAncestors === void 0) { findInAncestors = true; }
	        return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
	    };
	    /** @nocollapse */
	    TestabilityRegistry.decorators = [
	        { type: decorators_1.Injectable },
	    ];
	    /** @nocollapse */
	    TestabilityRegistry.ctorParameters = [];
	    return TestabilityRegistry;
	}());
	exports.TestabilityRegistry = TestabilityRegistry;
	var _NoopGetTestability = (function () {
	    function _NoopGetTestability() {
	    }
	    _NoopGetTestability.prototype.addToWindow = function (registry) { };
	    _NoopGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
	        return null;
	    };
	    return _NoopGetTestability;
	}());
	/**
	 * Set the {@link GetTestability} implementation used by the Angular testing framework.
	 * @experimental
	 */
	function setTestabilityGetter(getter) {
	    _testabilityGetter = getter;
	}
	exports.setTestabilityGetter = setTestabilityGetter;
	var _testabilityGetter = new _NoopGetTestability();
	//# sourceMappingURL=testability.js.map

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var async_1 = __webpack_require__(93);
	var exceptions_1 = __webpack_require__(4);
	var ng_zone_impl_1 = __webpack_require__(167);
	var ng_zone_impl_2 = __webpack_require__(167);
	exports.NgZoneError = ng_zone_impl_2.NgZoneError;
	/**
	 * An injectable service for executing work inside or outside of the Angular zone.
	 *
	 * The most common use of this service is to optimize performance when starting a work consisting of
	 * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
	 * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks
	 * can reenter the Angular zone via {@link #run}.
	 *
	 * <!-- TODO: add/fix links to:
	 *   - docs explaining zones and the use of zones in Angular and change-detection
	 *   - link to runOutsideAngular/run (throughout this file!)
	 *   -->
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
	 * ```
	 * import {Component, View, NgZone} from '@angular/core';
	 * import {NgIf} from '@angular/common';
	 *
	 * @Component({
	 *   selector: 'ng-zone-demo'.
	 *   template: `
	 *     <h2>Demo: NgZone</h2>
	 *
	 *     <p>Progress: {{progress}}%</p>
	 *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
	 *
	 *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
	 *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
	 *   `,
	 *   directives: [NgIf]
	 * })
	 * export class NgZoneDemo {
	 *   progress: number = 0;
	 *   label: string;
	 *
	 *   constructor(private _ngZone: NgZone) {}
	 *
	 *   // Loop inside the Angular zone
	 *   // so the UI DOES refresh after each setTimeout cycle
	 *   processWithinAngularZone() {
	 *     this.label = 'inside';
	 *     this.progress = 0;
	 *     this._increaseProgress(() => console.log('Inside Done!'));
	 *   }
	 *
	 *   // Loop outside of the Angular zone
	 *   // so the UI DOES NOT refresh after each setTimeout cycle
	 *   processOutsideOfAngularZone() {
	 *     this.label = 'outside';
	 *     this.progress = 0;
	 *     this._ngZone.runOutsideAngular(() => {
	 *       this._increaseProgress(() => {
	 *       // reenter the Angular zone and display done
	 *       this._ngZone.run(() => {console.log('Outside Done!') });
	 *     }}));
	 *   }
	 *
	 *
	 *   _increaseProgress(doneCallback: () => void) {
	 *     this.progress += 1;
	 *     console.log(`Current progress: ${this.progress}%`);
	 *
	 *     if (this.progress < 100) {
	 *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
	 *     } else {
	 *       doneCallback();
	 *     }
	 *   }
	 * }
	 * ```
	 * @experimental
	 */
	var NgZone = (function () {
	    function NgZone(_a) {
	        var _this = this;
	        var _b = _a.enableLongStackTrace, enableLongStackTrace = _b === void 0 ? false : _b;
	        this._hasPendingMicrotasks = false;
	        this._hasPendingMacrotasks = false;
	        /** @internal */
	        this._isStable = true;
	        /** @internal */
	        this._nesting = 0;
	        /** @internal */
	        this._onUnstable = new async_1.EventEmitter(false);
	        /** @internal */
	        this._onMicrotaskEmpty = new async_1.EventEmitter(false);
	        /** @internal */
	        this._onStable = new async_1.EventEmitter(false);
	        /** @internal */
	        this._onErrorEvents = new async_1.EventEmitter(false);
	        this._zoneImpl = new ng_zone_impl_1.NgZoneImpl({
	            trace: enableLongStackTrace,
	            onEnter: function () {
	                // console.log('ZONE.enter', this._nesting, this._isStable);
	                _this._nesting++;
	                if (_this._isStable) {
	                    _this._isStable = false;
	                    _this._onUnstable.emit(null);
	                }
	            },
	            onLeave: function () {
	                _this._nesting--;
	                // console.log('ZONE.leave', this._nesting, this._isStable);
	                _this._checkStable();
	            },
	            setMicrotask: function (hasMicrotasks) {
	                _this._hasPendingMicrotasks = hasMicrotasks;
	                _this._checkStable();
	            },
	            setMacrotask: function (hasMacrotasks) { _this._hasPendingMacrotasks = hasMacrotasks; },
	            onError: function (error) { return _this._onErrorEvents.emit(error); }
	        });
	    }
	    NgZone.isInAngularZone = function () { return ng_zone_impl_1.NgZoneImpl.isInAngularZone(); };
	    NgZone.assertInAngularZone = function () {
	        if (!ng_zone_impl_1.NgZoneImpl.isInAngularZone()) {
	            throw new exceptions_1.BaseException('Expected to be in Angular Zone, but it is not!');
	        }
	    };
	    NgZone.assertNotInAngularZone = function () {
	        if (ng_zone_impl_1.NgZoneImpl.isInAngularZone()) {
	            throw new exceptions_1.BaseException('Expected to not be in Angular Zone, but it is!');
	        }
	    };
	    NgZone.prototype._checkStable = function () {
	        var _this = this;
	        if (this._nesting == 0) {
	            if (!this._hasPendingMicrotasks && !this._isStable) {
	                try {
	                    // console.log('ZONE.microtaskEmpty');
	                    this._nesting++;
	                    this._onMicrotaskEmpty.emit(null);
	                }
	                finally {
	                    this._nesting--;
	                    if (!this._hasPendingMicrotasks) {
	                        try {
	                            // console.log('ZONE.stable', this._nesting, this._isStable);
	                            this.runOutsideAngular(function () { return _this._onStable.emit(null); });
	                        }
	                        finally {
	                            this._isStable = true;
	                        }
	                    }
	                }
	            }
	        }
	    };
	    ;
	    Object.defineProperty(NgZone.prototype, "onUnstable", {
	        /**
	         * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
	         */
	        get: function () { return this._onUnstable; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "onMicrotaskEmpty", {
	        /**
	         * Notifies when there is no more microtasks enqueue in the current VM Turn.
	         * This is a hint for Angular to do change detection, which may enqueue more microtasks.
	         * For this reason this event can fire multiple times per VM Turn.
	         */
	        get: function () { return this._onMicrotaskEmpty; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "onStable", {
	        /**
	         * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
	         * implies we are about to relinquish VM turn.
	         * This event gets called just once.
	         */
	        get: function () { return this._onStable; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "onError", {
	        /**
	         * Notify that an error has been delivered.
	         */
	        get: function () { return this._onErrorEvents; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "isStable", {
	        /**
	         * Whether there are no outstanding microtasks or microtasks.
	         */
	        get: function () { return this._isStable; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "hasPendingMicrotasks", {
	        /**
	         * Whether there are any outstanding microtasks.
	         */
	        get: function () { return this._hasPendingMicrotasks; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "hasPendingMacrotasks", {
	        /**
	         * Whether there are any outstanding microtasks.
	         */
	        get: function () { return this._hasPendingMacrotasks; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Executes the `fn` function synchronously within the Angular zone and returns value returned by
	     * the function.
	     *
	     * Running functions via `run` allows you to reenter Angular zone from a task that was executed
	     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
	     *
	     * Any future tasks or microtasks scheduled from within this function will continue executing from
	     * within the Angular zone.
	     *
	     * If a synchronous error happens it will be rethrown and not reported via `onError`.
	     */
	    NgZone.prototype.run = function (fn) { return this._zoneImpl.runInner(fn); };
	    /**
	     * Same as #run, except that synchronous errors are caught and forwarded
	     * via `onError` and not rethrown.
	     */
	    NgZone.prototype.runGuarded = function (fn) { return this._zoneImpl.runInnerGuarded(fn); };
	    /**
	     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
	     * the function.
	     *
	     * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that
	     * doesn't trigger Angular change-detection or is subject to Angular's error handling.
	     *
	     * Any future tasks or microtasks scheduled from within this function will continue executing from
	     * outside of the Angular zone.
	     *
	     * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
	     */
	    NgZone.prototype.runOutsideAngular = function (fn) { return this._zoneImpl.runOuter(fn); };
	    return NgZone;
	}());
	exports.NgZone = NgZone;
	//# sourceMappingURL=ng_zone.js.map

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var BrowserXhr = (function () {
	    function BrowserXhr() {
	    }
	    BrowserXhr.prototype.build = function () { return (new XMLHttpRequest()); };
	    /** @nocollapse */
	    BrowserXhr.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    BrowserXhr.ctorParameters = [];
	    return BrowserXhr;
	}());
	exports.BrowserXhr = BrowserXhr;
	//# sourceMappingURL=browser_xhr.js.map

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(11);
	var enums_1 = __webpack_require__(18);
	var headers_1 = __webpack_require__(32);
	var http_utils_1 = __webpack_require__(61);
	var url_search_params_1 = __webpack_require__(62);
	/**
	 * Creates a request options object to be optionally provided when instantiating a
	 * {@link Request}.
	 *
	 * This class is based on the `RequestInit` description in the [Fetch
	 * Spec](https://fetch.spec.whatwg.org/#requestinit).
	 *
	 * All values are null by default. Typical defaults can be found in the {@link BaseRequestOptions}
	 * class, which sub-classes `RequestOptions`.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/7Wvi3lfLq41aQPKlxB4O?p=preview))
	 *
	 * ```typescript
	 * import {RequestOptions, Request, RequestMethod} from '@angular/http';
	 *
	 * var options = new RequestOptions({
	 *   method: RequestMethod.Post,
	 *   url: 'https://google.com'
	 * });
	 * var req = new Request(options);
	 * console.log('req.method:', RequestMethod[req.method]); // Post
	 * console.log('options.url:', options.url); // https://google.com
	 * ```
	 *
	 * @experimental
	 */
	var RequestOptions = (function () {
	    function RequestOptions(_a) {
	        var _b = _a === void 0 ? {} : _a, method = _b.method, headers = _b.headers, body = _b.body, url = _b.url, search = _b.search, withCredentials = _b.withCredentials, responseType = _b.responseType;
	        this.method = lang_1.isPresent(method) ? http_utils_1.normalizeMethodName(method) : null;
	        this.headers = lang_1.isPresent(headers) ? headers : null;
	        this.body = lang_1.isPresent(body) ? body : null;
	        this.url = lang_1.isPresent(url) ? url : null;
	        this.search = lang_1.isPresent(search) ?
	            (lang_1.isString(search) ? new url_search_params_1.URLSearchParams((search)) : (search)) :
	            null;
	        this.withCredentials = lang_1.isPresent(withCredentials) ? withCredentials : null;
	        this.responseType = lang_1.isPresent(responseType) ? responseType : null;
	    }
	    /**
	     * Creates a copy of the `RequestOptions` instance, using the optional input as values to override
	     * existing values. This method will not change the values of the instance on which it is being
	     * called.
	     *
	     * Note that `headers` and `search` will override existing values completely if present in
	     * the `options` object. If these values should be merged, it should be done prior to calling
	     * `merge` on the `RequestOptions` instance.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/6w8XA8YTkDRcPYpdB9dk?p=preview))
	     *
	     * ```typescript
	     * import {RequestOptions, Request, RequestMethod} from '@angular/http';
	     *
	     * var options = new RequestOptions({
	     *   method: RequestMethod.Post
	     * });
	     * var req = new Request(options.merge({
	     *   url: 'https://google.com'
	     * }));
	     * console.log('req.method:', RequestMethod[req.method]); // Post
	     * console.log('options.url:', options.url); // null
	     * console.log('req.url:', req.url); // https://google.com
	     * ```
	     */
	    RequestOptions.prototype.merge = function (options) {
	        return new RequestOptions({
	            method: lang_1.isPresent(options) && lang_1.isPresent(options.method) ? options.method : this.method,
	            headers: lang_1.isPresent(options) && lang_1.isPresent(options.headers) ? options.headers : this.headers,
	            body: lang_1.isPresent(options) && lang_1.isPresent(options.body) ? options.body : this.body,
	            url: lang_1.isPresent(options) && lang_1.isPresent(options.url) ? options.url : this.url,
	            search: lang_1.isPresent(options) && lang_1.isPresent(options.search) ?
	                (lang_1.isString(options.search) ? new url_search_params_1.URLSearchParams((options.search)) :
	                    (options.search).clone()) :
	                this.search,
	            withCredentials: lang_1.isPresent(options) && lang_1.isPresent(options.withCredentials) ?
	                options.withCredentials :
	                this.withCredentials,
	            responseType: lang_1.isPresent(options) && lang_1.isPresent(options.responseType) ? options.responseType :
	                this.responseType
	        });
	    };
	    return RequestOptions;
	}());
	exports.RequestOptions = RequestOptions;
	var BaseRequestOptions = (function (_super) {
	    __extends(BaseRequestOptions, _super);
	    function BaseRequestOptions() {
	        _super.call(this, { method: enums_1.RequestMethod.Get, headers: new headers_1.Headers() });
	    }
	    /** @nocollapse */
	    BaseRequestOptions.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    BaseRequestOptions.ctorParameters = [];
	    return BaseRequestOptions;
	}(RequestOptions));
	exports.BaseRequestOptions = BaseRequestOptions;
	//# sourceMappingURL=base_request_options.js.map

/***/ },
/* 104 */
[293, 11],
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var body_1 = __webpack_require__(171);
	/**
	 * Creates `Response` instances from provided values.
	 *
	 * Though this object isn't
	 * usually instantiated by end-users, it is the primary object interacted with when it comes time to
	 * add data to a view.
	 *
	 * ### Example
	 *
	 * ```
	 * http.request('my-friends.txt').subscribe(response => this.friends = response.text());
	 * ```
	 *
	 * The Response's interface is inspired by the Response constructor defined in the [Fetch
	 * Spec](https://fetch.spec.whatwg.org/#response-class), but is considered a static value whose body
	 * can be accessed many times. There are other differences in the implementation, but this is the
	 * most significant.
	 *
	 * @experimental
	 */
	var Response = (function (_super) {
	    __extends(Response, _super);
	    function Response(responseOptions) {
	        _super.call(this);
	        this._body = responseOptions.body;
	        this.status = responseOptions.status;
	        this.ok = (this.status >= 200 && this.status <= 299);
	        this.statusText = responseOptions.statusText;
	        this.headers = responseOptions.headers;
	        this.type = responseOptions.type;
	        this.url = responseOptions.url;
	    }
	    Response.prototype.toString = function () {
	        return "Response with status: " + this.status + " " + this.statusText + " for URL: " + this.url;
	    };
	    return Response;
	}(body_1.Body));
	exports.Response = Response;
	//# sourceMappingURL=static_response.js.map

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var dom_adapter_1 = __webpack_require__(7);
	var event_manager_1 = __webpack_require__(23);
	var DomEventsPlugin = (function (_super) {
	    __extends(DomEventsPlugin, _super);
	    function DomEventsPlugin() {
	        _super.apply(this, arguments);
	    }
	    // This plugin should come last in the list of plugins, because it accepts all
	    // events.
	    DomEventsPlugin.prototype.supports = function (eventName) { return true; };
	    DomEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
	        var zone = this.manager.getZone();
	        var outsideHandler = function (event /** TODO #9100 */) { return zone.runGuarded(function () { return handler(event); }); };
	        return this.manager.getZone().runOutsideAngular(function () { return dom_adapter_1.getDOM().onAndCancel(element, eventName, outsideHandler); });
	    };
	    DomEventsPlugin.prototype.addGlobalEventListener = function (target, eventName, handler) {
	        var element = dom_adapter_1.getDOM().getGlobalEventTarget(target);
	        var zone = this.manager.getZone();
	        var outsideHandler = function (event /** TODO #9100 */) { return zone.runGuarded(function () { return handler(event); }); };
	        return this.manager.getZone().runOutsideAngular(function () { return dom_adapter_1.getDOM().onAndCancel(element, eventName, outsideHandler); });
	    };
	    /** @nocollapse */
	    DomEventsPlugin.decorators = [
	        { type: core_1.Injectable },
	    ];
	    return DomEventsPlugin;
	}(event_manager_1.EventManagerPlugin));
	exports.DomEventsPlugin = DomEventsPlugin;
	//# sourceMappingURL=dom_events.js.map

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var exceptions_1 = __webpack_require__(19);
	var lang_1 = __webpack_require__(5);
	var hammer_common_1 = __webpack_require__(240);
	/**
	 * A DI token that you can use to provide{@link HammerGestureConfig} to Angular. Use it to configure
	 * Hammer gestures.
	 *
	 * @experimental
	 */
	exports.HAMMER_GESTURE_CONFIG = new core_1.OpaqueToken('HammerGestureConfig');
	var HammerGestureConfig = (function () {
	    function HammerGestureConfig() {
	        this.events = [];
	        this.overrides = {};
	    }
	    HammerGestureConfig.prototype.buildHammer = function (element) {
	        var mc = new Hammer(element);
	        mc.get('pinch').set({ enable: true });
	        mc.get('rotate').set({ enable: true });
	        for (var eventName in this.overrides) {
	            mc.get(eventName).set(this.overrides[eventName]);
	        }
	        return mc;
	    };
	    /** @nocollapse */
	    HammerGestureConfig.decorators = [
	        { type: core_1.Injectable },
	    ];
	    return HammerGestureConfig;
	}());
	exports.HammerGestureConfig = HammerGestureConfig;
	var HammerGesturesPlugin = (function (_super) {
	    __extends(HammerGesturesPlugin, _super);
	    function HammerGesturesPlugin(_config) {
	        _super.call(this);
	        this._config = _config;
	    }
	    HammerGesturesPlugin.prototype.supports = function (eventName) {
	        if (!_super.prototype.supports.call(this, eventName) && !this.isCustomEvent(eventName))
	            return false;
	        if (!lang_1.isPresent(window['Hammer'])) {
	            throw new exceptions_1.BaseException("Hammer.js is not loaded, can not bind " + eventName + " event");
	        }
	        return true;
	    };
	    HammerGesturesPlugin.prototype.addEventListener = function (element, eventName, handler) {
	        var _this = this;
	        var zone = this.manager.getZone();
	        eventName = eventName.toLowerCase();
	        return zone.runOutsideAngular(function () {
	            // Creating the manager bind events, must be done outside of angular
	            var mc = _this._config.buildHammer(element);
	            var callback = function (eventObj /** TODO #???? */) {
	                zone.runGuarded(function () { handler(eventObj); });
	            };
	            mc.on(eventName, callback);
	            return function () { mc.off(eventName, callback); };
	        });
	    };
	    HammerGesturesPlugin.prototype.isCustomEvent = function (eventName) { return this._config.events.indexOf(eventName) > -1; };
	    /** @nocollapse */
	    HammerGesturesPlugin.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    HammerGesturesPlugin.ctorParameters = [
	        { type: HammerGestureConfig, decorators: [{ type: core_1.Inject, args: [exports.HAMMER_GESTURE_CONFIG,] },] },
	    ];
	    return HammerGesturesPlugin;
	}(hammer_common_1.HammerGesturesPluginCommon));
	exports.HammerGesturesPlugin = HammerGesturesPlugin;
	//# sourceMappingURL=hammer_gestures.js.map

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var dom_adapter_1 = __webpack_require__(7);
	/**
	 * A pattern that recognizes a commonly useful subset of URLs that are safe.
	 *
	 * This regular expression matches a subset of URLs that will not cause script
	 * execution if used in URL context within a HTML document. Specifically, this
	 * regular expression matches if (comment from here on and regex copied from
	 * Soy's EscapingConventions):
	 * (1) Either a protocol in a whitelist (http, https, mailto or ftp).
	 * (2) or no protocol.  A protocol must be followed by a colon. The below
	 *     allows that by allowing colons only after one of the characters [/?#].
	 *     A colon after a hash (#) must be in the fragment.
	 *     Otherwise, a colon after a (?) must be in a query.
	 *     Otherwise, a colon after a single solidus (/) must be in a path.
	 *     Otherwise, a colon after a double solidus (//) must be in the authority
	 *     (before port).
	 *
	 * The pattern disallows &, used in HTML entity declarations before
	 * one of the characters in [/?#]. This disallows HTML entities used in the
	 * protocol name, which should never happen, e.g. "h&#116;tp" for "http".
	 * It also disallows HTML entities in the first path part of a relative path,
	 * e.g. "foo&lt;bar/baz".  Our existing escaping functions should not produce
	 * that. More importantly, it disallows masking of a colon,
	 * e.g. "javascript&#58;...".
	 *
	 * This regular expression was taken from the Closure sanitization library.
	 */
	var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
	/* A pattern that matches safe srcset values */
	var SAFE_SRCSET_PATTERN = /^(?:(?:https?|file):|[^&:/?#]*(?:[/?#]|$))/gi;
	/** A pattern that matches safe data URLs. Only matches image, video and audio types. */
	var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
	function sanitizeUrl(url) {
	    url = String(url);
	    if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))
	        return url;
	    if (core_1.isDevMode()) {
	        dom_adapter_1.getDOM().log("WARNING: sanitizing unsafe URL value " + url + " (see http://g.co/ng/security#xss)");
	    }
	    return 'unsafe:' + url;
	}
	exports.sanitizeUrl = sanitizeUrl;
	function sanitizeSrcset(srcset) {
	    srcset = String(srcset);
	    return srcset.split(',').map(function (srcset) { return sanitizeUrl(srcset.trim()); }).join(', ');
	}
	exports.sanitizeSrcset = sanitizeSrcset;
	//# sourceMappingURL=url_sanitizer.js.map

/***/ },
/* 109 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	// This file contains interface versions of browser types that can be serialized to Plain Old
	// JavaScript Objects
	var LocationType = (function () {
	    function LocationType(href, protocol, host, hostname, port, pathname, search, hash, origin) {
	        this.href = href;
	        this.protocol = protocol;
	        this.host = host;
	        this.hostname = hostname;
	        this.port = port;
	        this.pathname = pathname;
	        this.search = search;
	        this.hash = hash;
	        this.origin = origin;
	    }
	    return LocationType;
	}());
	exports.LocationType = LocationType;
	//# sourceMappingURL=serialized_types.js.map

/***/ },
/* 110 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.HalField = HalField;
	exports.HalEmbedded = HalEmbedded;
	exports.HalLink = HalLink;
	exports.getCookedFieldDescription = getCookedFieldDescription;
	exports.getRawFieldDescription = getRawFieldDescription;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var HAL_COOKED_FIELD_METADATA_KEY = Symbol('halCookedFieldMetadataKey');
	var HAL_RAW_FIELD_METADATA_KEY = Symbol('halRawFieldMetadataKey');
	var HalFieldSection = exports.HalFieldSection = undefined;
	(function (HalFieldSection) {
	    HalFieldSection[HalFieldSection["EMBEDDED"] = 0] = "EMBEDDED";
	    HalFieldSection[HalFieldSection["LINKS"] = 1] = "LINKS";
	    HalFieldSection[HalFieldSection["RESOURCE"] = 2] = "RESOURCE";
	})(HalFieldSection || (exports.HalFieldSection = HalFieldSection = {}));

	var HalFieldDescription = exports.HalFieldDescription = function HalFieldDescription(key, arg) {
	    _classCallCheck(this, HalFieldDescription);

	    this.section = HalFieldSection.RESOURCE;
	    this.rawName = key;
	    this.cookedName = key;
	    if (arg instanceof String) {
	        this.rawName = arg;
	        this.typeDescription = new HalFieldTypeDescription({});
	    } else if (arg instanceof Function) {
	        this.typeDescription = new HalFieldTypeDescription(arg);
	    } else {
	        var metadata = arg || {};
	        if (metadata.name !== undefined) {
	            this.rawName = metadata.name;
	        }
	        if (metadata.section !== undefined) {
	            this.section = metadata.section;
	        }
	        this.typeDescription = new HalFieldTypeDescription(metadata);
	    }
	};

	var HalFieldTypeDescription = exports.HalFieldTypeDescription = function () {
	    function HalFieldTypeDescription(arg) {
	        _classCallCheck(this, HalFieldTypeDescription);

	        if (arg instanceof Function) {
	            this.type = arg;
	        } else {
	            var metadata = arg || {};
	            this.type = metadata.type;
	            this.collection = metadata.collection;
	        }
	    }

	    _createClass(HalFieldTypeDescription, [{
	        key: 'getElementTypeDescription',
	        value: function getElementTypeDescription() {
	            if (!this.collection) {
	                throw new TypeError('This HalFieldTypeDescription does not describe a collection.');
	            }
	            return new HalFieldTypeDescription({
	                type: this.type
	            });
	        }
	    }]);

	    return HalFieldTypeDescription;
	}();

	function HalField(arg) {
	    return function (target, key) {
	        if (typeof key === 'string') {
	            var description = new HalFieldDescription(key, arg);
	            defineDescriptionMetadata(description, target);
	        } else {
	            throw new TypeError('The @HalField decorator can only be applied to a field whose name is a String');
	        }
	    };
	}
	function HalEmbedded(arg) {
	    return function (target, key) {
	        if (typeof key === 'string') {
	            var description = new HalFieldDescription(key, arg);
	            description.section = HalFieldSection.EMBEDDED;
	            defineDescriptionMetadata(description, target);
	        } else {
	            throw new TypeError('The @HalEmbedded decorator can only be applied to a field whose name is a String');
	        }
	    };
	}
	function HalLink(arg) {
	    return function (target, key) {
	        if (typeof key === 'string') {
	            var description = new HalFieldDescription(key, arg);
	            description.section = HalFieldSection.LINKS;
	            defineDescriptionMetadata(description, target);
	        } else {
	            throw new TypeError('The @HalLink decorator can only be applied to a field whose name is a String');
	        }
	    };
	}
	function defineDescriptionMetadata(description, target) {
	    Reflect.defineMetadata(HAL_COOKED_FIELD_METADATA_KEY, description, target.constructor, description.cookedName);
	    Reflect.defineMetadata(HAL_RAW_FIELD_METADATA_KEY, description, target.constructor, description.rawName);
	}
	function getCookedFieldDescription(target, key) {
	    return Reflect.getMetadata(HAL_COOKED_FIELD_METADATA_KEY, target, key) || new HalFieldDescription(key, undefined);
	}
	function getRawFieldDescription(target, key) {
	    return Reflect.getMetadata(HAL_RAW_FIELD_METADATA_KEY, target, key) || new HalFieldDescription(key, undefined);
	}

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.HalHttp = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _core = __webpack_require__(1);

	var _http = __webpack_require__(231);

	var _error = __webpack_require__(188);

	var _object = __webpack_require__(39);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = undefined && undefined.__metadata || function (k, v) {
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};

	/**
	 *
	 */
	var HalHttp = exports.HalHttp = function () {
	    function HalHttp(objectSerializer, http) {
	        _classCallCheck(this, HalHttp);

	        this.objectSerializer = objectSerializer;
	        this.http = http;
	    }

	    _createClass(HalHttp, [{
	        key: "get",
	        value: function get(url) {
	            var _this = this;

	            return this.http.get(url).map(handleErrorResponse).map(function (response) {
	                if (response.status === 204) {
	                    return undefined;
	                }
	                return _this.objectSerializer.deserialize(response.text());
	            });
	        }
	    }, {
	        key: "delete",
	        value: function _delete(url) {
	            return undefined;
	        }
	    }, {
	        key: "post",
	        value: function post(url, body) {
	            return undefined;
	        }
	    }, {
	        key: "put",
	        value: function put(url, body) {
	            return undefined;
	        }
	    }]);

	    return HalHttp;
	}();
	exports.HalHttp = HalHttp = __decorate([(0, _core.Injectable)(), __metadata('design:paramtypes', [_object.HalObjectSerializer, _http.Http])], HalHttp);
	function handleErrorResponse(response) {
	    var status = response.status;
	    /* This is probably a little over-zealous, but it corresponds to !response.ok (which doesn't work with the current
	      * Angular 2 beta. */
	    if (status < 200 || status >= 300) {
	        throw new _error.HalError(status, response.text());
	    }
	    return response;
	}
	function mapUpdate(response) {
	    if (response.headers.has('Location')) {
	        return new _object.HalLinkObject(response.headers.get('Location'), false);
	    }
	    return undefined;
	}

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.HalInstanceFactory = undefined;

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _core = __webpack_require__(1);

	var _field = __webpack_require__(110);

	var _object = __webpack_require__(39);

	var _translator = __webpack_require__(190);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = undefined && undefined.__metadata || function (k, v) {
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	        decorator(target, key, paramIndex);
	    };
	};
	var HalInstanceFactory = exports.HalInstanceFactory = function () {
	    function HalInstanceFactory(collectionTranslators, objectTranslators) {
	        _classCallCheck(this, HalInstanceFactory);

	        this.collectionTranslators = collectionTranslators;
	        this.objectTranslators = objectTranslators;
	    }

	    _createClass(HalInstanceFactory, [{
	        key: "createInstance",
	        value: function createInstance(value, typeDescription, resourceFactory) {
	            var _this = this;

	            /* If the field is a collection... */
	            if (typeDescription.collection) {
	                /* The value must be an array. */
	                if (!Array.isArray(value)) {
	                    throw new TypeError('Expected an array, but did not get one.');
	                } else {
	                    var _ret = function () {
	                        /* Create instance of all the elements. */
	                        var elementTypeDescription = typeDescription.getElementTypeDescription();
	                        var instanceArray = value.map(function (element) {
	                            return _this.createInstance(element, elementTypeDescription, resourceFactory);
	                        });
	                        /* Then translate the array into a collection instance. */
	                        return {
	                            v: findApplicableCollectionTranslator(_this.collectionTranslators, typeDescription.collection).fromArray(instanceArray, typeDescription.collection)
	                        };
	                    }();

	                    if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
	                }
	            } else if (Array.isArray(typeDescription.type)) {
	                /* The value must be an array. */
	                if (!Array.isArray(value)) {
	                    throw new TypeError('Expected an array, but did not get one.');
	                } else {
	                    /* Create instances for each value using the corresponding tuple type to build a type descriptor. */
	                    return Array.from(wu.zipWith(function (element, elementType) {
	                        return _this.createInstance(element, new _field.HalFieldTypeDescription(elementType), resourceFactory);
	                    }, value, typeDescription.type));
	                }
	            } else if (value instanceof _object.HalObject) {
	                /* Get the instance's type from the type description if present, otherwise use the type of the HAL object's
	                 * resource. We already handled tuple types, so it must be a constructor. */
	                var type = typeDescription.type || value.resource.constructor;
	                /* This is where we'll build the object we send to the translator. */
	                var rawInstance = {};
	                /* Copy fields from the links and embedded sections, then all other fields. The order matters -- fields in later
	                 * sections will overwrite earlier sections. */
	                this.fillInstance(rawInstance, value.links, type, _field.HalFieldSection.LINKS, resourceFactory);
	                this.fillInstance(rawInstance, value.embedded, type, _field.HalFieldSection.EMBEDDED, resourceFactory);
	                this.fillInstance(rawInstance, value.resource, type, _field.HalFieldSection.RESOURCE, resourceFactory);
	                /* Translate the raw instance into a cooked instance. */
	                return findApplicableObjectTranslator(this.objectTranslators, type).fromObject(rawInstance, type);
	            } else if (value instanceof _object.HalLinkObject) {
	                return resourceFactory.createResource(value, typeDescription);
	            } else if ((typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object') {
	                /* Get the instance's type from the type description if present, otherwise use the type of the HAL object's
	                 * resource. We already handled tuple types, so it must be a constructor. */
	                var _type = typeDescription.type || value.constructor;
	                /* This is where we'll build the object we send to the translator. */
	                var _rawInstance = {};
	                /* Copy fields from the value. We treat all the fields as if they were in the resource section. */
	                this.fillInstance(_rawInstance, value, _type, _field.HalFieldSection.RESOURCE, resourceFactory);
	                /* Translate the raw instance into a cooked instance. */
	                return findApplicableObjectTranslator(this.objectTranslators, _type).fromObject(_rawInstance, _type);
	            } else {
	                /* Just return it. */
	                return value;
	            }
	        }
	    }, {
	        key: "fillInstance",
	        value: function fillInstance(target, source, type, section, resourceFactory) {
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;

	            try {
	                for (var _iterator = Object.entries(source)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var _step$value = _slicedToArray(_step.value, 2);

	                    var key = _step$value[0];
	                    var value = _step$value[1];

	                    /* Look up a field description using the raw name. */
	                    var fieldDescription = (0, _field.getRawFieldDescription)(type, key);
	                    /* If the field belongs in this section... */
	                    if (fieldDescription.section === section) {
	                        /* Create an instance from the value, then assign it using the cooked name. */
	                        /* TODO: Should we throw an exception if a field is reassigned? */
	                        target[fieldDescription.cookedName] = this.createInstance(value, fieldDescription.typeDescription, resourceFactory);
	                    }
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	        }
	    }]);

	    return HalInstanceFactory;
	}();
	exports.HalInstanceFactory = HalInstanceFactory = __decorate([(0, _core.Injectable)(), __param(0, (0, _core.Inject)(_translator.HAL_COLLECTION_TRANSLATORS)), __param(1, (0, _core.Inject)(_translator.HAL_OBJECT_TRANSLATORS)), __metadata('design:paramtypes', [Array, Array])], HalInstanceFactory);
	function findApplicableCollectionTranslator(translators, type) {
	    try {
	        return findApplicableTranslator(translators, type);
	    } catch (ex) {
	        throw Object.create(ex, {
	            message: "Error finding an applicable collection translator: " + ex.message
	        });
	    }
	}
	function findApplicableObjectTranslator(translators, type) {
	    try {
	        return findApplicableTranslator(translators, type);
	    } catch (ex) {
	        throw Object.create(ex, {
	            message: "Error finding an applicable object translator: " + ex.message
	        });
	    }
	}
	function findApplicableTranslator(translators, ctor) {
	    var currentPrototype = ctor ? ctor.prototype : undefined;
	    var currentCtor = ctor;
	    while (true) {
	        var applicable = translators.filter(function (translator) {
	            return translator.appliesTo(currentCtor);
	        });
	        /* If we find multiple translators applicable to the same type, we have no way to choose among them. So we just
	         * throw an exception. */
	        if (applicable.length > 1) {
	            throw new TypeError("Multiple translators found for type " + currentCtor + " while finding translators for type " + ctor + ".");
	        }
	        /* If we find exactly one translator, we can return it. */
	        if (applicable.length === 1) {
	            return applicable[0];
	        }
	        /* Once we're reached the bottom of the prototype chain, we need to stop looking. */
	        if (!currentCtor) {
	            break;
	        }
	        /* Otherwise we should try using our prototype's constructor (if we have a prototype), or else undefined. */
	        if (currentPrototype) {
	            currentCtor = currentPrototype.constructor;
	            currentPrototype = Object.getPrototypeOf(currentPrototype);
	        } else {
	            currentCtor = undefined;
	        }
	    }
	    /* If we get out of the loop, we walked all the way down the prototype chain and didn't find any applicable
	     * translators. Give up and throw an exception. */
	    throw new TypeError("No translators found for type " + ctor + ".");
	}

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(286);
	var isObject_1 = __webpack_require__(287);
	var isFunction_1 = __webpack_require__(196);
	var tryCatch_1 = __webpack_require__(290);
	var errorObject_1 = __webpack_require__(195);
	var UnsubscriptionError_1 = __webpack_require__(285);
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.isUnsubscribed = false;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isUnsubscribed = true;
	        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this._subscriptions = null;
	        if (isFunction_1.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                (errors = errors || []).push(errorObject_1.errorObject.e);
	            }
	        }
	        if (isArray_1.isArray(_subscriptions)) {
	            var index = -1;
	            var len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                            errors = errors.concat(err.errors);
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `isUnsubscribed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {
	            return;
	        }
	        var sub = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                sub = new Subscription(teardown);
	            case 'object':
	                if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {
	                    break;
	                }
	                else if (this.isUnsubscribed) {
	                    sub.unsubscribe();
	                }
	                else {
	                    (this._subscriptions || (this._subscriptions = [])).push(sub);
	                }
	                break;
	            default:
	                throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        return sub;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        // HACK: This might be redundant because of the logic in `add()`
	        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
	            return;
	        }
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.isUnsubscribed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	exports.Subscription = Subscription;
	//# sourceMappingURL=Subscription.js.map

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(40);
	var Symbol = root_1.root.Symbol;
	exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	//# sourceMappingURL=rxSubscriber.js.map

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var directives_1 = __webpack_require__(116);
	/**
	 * A collection of Angular core directives that are likely to be used in each and every Angular
	 * application. This includes core directives (e.g., NgIf and NgFor), and forms directives (e.g.,
	 * NgModel).
	 *
	 * This collection can be used to quickly enumerate all the built-in directives in the `directives`
	 * property of the `@Component` decorator.
	 *
	 * ### Example
	 *
	 * Instead of writing:
	 *
	 * ```typescript
	 * import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, NgModel, NgForm} from
	 * '@angular/common';
	 * import {OtherDirective} from './myDirectives';
	 *
	 * @Component({
	 *   selector: 'my-component',
	 *   templateUrl: 'myComponent.html',
	 *   directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, NgModel, NgForm,
	 * OtherDirective]
	 * })
	 * export class MyComponent {
	 *   ...
	 * }
	 * ```
	 * one could import all the common directives at once:
	 *
	 * ```typescript
	 * import {COMMON_DIRECTIVES} from '@angular/common';
	 * import {OtherDirective} from './myDirectives';
	 *
	 * @Component({
	 *   selector: 'my-component',
	 *   templateUrl: 'myComponent.html',
	 *   directives: [COMMON_DIRECTIVES, OtherDirective]
	 * })
	 * export class MyComponent {
	 *   ...
	 * }
	 * ```
	 *
	 * @experimental Contains forms which are experimental.
	 */
	exports.COMMON_DIRECTIVES = [directives_1.CORE_DIRECTIVES];
	//# sourceMappingURL=common_directives.js.map

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * @module
	 * @description
	 * Common directives shipped with Angular.
	 */
	var core_directives_1 = __webpack_require__(197);
	exports.CORE_DIRECTIVES = core_directives_1.CORE_DIRECTIVES;
	var ng_class_1 = __webpack_require__(117);
	exports.NgClass = ng_class_1.NgClass;
	var ng_for_1 = __webpack_require__(118);
	exports.NgFor = ng_for_1.NgFor;
	var ng_if_1 = __webpack_require__(119);
	exports.NgIf = ng_if_1.NgIf;
	var ng_plural_1 = __webpack_require__(120);
	exports.NgPlural = ng_plural_1.NgPlural;
	exports.NgPluralCase = ng_plural_1.NgPluralCase;
	var ng_style_1 = __webpack_require__(121);
	exports.NgStyle = ng_style_1.NgStyle;
	var ng_switch_1 = __webpack_require__(70);
	exports.NgSwitch = ng_switch_1.NgSwitch;
	exports.NgSwitchCase = ng_switch_1.NgSwitchCase;
	exports.NgSwitchDefault = ng_switch_1.NgSwitchDefault;
	var ng_template_outlet_1 = __webpack_require__(122);
	exports.NgTemplateOutlet = ng_template_outlet_1.NgTemplateOutlet;
	//# sourceMappingURL=directives.js.map

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(10);
	var lang_1 = __webpack_require__(3);
	var NgClass = (function () {
	    function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
	        this._iterableDiffers = _iterableDiffers;
	        this._keyValueDiffers = _keyValueDiffers;
	        this._ngEl = _ngEl;
	        this._renderer = _renderer;
	        this._initialClasses = [];
	    }
	    Object.defineProperty(NgClass.prototype, "initialClasses", {
	        set: function (v) {
	            this._applyInitialClasses(true);
	            this._initialClasses = lang_1.isPresent(v) && lang_1.isString(v) ? v.split(' ') : [];
	            this._applyInitialClasses(false);
	            this._applyClasses(this._rawClass, false);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgClass.prototype, "ngClass", {
	        set: function (v) {
	            this._cleanupClasses(this._rawClass);
	            if (lang_1.isString(v)) {
	                v = v.split(' ');
	            }
	            this._rawClass = v;
	            this._iterableDiffer = null;
	            this._keyValueDiffer = null;
	            if (lang_1.isPresent(v)) {
	                if (collection_1.isListLikeIterable(v)) {
	                    this._iterableDiffer = this._iterableDiffers.find(v).create(null);
	                }
	                else {
	                    this._keyValueDiffer = this._keyValueDiffers.find(v).create(null);
	                }
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    NgClass.prototype.ngDoCheck = function () {
	        if (lang_1.isPresent(this._iterableDiffer)) {
	            var changes = this._iterableDiffer.diff(this._rawClass);
	            if (lang_1.isPresent(changes)) {
	                this._applyIterableChanges(changes);
	            }
	        }
	        if (lang_1.isPresent(this._keyValueDiffer)) {
	            var changes = this._keyValueDiffer.diff(this._rawClass);
	            if (lang_1.isPresent(changes)) {
	                this._applyKeyValueChanges(changes);
	            }
	        }
	    };
	    NgClass.prototype._cleanupClasses = function (rawClassVal) {
	        this._applyClasses(rawClassVal, true);
	        this._applyInitialClasses(false);
	    };
	    NgClass.prototype._applyKeyValueChanges = function (changes) {
	        var _this = this;
	        changes.forEachAddedItem(function (record) { _this._toggleClass(record.key, record.currentValue); });
	        changes.forEachChangedItem(function (record) { _this._toggleClass(record.key, record.currentValue); });
	        changes.forEachRemovedItem(function (record) {
	            if (record.previousValue) {
	                _this._toggleClass(record.key, false);
	            }
	        });
	    };
	    NgClass.prototype._applyIterableChanges = function (changes) {
	        var _this = this;
	        changes.forEachAddedItem(function (record) { _this._toggleClass(record.item, true); });
	        changes.forEachRemovedItem(function (record) { _this._toggleClass(record.item, false); });
	    };
	    NgClass.prototype._applyInitialClasses = function (isCleanup) {
	        var _this = this;
	        this._initialClasses.forEach(function (className) { return _this._toggleClass(className, !isCleanup); });
	    };
	    NgClass.prototype._applyClasses = function (rawClassVal, isCleanup) {
	        var _this = this;
	        if (lang_1.isPresent(rawClassVal)) {
	            if (lang_1.isArray(rawClassVal)) {
	                rawClassVal.forEach(function (className) { return _this._toggleClass(className, !isCleanup); });
	            }
	            else if (rawClassVal instanceof Set) {
	                rawClassVal.forEach(function (className) { return _this._toggleClass(className, !isCleanup); });
	            }
	            else {
	                collection_1.StringMapWrapper.forEach(rawClassVal, function (expVal, className) {
	                    if (lang_1.isPresent(expVal))
	                        _this._toggleClass(className, !isCleanup);
	                });
	            }
	        }
	    };
	    NgClass.prototype._toggleClass = function (className, enabled) {
	        className = className.trim();
	        if (className.length > 0) {
	            if (className.indexOf(' ') > -1) {
	                var classes = className.split(/\s+/g);
	                for (var i = 0, len = classes.length; i < len; i++) {
	                    this._renderer.setElementClass(this._ngEl.nativeElement, classes[i], enabled);
	                }
	            }
	            else {
	                this._renderer.setElementClass(this._ngEl.nativeElement, className, enabled);
	            }
	        }
	    };
	    /** @nocollapse */
	    NgClass.decorators = [
	        { type: core_1.Directive, args: [{ selector: '[ngClass]' },] },
	    ];
	    /** @nocollapse */
	    NgClass.ctorParameters = [
	        { type: core_1.IterableDiffers, },
	        { type: core_1.KeyValueDiffers, },
	        { type: core_1.ElementRef, },
	        { type: core_1.Renderer, },
	    ];
	    /** @nocollapse */
	    NgClass.propDecorators = {
	        'initialClasses': [{ type: core_1.Input, args: ['class',] },],
	        'ngClass': [{ type: core_1.Input },],
	    };
	    return NgClass;
	}());
	exports.NgClass = NgClass;
	//# sourceMappingURL=ng_class.js.map

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var exceptions_1 = __webpack_require__(20);
	var lang_1 = __webpack_require__(3);
	var NgForRow = (function () {
	    function NgForRow($implicit, index, count) {
	        this.$implicit = $implicit;
	        this.index = index;
	        this.count = count;
	    }
	    Object.defineProperty(NgForRow.prototype, "first", {
	        get: function () { return this.index === 0; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgForRow.prototype, "last", {
	        get: function () { return this.index === this.count - 1; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgForRow.prototype, "even", {
	        get: function () { return this.index % 2 === 0; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgForRow.prototype, "odd", {
	        get: function () { return !this.even; },
	        enumerable: true,
	        configurable: true
	    });
	    return NgForRow;
	}());
	exports.NgForRow = NgForRow;
	var NgFor = (function () {
	    function NgFor(_viewContainer, _templateRef, _iterableDiffers, _cdr) {
	        this._viewContainer = _viewContainer;
	        this._templateRef = _templateRef;
	        this._iterableDiffers = _iterableDiffers;
	        this._cdr = _cdr;
	    }
	    Object.defineProperty(NgFor.prototype, "ngForTemplate", {
	        set: function (value) {
	            if (lang_1.isPresent(value)) {
	                this._templateRef = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    NgFor.prototype.ngOnChanges = function (changes) {
	        if ('ngForOf' in changes) {
	            // React on ngForOf changes only once all inputs have been initialized
	            var value = changes['ngForOf'].currentValue;
	            if (lang_1.isBlank(this._differ) && lang_1.isPresent(value)) {
	                try {
	                    this._differ = this._iterableDiffers.find(value).create(this._cdr, this.ngForTrackBy);
	                }
	                catch (e) {
	                    throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + value + "' of type '" + lang_1.getTypeNameForDebugging(value) + "'. NgFor only supports binding to Iterables such as Arrays.");
	                }
	            }
	        }
	    };
	    NgFor.prototype.ngDoCheck = function () {
	        if (lang_1.isPresent(this._differ)) {
	            var changes = this._differ.diff(this.ngForOf);
	            if (lang_1.isPresent(changes))
	                this._applyChanges(changes);
	        }
	    };
	    NgFor.prototype._applyChanges = function (changes) {
	        var _this = this;
	        var insertTuples = [];
	        changes.forEachOperation(function (item, adjustedPreviousIndex, currentIndex) {
	            if (item.previousIndex == null) {
	                var view = _this._viewContainer.createEmbeddedView(_this._templateRef, new NgForRow(null, null, null), currentIndex);
	                var tuple = new RecordViewTuple(item, view);
	                insertTuples.push(tuple);
	            }
	            else if (currentIndex == null) {
	                _this._viewContainer.remove(adjustedPreviousIndex);
	            }
	            else {
	                var view = _this._viewContainer.get(adjustedPreviousIndex);
	                _this._viewContainer.move(view, currentIndex);
	                var tuple = new RecordViewTuple(item, view);
	                insertTuples.push(tuple);
	            }
	        });
	        for (var i = 0; i < insertTuples.length; i++) {
	            this._perViewChange(insertTuples[i].view, insertTuples[i].record);
	        }
	        for (var i = 0, ilen = this._viewContainer.length; i < ilen; i++) {
	            var viewRef = this._viewContainer.get(i);
	            viewRef.context.index = i;
	            viewRef.context.count = ilen;
	        }
	        changes.forEachIdentityChange(function (record) {
	            var viewRef = _this._viewContainer.get(record.currentIndex);
	            viewRef.context.$implicit = record.item;
	        });
	    };
	    NgFor.prototype._perViewChange = function (view, record) {
	        view.context.$implicit = record.item;
	    };
	    /** @nocollapse */
	    NgFor.decorators = [
	        { type: core_1.Directive, args: [{ selector: '[ngFor][ngForOf]' },] },
	    ];
	    /** @nocollapse */
	    NgFor.ctorParameters = [
	        { type: core_1.ViewContainerRef, },
	        { type: core_1.TemplateRef, },
	        { type: core_1.IterableDiffers, },
	        { type: core_1.ChangeDetectorRef, },
	    ];
	    /** @nocollapse */
	    NgFor.propDecorators = {
	        'ngForOf': [{ type: core_1.Input },],
	        'ngForTrackBy': [{ type: core_1.Input },],
	        'ngForTemplate': [{ type: core_1.Input },],
	    };
	    return NgFor;
	}());
	exports.NgFor = NgFor;
	var RecordViewTuple = (function () {
	    function RecordViewTuple(record, view) {
	        this.record = record;
	        this.view = view;
	    }
	    return RecordViewTuple;
	}());
	//# sourceMappingURL=ng_for.js.map

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(3);
	var NgIf = (function () {
	    function NgIf(_viewContainer, _templateRef) {
	        this._viewContainer = _viewContainer;
	        this._templateRef = _templateRef;
	        this._prevCondition = null;
	    }
	    Object.defineProperty(NgIf.prototype, "ngIf", {
	        set: function (newCondition) {
	            if (newCondition && (lang_1.isBlank(this._prevCondition) || !this._prevCondition)) {
	                this._prevCondition = true;
	                this._viewContainer.createEmbeddedView(this._templateRef);
	            }
	            else if (!newCondition && (lang_1.isBlank(this._prevCondition) || this._prevCondition)) {
	                this._prevCondition = false;
	                this._viewContainer.clear();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** @nocollapse */
	    NgIf.decorators = [
	        { type: core_1.Directive, args: [{ selector: '[ngIf]' },] },
	    ];
	    /** @nocollapse */
	    NgIf.ctorParameters = [
	        { type: core_1.ViewContainerRef, },
	        { type: core_1.TemplateRef, },
	    ];
	    /** @nocollapse */
	    NgIf.propDecorators = {
	        'ngIf': [{ type: core_1.Input },],
	    };
	    return NgIf;
	}());
	exports.NgIf = NgIf;
	//# sourceMappingURL=ng_if.js.map

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(3);
	var localization_1 = __webpack_require__(82);
	var ng_switch_1 = __webpack_require__(70);
	var NgPlural = (function () {
	    function NgPlural(_localization) {
	        this._localization = _localization;
	        this._caseViews = {};
	    }
	    Object.defineProperty(NgPlural.prototype, "ngPlural", {
	        set: function (value) {
	            this._switchValue = value;
	            this._updateView();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    NgPlural.prototype.addCase = function (value, switchView) { this._caseViews[value] = switchView; };
	    /** @internal */
	    NgPlural.prototype._updateView = function () {
	        this._clearViews();
	        var key = localization_1.getPluralCategory(this._switchValue, Object.keys(this._caseViews), this._localization);
	        this._activateView(this._caseViews[key]);
	    };
	    /** @internal */
	    NgPlural.prototype._clearViews = function () {
	        if (lang_1.isPresent(this._activeView))
	            this._activeView.destroy();
	    };
	    /** @internal */
	    NgPlural.prototype._activateView = function (view) {
	        if (!lang_1.isPresent(view))
	            return;
	        this._activeView = view;
	        this._activeView.create();
	    };
	    /** @nocollapse */
	    NgPlural.decorators = [
	        { type: core_1.Directive, args: [{ selector: '[ngPlural]' },] },
	    ];
	    /** @nocollapse */
	    NgPlural.ctorParameters = [
	        { type: localization_1.NgLocalization, },
	    ];
	    /** @nocollapse */
	    NgPlural.propDecorators = {
	        'ngPlural': [{ type: core_1.Input },],
	    };
	    return NgPlural;
	}());
	exports.NgPlural = NgPlural;
	var NgPluralCase = (function () {
	    function NgPluralCase(value, template, viewContainer, ngPlural) {
	        this.value = value;
	        ngPlural.addCase(value, new ng_switch_1.SwitchView(viewContainer, template));
	    }
	    /** @nocollapse */
	    NgPluralCase.decorators = [
	        { type: core_1.Directive, args: [{ selector: '[ngPluralCase]' },] },
	    ];
	    /** @nocollapse */
	    NgPluralCase.ctorParameters = [
	        { type: undefined, decorators: [{ type: core_1.Attribute, args: ['ngPluralCase',] },] },
	        { type: core_1.TemplateRef, },
	        { type: core_1.ViewContainerRef, },
	        { type: NgPlural, decorators: [{ type: core_1.Host },] },
	    ];
	    return NgPluralCase;
	}());
	exports.NgPluralCase = NgPluralCase;
	//# sourceMappingURL=ng_plural.js.map

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(3);
	var NgStyle = (function () {
	    function NgStyle(_differs, _ngEl, _renderer) {
	        this._differs = _differs;
	        this._ngEl = _ngEl;
	        this._renderer = _renderer;
	    }
	    Object.defineProperty(NgStyle.prototype, "ngStyle", {
	        set: function (v) {
	            this._ngStyle = v;
	            if (lang_1.isBlank(this._differ) && lang_1.isPresent(v)) {
	                this._differ = this._differs.find(this._ngStyle).create(null);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    NgStyle.prototype.ngDoCheck = function () {
	        if (lang_1.isPresent(this._differ)) {
	            var changes = this._differ.diff(this._ngStyle);
	            if (lang_1.isPresent(changes)) {
	                this._applyChanges(changes);
	            }
	        }
	    };
	    NgStyle.prototype._applyChanges = function (changes) {
	        var _this = this;
	        changes.forEachRemovedItem(function (record) { _this._setStyle(record.key, null); });
	        changes.forEachAddedItem(function (record) { _this._setStyle(record.key, record.currentValue); });
	        changes.forEachChangedItem(function (record) { _this._setStyle(record.key, record.currentValue); });
	    };
	    NgStyle.prototype._setStyle = function (name, val) {
	        var nameParts = name.split('.');
	        var nameToSet = nameParts[0];
	        var valToSet = lang_1.isPresent(val) && nameParts.length === 2 ? "" + val + nameParts[1] : val;
	        this._renderer.setElementStyle(this._ngEl.nativeElement, nameToSet, valToSet);
	    };
	    /** @nocollapse */
	    NgStyle.decorators = [
	        { type: core_1.Directive, args: [{ selector: '[ngStyle]' },] },
	    ];
	    /** @nocollapse */
	    NgStyle.ctorParameters = [
	        { type: core_1.KeyValueDiffers, },
	        { type: core_1.ElementRef, },
	        { type: core_1.Renderer, },
	    ];
	    /** @nocollapse */
	    NgStyle.propDecorators = {
	        'ngStyle': [{ type: core_1.Input },],
	    };
	    return NgStyle;
	}());
	exports.NgStyle = NgStyle;
	//# sourceMappingURL=ng_style.js.map

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var NgTemplateOutlet = (function () {
	    function NgTemplateOutlet(_viewContainerRef) {
	        this._viewContainerRef = _viewContainerRef;
	    }
	    Object.defineProperty(NgTemplateOutlet.prototype, "ngOutletContext", {
	        set: function (context) { this._context = context; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgTemplateOutlet.prototype, "ngTemplateOutlet", {
	        set: function (templateRef) { this._templateRef = templateRef; },
	        enumerable: true,
	        configurable: true
	    });
	    NgTemplateOutlet.prototype.ngOnChanges = function () {
	        if (this._viewRef) {
	            this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._viewRef));
	        }
	        if (this._templateRef) {
	            this._viewRef = this._viewContainerRef.createEmbeddedView(this._templateRef, this._context);
	        }
	    };
	    /** @nocollapse */
	    NgTemplateOutlet.decorators = [
	        { type: core_1.Directive, args: [{ selector: '[ngTemplateOutlet]' },] },
	    ];
	    /** @nocollapse */
	    NgTemplateOutlet.ctorParameters = [
	        { type: core_1.ViewContainerRef, },
	    ];
	    /** @nocollapse */
	    NgTemplateOutlet.propDecorators = {
	        'ngOutletContext': [{ type: core_1.Input },],
	        'ngTemplateOutlet': [{ type: core_1.Input },],
	    };
	    return NgTemplateOutlet;
	}());
	exports.NgTemplateOutlet = NgTemplateOutlet;
	//# sourceMappingURL=ng_template_outlet.js.map

/***/ },
/* 123 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * A base class for the WrappedException that can be used to identify
	 * a WrappedException from ExceptionHandler without adding circular
	 * dependency.
	 */
	var BaseWrappedException = (function (_super) {
	    __extends(BaseWrappedException, _super);
	    function BaseWrappedException(message) {
	        _super.call(this, message);
	    }
	    Object.defineProperty(BaseWrappedException.prototype, "wrapperMessage", {
	        get: function () { return ''; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BaseWrappedException.prototype, "wrapperStack", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BaseWrappedException.prototype, "originalException", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BaseWrappedException.prototype, "originalStack", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BaseWrappedException.prototype, "context", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BaseWrappedException.prototype, "message", {
	        get: function () { return ''; },
	        enumerable: true,
	        configurable: true
	    });
	    return BaseWrappedException;
	}(Error));
	exports.BaseWrappedException = BaseWrappedException;
	//# sourceMappingURL=base_wrapped_exception.js.map

/***/ },
/* 124 */
[294, 123, 10, 3],
/* 125 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	(function (NumberFormatStyle) {
	    NumberFormatStyle[NumberFormatStyle["Decimal"] = 0] = "Decimal";
	    NumberFormatStyle[NumberFormatStyle["Percent"] = 1] = "Percent";
	    NumberFormatStyle[NumberFormatStyle["Currency"] = 2] = "Currency";
	})(exports.NumberFormatStyle || (exports.NumberFormatStyle = {}));
	var NumberFormatStyle = exports.NumberFormatStyle;
	var NumberFormatter = (function () {
	    function NumberFormatter() {
	    }
	    NumberFormatter.format = function (num, locale, style, _a) {
	        var _b = _a === void 0 ? {} : _a, minimumIntegerDigits = _b.minimumIntegerDigits, minimumFractionDigits = _b.minimumFractionDigits, maximumFractionDigits = _b.maximumFractionDigits, currency = _b.currency, _c = _b.currencyAsSymbol, currencyAsSymbol = _c === void 0 ? false : _c;
	        var options = {
	            minimumIntegerDigits: minimumIntegerDigits,
	            minimumFractionDigits: minimumFractionDigits,
	            maximumFractionDigits: maximumFractionDigits,
	            style: NumberFormatStyle[style].toLowerCase()
	        };
	        if (style == NumberFormatStyle.Currency) {
	            options.currency = currency;
	            options.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
	        }
	        return new Intl.NumberFormat(locale, options).format(num);
	    };
	    return NumberFormatter;
	}());
	exports.NumberFormatter = NumberFormatter;
	var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsazZEwGjJ']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|J+|j+|m+|s+|a|z|Z|G+|w+))(.*)/;
	var PATTERN_ALIASES = {
	    yMMMdjms: datePartGetterFactory(combine([
	        digitCondition('year', 1),
	        nameCondition('month', 3),
	        digitCondition('day', 1),
	        digitCondition('hour', 1),
	        digitCondition('minute', 1),
	        digitCondition('second', 1),
	    ])),
	    yMdjm: datePartGetterFactory(combine([
	        digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1),
	        digitCondition('hour', 1), digitCondition('minute', 1)
	    ])),
	    yMMMMEEEEd: datePartGetterFactory(combine([
	        digitCondition('year', 1), nameCondition('month', 4), nameCondition('weekday', 4),
	        digitCondition('day', 1)
	    ])),
	    yMMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), digitCondition('day', 1)])),
	    yMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1)])),
	    yMd: datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1)])),
	    jms: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('second', 1), digitCondition('minute', 1)])),
	    jm: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('minute', 1)]))
	};
	var DATE_FORMATS = {
	    yyyy: datePartGetterFactory(digitCondition('year', 4)),
	    yy: datePartGetterFactory(digitCondition('year', 2)),
	    y: datePartGetterFactory(digitCondition('year', 1)),
	    MMMM: datePartGetterFactory(nameCondition('month', 4)),
	    MMM: datePartGetterFactory(nameCondition('month', 3)),
	    MM: datePartGetterFactory(digitCondition('month', 2)),
	    M: datePartGetterFactory(digitCondition('month', 1)),
	    LLLL: datePartGetterFactory(nameCondition('month', 4)),
	    dd: datePartGetterFactory(digitCondition('day', 2)),
	    d: datePartGetterFactory(digitCondition('day', 1)),
	    HH: digitModifier(hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), false)))),
	    H: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), false))),
	    hh: digitModifier(hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), true)))),
	    h: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
	    jj: datePartGetterFactory(digitCondition('hour', 2)),
	    j: datePartGetterFactory(digitCondition('hour', 1)),
	    mm: digitModifier(datePartGetterFactory(digitCondition('minute', 2))),
	    m: datePartGetterFactory(digitCondition('minute', 1)),
	    ss: digitModifier(datePartGetterFactory(digitCondition('second', 2))),
	    s: datePartGetterFactory(digitCondition('second', 1)),
	    // while ISO 8601 requires fractions to be prefixed with `.` or `,`
	    // we can be just safely rely on using `sss` since we currently don't support single or two digit
	    // fractions
	    sss: datePartGetterFactory(digitCondition('second', 3)),
	    EEEE: datePartGetterFactory(nameCondition('weekday', 4)),
	    EEE: datePartGetterFactory(nameCondition('weekday', 3)),
	    EE: datePartGetterFactory(nameCondition('weekday', 2)),
	    E: datePartGetterFactory(nameCondition('weekday', 1)),
	    a: hourClockExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
	    Z: timeZoneGetter('short'),
	    z: timeZoneGetter('long'),
	    ww: datePartGetterFactory({}),
	    // first Thursday of the year. not support ?
	    w: datePartGetterFactory({}),
	    // of the year not support ?
	    G: datePartGetterFactory(nameCondition('era', 1)),
	    GG: datePartGetterFactory(nameCondition('era', 2)),
	    GGG: datePartGetterFactory(nameCondition('era', 3)),
	    GGGG: datePartGetterFactory(nameCondition('era', 4))
	};
	function digitModifier(inner) {
	    return function (date, locale) {
	        var result = inner(date, locale);
	        return result.length == 1 ? '0' + result : result;
	    };
	}
	function hourClockExtracter(inner) {
	    return function (date, locale) {
	        var result = inner(date, locale);
	        return result.split(' ')[1];
	    };
	}
	function hourExtracter(inner) {
	    return function (date, locale) {
	        var result = inner(date, locale);
	        return result.split(' ')[0];
	    };
	}
	function timeZoneGetter(timezone) {
	    // To workaround `Intl` API restriction for single timezone let format with 24 hours
	    var format = { hour: '2-digit', hour12: false, timeZoneName: timezone };
	    return function (date, locale) {
	        var result = new Intl.DateTimeFormat(locale, format).format(date);
	        // Then extract first 3 letters that related to hours
	        return result ? result.substring(3) : '';
	    };
	}
	function hour12Modify(options, value) {
	    options.hour12 = value;
	    return options;
	}
	function digitCondition(prop, len) {
	    var result = {};
	    result[prop] = len == 2 ? '2-digit' : 'numeric';
	    return result;
	}
	function nameCondition(prop, len) {
	    var result = {};
	    result[prop] = len < 4 ? 'short' : 'long';
	    return result;
	}
	function combine(options) {
	    var result = {};
	    options.forEach(function (option) { Object.assign(result, option); });
	    return result;
	}
	function datePartGetterFactory(ret) {
	    return function (date, locale) {
	        return new Intl.DateTimeFormat(locale, ret).format(date);
	    };
	}
	var datePartsFormatterCache = new Map();
	function dateFormatter(format, date, locale) {
	    var text = '';
	    var match;
	    var fn;
	    var parts = [];
	    if (PATTERN_ALIASES[format]) {
	        return PATTERN_ALIASES[format](date, locale);
	    }
	    if (datePartsFormatterCache.has(format)) {
	        parts = datePartsFormatterCache.get(format);
	    }
	    else {
	        var matches = DATE_FORMATS_SPLIT.exec(format);
	        while (format) {
	            match = DATE_FORMATS_SPLIT.exec(format);
	            if (match) {
	                parts = concat(parts, match, 1);
	                format = parts.pop();
	            }
	            else {
	                parts.push(format);
	                format = null;
	            }
	        }
	        datePartsFormatterCache.set(format, parts);
	    }
	    parts.forEach(function (part) {
	        fn = DATE_FORMATS[part];
	        text += fn ? fn(date, locale) :
	            part === '\'\'' ? '\'' : part.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
	    });
	    return text;
	}
	var slice = [].slice;
	function concat(array1 /** TODO #9100 */, array2 /** TODO #9100 */, index /** TODO #9100 */) {
	    return array1.concat(slice.call(array2, index));
	}
	var DateFormatter = (function () {
	    function DateFormatter() {
	    }
	    DateFormatter.format = function (date, locale, pattern) {
	        return dateFormatter(pattern, date, locale);
	    };
	    return DateFormatter;
	}());
	exports.DateFormatter = DateFormatter;
	//# sourceMappingURL=intl.js.map

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var checkbox_value_accessor_1 = __webpack_require__(41);
	var default_value_accessor_1 = __webpack_require__(42);
	var ng_control_group_1 = __webpack_require__(72);
	var ng_control_name_1 = __webpack_require__(73);
	var ng_control_status_1 = __webpack_require__(74);
	var ng_form_1 = __webpack_require__(75);
	var ng_form_control_1 = __webpack_require__(76);
	var ng_form_model_1 = __webpack_require__(77);
	var ng_model_1 = __webpack_require__(78);
	var number_value_accessor_1 = __webpack_require__(79);
	var radio_control_value_accessor_1 = __webpack_require__(43);
	var select_control_value_accessor_1 = __webpack_require__(44);
	var select_multiple_control_value_accessor_1 = __webpack_require__(80);
	var validators_1 = __webpack_require__(81);
	var checkbox_value_accessor_2 = __webpack_require__(41);
	exports.CheckboxControlValueAccessor = checkbox_value_accessor_2.CheckboxControlValueAccessor;
	var default_value_accessor_2 = __webpack_require__(42);
	exports.DefaultValueAccessor = default_value_accessor_2.DefaultValueAccessor;
	var ng_control_1 = __webpack_require__(21);
	exports.NgControl = ng_control_1.NgControl;
	var ng_control_group_2 = __webpack_require__(72);
	exports.NgControlGroup = ng_control_group_2.NgControlGroup;
	var ng_control_name_2 = __webpack_require__(73);
	exports.NgControlName = ng_control_name_2.NgControlName;
	var ng_control_status_2 = __webpack_require__(74);
	exports.NgControlStatus = ng_control_status_2.NgControlStatus;
	var ng_form_2 = __webpack_require__(75);
	exports.NgForm = ng_form_2.NgForm;
	var ng_form_control_2 = __webpack_require__(76);
	exports.NgFormControl = ng_form_control_2.NgFormControl;
	var ng_form_model_2 = __webpack_require__(77);
	exports.NgFormModel = ng_form_model_2.NgFormModel;
	var ng_model_2 = __webpack_require__(78);
	exports.NgModel = ng_model_2.NgModel;
	var number_value_accessor_2 = __webpack_require__(79);
	exports.NumberValueAccessor = number_value_accessor_2.NumberValueAccessor;
	var radio_control_value_accessor_2 = __webpack_require__(43);
	exports.RadioButtonState = radio_control_value_accessor_2.RadioButtonState;
	exports.RadioControlValueAccessor = radio_control_value_accessor_2.RadioControlValueAccessor;
	var select_control_value_accessor_2 = __webpack_require__(44);
	exports.NgSelectOption = select_control_value_accessor_2.NgSelectOption;
	exports.SelectControlValueAccessor = select_control_value_accessor_2.SelectControlValueAccessor;
	var select_multiple_control_value_accessor_2 = __webpack_require__(80);
	exports.NgSelectMultipleOption = select_multiple_control_value_accessor_2.NgSelectMultipleOption;
	exports.SelectMultipleControlValueAccessor = select_multiple_control_value_accessor_2.SelectMultipleControlValueAccessor;
	var validators_2 = __webpack_require__(81);
	exports.MaxLengthValidator = validators_2.MaxLengthValidator;
	exports.MinLengthValidator = validators_2.MinLengthValidator;
	exports.PatternValidator = validators_2.PatternValidator;
	exports.RequiredValidator = validators_2.RequiredValidator;
	/**
	 *
	 * A list of all the form directives used as part of a `@Component` annotation.
	 *
	 *  This is a shorthand for importing them each individually.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'my-app',
	 *   directives: [FORM_DIRECTIVES]
	 * })
	 * class MyApp {}
	 * ```
	 * @experimental
	 */
	exports.FORM_DIRECTIVES = [
	    ng_control_name_1.NgControlName,
	    ng_control_group_1.NgControlGroup,
	    ng_form_control_1.NgFormControl,
	    ng_model_1.NgModel,
	    ng_form_model_1.NgFormModel,
	    ng_form_1.NgForm,
	    select_control_value_accessor_1.NgSelectOption,
	    select_multiple_control_value_accessor_1.NgSelectMultipleOption,
	    default_value_accessor_1.DefaultValueAccessor,
	    number_value_accessor_1.NumberValueAccessor,
	    checkbox_value_accessor_1.CheckboxControlValueAccessor,
	    select_control_value_accessor_1.SelectControlValueAccessor,
	    select_multiple_control_value_accessor_1.SelectMultipleControlValueAccessor,
	    radio_control_value_accessor_1.RadioControlValueAccessor,
	    ng_control_status_1.NgControlStatus,
	    validators_1.RequiredValidator,
	    validators_1.MinLengthValidator,
	    validators_1.MaxLengthValidator,
	    validators_1.PatternValidator,
	];
	//# sourceMappingURL=directives.js.map

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(10);
	var lang_1 = __webpack_require__(3);
	var model_1 = __webpack_require__(45);
	var FormBuilder = (function () {
	    function FormBuilder() {
	    }
	    /**
	     * Construct a new {@link ControlGroup} with the given map of configuration.
	     * Valid keys for the `extra` parameter map are `optionals` and `validator`.
	     *
	     * See the {@link ControlGroup} constructor for more details.
	     */
	    FormBuilder.prototype.group = function (controlsConfig, extra) {
	        if (extra === void 0) { extra = null; }
	        var controls = this._reduceControls(controlsConfig);
	        var optionals = (lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, 'optionals') : null);
	        var validator = lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, 'validator') : null;
	        var asyncValidator = lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, 'asyncValidator') : null;
	        return new model_1.ControlGroup(controls, optionals, validator, asyncValidator);
	    };
	    /**
	     * Construct a new {@link Control} with the given `value`,`validator`, and `asyncValidator`.
	     */
	    FormBuilder.prototype.control = function (value, validator, asyncValidator) {
	        if (validator === void 0) { validator = null; }
	        if (asyncValidator === void 0) { asyncValidator = null; }
	        return new model_1.Control(value, validator, asyncValidator);
	    };
	    /**
	     * Construct an array of {@link Control}s from the given `controlsConfig` array of
	     * configuration, with the given optional `validator` and `asyncValidator`.
	     */
	    FormBuilder.prototype.array = function (controlsConfig, validator, asyncValidator) {
	        var _this = this;
	        if (validator === void 0) { validator = null; }
	        if (asyncValidator === void 0) { asyncValidator = null; }
	        var controls = controlsConfig.map(function (c) { return _this._createControl(c); });
	        return new model_1.ControlArray(controls, validator, asyncValidator);
	    };
	    /** @internal */
	    FormBuilder.prototype._reduceControls = function (controlsConfig) {
	        var _this = this;
	        var controls = {};
	        collection_1.StringMapWrapper.forEach(controlsConfig, function (controlConfig, controlName) {
	            controls[controlName] = _this._createControl(controlConfig);
	        });
	        return controls;
	    };
	    /** @internal */
	    FormBuilder.prototype._createControl = function (controlConfig) {
	        if (controlConfig instanceof model_1.Control || controlConfig instanceof model_1.ControlGroup ||
	            controlConfig instanceof model_1.ControlArray) {
	            return controlConfig;
	        }
	        else if (lang_1.isArray(controlConfig)) {
	            var value = controlConfig[0];
	            var validator = controlConfig.length > 1 ? controlConfig[1] : null;
	            var asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;
	            return this.control(value, validator, asyncValidator);
	        }
	        else {
	            return this.control(controlConfig);
	        }
	    };
	    /** @nocollapse */
	    FormBuilder.decorators = [
	        { type: core_1.Injectable },
	    ];
	    return FormBuilder;
	}());
	exports.FormBuilder = FormBuilder;
	//# sourceMappingURL=form_builder.js.map

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * @module
	 * @description
	 * This module provides a set of common Pipes.
	 */
	var async_pipe_1 = __webpack_require__(129);
	exports.AsyncPipe = async_pipe_1.AsyncPipe;
	var common_pipes_1 = __webpack_require__(203);
	exports.COMMON_PIPES = common_pipes_1.COMMON_PIPES;
	var date_pipe_1 = __webpack_require__(130);
	exports.DatePipe = date_pipe_1.DatePipe;
	var i18n_plural_pipe_1 = __webpack_require__(131);
	exports.I18nPluralPipe = i18n_plural_pipe_1.I18nPluralPipe;
	var i18n_select_pipe_1 = __webpack_require__(132);
	exports.I18nSelectPipe = i18n_select_pipe_1.I18nSelectPipe;
	var json_pipe_1 = __webpack_require__(133);
	exports.JsonPipe = json_pipe_1.JsonPipe;
	var lowercase_pipe_1 = __webpack_require__(134);
	exports.LowerCasePipe = lowercase_pipe_1.LowerCasePipe;
	var number_pipe_1 = __webpack_require__(135);
	exports.CurrencyPipe = number_pipe_1.CurrencyPipe;
	exports.DecimalPipe = number_pipe_1.DecimalPipe;
	exports.PercentPipe = number_pipe_1.PercentPipe;
	var replace_pipe_1 = __webpack_require__(136);
	exports.ReplacePipe = replace_pipe_1.ReplacePipe;
	var slice_pipe_1 = __webpack_require__(137);
	exports.SlicePipe = slice_pipe_1.SlicePipe;
	var uppercase_pipe_1 = __webpack_require__(138);
	exports.UpperCasePipe = uppercase_pipe_1.UpperCasePipe;
	//# sourceMappingURL=pipes.js.map

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(3);
	var invalid_pipe_argument_exception_1 = __webpack_require__(16);
	var ObservableStrategy = (function () {
	    function ObservableStrategy() {
	    }
	    ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {
	        return async.subscribe({ next: updateLatestValue, error: function (e) { throw e; } });
	    };
	    ObservableStrategy.prototype.dispose = function (subscription) { subscription.unsubscribe(); };
	    ObservableStrategy.prototype.onDestroy = function (subscription) { subscription.unsubscribe(); };
	    return ObservableStrategy;
	}());
	var PromiseStrategy = (function () {
	    function PromiseStrategy() {
	    }
	    PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {
	        return async.then(updateLatestValue, function (e) { throw e; });
	    };
	    PromiseStrategy.prototype.dispose = function (subscription) { };
	    PromiseStrategy.prototype.onDestroy = function (subscription) { };
	    return PromiseStrategy;
	}());
	var _promiseStrategy = new PromiseStrategy();
	var _observableStrategy = new ObservableStrategy();
	var __unused;
	var AsyncPipe = (function () {
	    function AsyncPipe(_ref) {
	        /** @internal */
	        this._latestValue = null;
	        /** @internal */
	        this._latestReturnedValue = null;
	        /** @internal */
	        this._subscription = null;
	        /** @internal */
	        this._obj = null;
	        this._strategy = null;
	        this._ref = _ref;
	    }
	    AsyncPipe.prototype.ngOnDestroy = function () {
	        if (lang_1.isPresent(this._subscription)) {
	            this._dispose();
	        }
	    };
	    AsyncPipe.prototype.transform = function (obj) {
	        if (lang_1.isBlank(this._obj)) {
	            if (lang_1.isPresent(obj)) {
	                this._subscribe(obj);
	            }
	            this._latestReturnedValue = this._latestValue;
	            return this._latestValue;
	        }
	        if (obj !== this._obj) {
	            this._dispose();
	            return this.transform(obj);
	        }
	        if (this._latestValue === this._latestReturnedValue) {
	            return this._latestReturnedValue;
	        }
	        else {
	            this._latestReturnedValue = this._latestValue;
	            return core_1.WrappedValue.wrap(this._latestValue);
	        }
	    };
	    /** @internal */
	    AsyncPipe.prototype._subscribe = function (obj) {
	        var _this = this;
	        this._obj = obj;
	        this._strategy = this._selectStrategy(obj);
	        this._subscription = this._strategy.createSubscription(obj, function (value) { return _this._updateLatestValue(obj, value); });
	    };
	    /** @internal */
	    AsyncPipe.prototype._selectStrategy = function (obj) {
	        if (lang_1.isPromise(obj)) {
	            return _promiseStrategy;
	        }
	        else if (obj.subscribe) {
	            return _observableStrategy;
	        }
	        else {
	            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(AsyncPipe, obj);
	        }
	    };
	    /** @internal */
	    AsyncPipe.prototype._dispose = function () {
	        this._strategy.dispose(this._subscription);
	        this._latestValue = null;
	        this._latestReturnedValue = null;
	        this._subscription = null;
	        this._obj = null;
	    };
	    /** @internal */
	    AsyncPipe.prototype._updateLatestValue = function (async, value) {
	        if (async === this._obj) {
	            this._latestValue = value;
	            this._ref.markForCheck();
	        }
	    };
	    /** @nocollapse */
	    AsyncPipe.decorators = [
	        { type: core_1.Pipe, args: [{ name: 'async', pure: false },] },
	    ];
	    /** @nocollapse */
	    AsyncPipe.ctorParameters = [
	        { type: core_1.ChangeDetectorRef, },
	    ];
	    return AsyncPipe;
	}());
	exports.AsyncPipe = AsyncPipe;
	//# sourceMappingURL=async_pipe.js.map

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(10);
	var intl_1 = __webpack_require__(125);
	var lang_1 = __webpack_require__(3);
	var invalid_pipe_argument_exception_1 = __webpack_require__(16);
	// TODO: move to a global configurable location along with other i18n components.
	var defaultLocale = 'en-US';
	var DatePipe = (function () {
	    function DatePipe() {
	    }
	    DatePipe.prototype.transform = function (value, pattern) {
	        if (pattern === void 0) { pattern = 'mediumDate'; }
	        if (lang_1.isBlank(value))
	            return null;
	        if (!this.supports(value)) {
	            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(DatePipe, value);
	        }
	        if (lang_1.NumberWrapper.isNumeric(value)) {
	            value = lang_1.DateWrapper.fromMillis(lang_1.NumberWrapper.parseInt(value, 10));
	        }
	        else if (lang_1.isString(value)) {
	            value = lang_1.DateWrapper.fromISOString(value);
	        }
	        if (collection_1.StringMapWrapper.contains(DatePipe._ALIASES, pattern)) {
	            pattern = collection_1.StringMapWrapper.get(DatePipe._ALIASES, pattern);
	        }
	        return intl_1.DateFormatter.format(value, defaultLocale, pattern);
	    };
	    DatePipe.prototype.supports = function (obj) {
	        if (lang_1.isDate(obj) || lang_1.NumberWrapper.isNumeric(obj)) {
	            return true;
	        }
	        if (lang_1.isString(obj) && lang_1.isDate(lang_1.DateWrapper.fromISOString(obj))) {
	            return true;
	        }
	        return false;
	    };
	    /** @internal */
	    DatePipe._ALIASES = {
	        'medium': 'yMMMdjms',
	        'short': 'yMdjm',
	        'fullDate': 'yMMMMEEEEd',
	        'longDate': 'yMMMMd',
	        'mediumDate': 'yMMMd',
	        'shortDate': 'yMd',
	        'mediumTime': 'jms',
	        'shortTime': 'jm'
	    };
	    /** @nocollapse */
	    DatePipe.decorators = [
	        { type: core_1.Pipe, args: [{ name: 'date', pure: true },] },
	    ];
	    return DatePipe;
	}());
	exports.DatePipe = DatePipe;
	//# sourceMappingURL=date_pipe.js.map

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(3);
	var localization_1 = __webpack_require__(82);
	var invalid_pipe_argument_exception_1 = __webpack_require__(16);
	var _INTERPOLATION_REGEXP = /#/g;
	var I18nPluralPipe = (function () {
	    function I18nPluralPipe(_localization) {
	        this._localization = _localization;
	    }
	    I18nPluralPipe.prototype.transform = function (value, pluralMap) {
	        if (lang_1.isBlank(value))
	            return '';
	        if (!lang_1.isStringMap(pluralMap)) {
	            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(I18nPluralPipe, pluralMap);
	        }
	        var key = localization_1.getPluralCategory(value, Object.keys(pluralMap), this._localization);
	        return lang_1.StringWrapper.replaceAll(pluralMap[key], _INTERPOLATION_REGEXP, value.toString());
	    };
	    /** @nocollapse */
	    I18nPluralPipe.decorators = [
	        { type: core_1.Pipe, args: [{ name: 'i18nPlural', pure: true },] },
	    ];
	    /** @nocollapse */
	    I18nPluralPipe.ctorParameters = [
	        { type: localization_1.NgLocalization, },
	    ];
	    return I18nPluralPipe;
	}());
	exports.I18nPluralPipe = I18nPluralPipe;
	//# sourceMappingURL=i18n_plural_pipe.js.map

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(3);
	var invalid_pipe_argument_exception_1 = __webpack_require__(16);
	var I18nSelectPipe = (function () {
	    function I18nSelectPipe() {
	    }
	    I18nSelectPipe.prototype.transform = function (value, mapping) {
	        if (lang_1.isBlank(value))
	            return '';
	        if (!lang_1.isStringMap(mapping)) {
	            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(I18nSelectPipe, mapping);
	        }
	        return mapping.hasOwnProperty(value) ? mapping[value] : '';
	    };
	    /** @nocollapse */
	    I18nSelectPipe.decorators = [
	        { type: core_1.Pipe, args: [{ name: 'i18nSelect', pure: true },] },
	    ];
	    return I18nSelectPipe;
	}());
	exports.I18nSelectPipe = I18nSelectPipe;
	//# sourceMappingURL=i18n_select_pipe.js.map

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(3);
	var JsonPipe = (function () {
	    function JsonPipe() {
	    }
	    JsonPipe.prototype.transform = function (value) { return lang_1.Json.stringify(value); };
	    /** @nocollapse */
	    JsonPipe.decorators = [
	        { type: core_1.Pipe, args: [{ name: 'json', pure: false },] },
	    ];
	    return JsonPipe;
	}());
	exports.JsonPipe = JsonPipe;
	//# sourceMappingURL=json_pipe.js.map

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(3);
	var invalid_pipe_argument_exception_1 = __webpack_require__(16);
	var LowerCasePipe = (function () {
	    function LowerCasePipe() {
	    }
	    LowerCasePipe.prototype.transform = function (value) {
	        if (lang_1.isBlank(value))
	            return value;
	        if (!lang_1.isString(value)) {
	            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(LowerCasePipe, value);
	        }
	        return value.toLowerCase();
	    };
	    /** @nocollapse */
	    LowerCasePipe.decorators = [
	        { type: core_1.Pipe, args: [{ name: 'lowercase' },] },
	    ];
	    return LowerCasePipe;
	}());
	exports.LowerCasePipe = LowerCasePipe;
	//# sourceMappingURL=lowercase_pipe.js.map

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var intl_1 = __webpack_require__(125);
	var lang_1 = __webpack_require__(3);
	var invalid_pipe_argument_exception_1 = __webpack_require__(16);
	var defaultLocale = 'en-US';
	var _NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(\-(\d+))?)?$/;
	function formatNumber(pipe, value, style, digits, currency, currencyAsSymbol) {
	    if (currency === void 0) { currency = null; }
	    if (currencyAsSymbol === void 0) { currencyAsSymbol = false; }
	    if (lang_1.isBlank(value))
	        return null;
	    // Convert strings to numbers
	    value = lang_1.isString(value) && lang_1.NumberWrapper.isNumeric(value) ? +value : value;
	    if (!lang_1.isNumber(value)) {
	        throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(pipe, value);
	    }
	    var minInt;
	    var minFraction;
	    var maxFraction;
	    if (style !== intl_1.NumberFormatStyle.Currency) {
	        // rely on Intl default for currency
	        minInt = 1;
	        minFraction = 0;
	        maxFraction = 3;
	    }
	    if (lang_1.isPresent(digits)) {
	        var parts = digits.match(_NUMBER_FORMAT_REGEXP);
	        if (parts === null) {
	            throw new Error(digits + " is not a valid digit info for number pipes");
	        }
	        if (lang_1.isPresent(parts[1])) {
	            minInt = lang_1.NumberWrapper.parseIntAutoRadix(parts[1]);
	        }
	        if (lang_1.isPresent(parts[3])) {
	            minFraction = lang_1.NumberWrapper.parseIntAutoRadix(parts[3]);
	        }
	        if (lang_1.isPresent(parts[5])) {
	            maxFraction = lang_1.NumberWrapper.parseIntAutoRadix(parts[5]);
	        }
	    }
	    return intl_1.NumberFormatter.format(value, defaultLocale, style, {
	        minimumIntegerDigits: minInt,
	        minimumFractionDigits: minFraction,
	        maximumFractionDigits: maxFraction,
	        currency: currency,
	        currencyAsSymbol: currencyAsSymbol
	    });
	}
	var DecimalPipe = (function () {
	    function DecimalPipe() {
	    }
	    DecimalPipe.prototype.transform = function (value, digits) {
	        if (digits === void 0) { digits = null; }
	        return formatNumber(DecimalPipe, value, intl_1.NumberFormatStyle.Decimal, digits);
	    };
	    /** @nocollapse */
	    DecimalPipe.decorators = [
	        { type: core_1.Pipe, args: [{ name: 'number' },] },
	    ];
	    return DecimalPipe;
	}());
	exports.DecimalPipe = DecimalPipe;
	var PercentPipe = (function () {
	    function PercentPipe() {
	    }
	    PercentPipe.prototype.transform = function (value, digits) {
	        if (digits === void 0) { digits = null; }
	        return formatNumber(PercentPipe, value, intl_1.NumberFormatStyle.Percent, digits);
	    };
	    /** @nocollapse */
	    PercentPipe.decorators = [
	        { type: core_1.Pipe, args: [{ name: 'percent' },] },
	    ];
	    return PercentPipe;
	}());
	exports.PercentPipe = PercentPipe;
	var CurrencyPipe = (function () {
	    function CurrencyPipe() {
	    }
	    CurrencyPipe.prototype.transform = function (value, currencyCode, symbolDisplay, digits) {
	        if (currencyCode === void 0) { currencyCode = 'USD'; }
	        if (symbolDisplay === void 0) { symbolDisplay = false; }
	        if (digits === void 0) { digits = null; }
	        return formatNumber(CurrencyPipe, value, intl_1.NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);
	    };
	    /** @nocollapse */
	    CurrencyPipe.decorators = [
	        { type: core_1.Pipe, args: [{ name: 'currency' },] },
	    ];
	    return CurrencyPipe;
	}());
	exports.CurrencyPipe = CurrencyPipe;
	//# sourceMappingURL=number_pipe.js.map

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(3);
	var invalid_pipe_argument_exception_1 = __webpack_require__(16);
	var ReplacePipe = (function () {
	    function ReplacePipe() {
	    }
	    ReplacePipe.prototype.transform = function (value, pattern, replacement) {
	        if (lang_1.isBlank(value)) {
	            return value;
	        }
	        if (!this._supportedInput(value)) {
	            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(ReplacePipe, value);
	        }
	        var input = value.toString();
	        if (!this._supportedPattern(pattern)) {
	            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(ReplacePipe, pattern);
	        }
	        if (!this._supportedReplacement(replacement)) {
	            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(ReplacePipe, replacement);
	        }
	        if (lang_1.isFunction(replacement)) {
	            var rgxPattern = lang_1.isString(pattern) ? new RegExp(pattern, 'g') : pattern;
	            return lang_1.StringWrapper.replaceAllMapped(input, rgxPattern, replacement);
	        }
	        if (pattern instanceof RegExp) {
	            // use the replaceAll variant
	            return lang_1.StringWrapper.replaceAll(input, pattern, replacement);
	        }
	        return lang_1.StringWrapper.replace(input, pattern, replacement);
	    };
	    ReplacePipe.prototype._supportedInput = function (input) { return lang_1.isString(input) || lang_1.isNumber(input); };
	    ReplacePipe.prototype._supportedPattern = function (pattern) {
	        return lang_1.isString(pattern) || pattern instanceof RegExp;
	    };
	    ReplacePipe.prototype._supportedReplacement = function (replacement) {
	        return lang_1.isString(replacement) || lang_1.isFunction(replacement);
	    };
	    /** @nocollapse */
	    ReplacePipe.decorators = [
	        { type: core_1.Pipe, args: [{ name: 'replace' },] },
	    ];
	    return ReplacePipe;
	}());
	exports.ReplacePipe = ReplacePipe;
	//# sourceMappingURL=replace_pipe.js.map

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(10);
	var lang_1 = __webpack_require__(3);
	var invalid_pipe_argument_exception_1 = __webpack_require__(16);
	var SlicePipe = (function () {
	    function SlicePipe() {
	    }
	    SlicePipe.prototype.transform = function (value, start, end) {
	        if (end === void 0) { end = null; }
	        if (lang_1.isBlank(value))
	            return value;
	        if (!this.supports(value)) {
	            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(SlicePipe, value);
	        }
	        if (lang_1.isString(value)) {
	            return lang_1.StringWrapper.slice(value, start, end);
	        }
	        return collection_1.ListWrapper.slice(value, start, end);
	    };
	    SlicePipe.prototype.supports = function (obj) { return lang_1.isString(obj) || lang_1.isArray(obj); };
	    /** @nocollapse */
	    SlicePipe.decorators = [
	        { type: core_1.Pipe, args: [{ name: 'slice', pure: false },] },
	    ];
	    return SlicePipe;
	}());
	exports.SlicePipe = SlicePipe;
	//# sourceMappingURL=slice_pipe.js.map

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(3);
	var invalid_pipe_argument_exception_1 = __webpack_require__(16);
	var UpperCasePipe = (function () {
	    function UpperCasePipe() {
	    }
	    UpperCasePipe.prototype.transform = function (value) {
	        if (lang_1.isBlank(value))
	            return value;
	        if (!lang_1.isString(value)) {
	            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(UpperCasePipe, value);
	        }
	        return value.toUpperCase();
	    };
	    /** @nocollapse */
	    UpperCasePipe.decorators = [
	        { type: core_1.Pipe, args: [{ name: 'uppercase' },] },
	    ];
	    return UpperCasePipe;
	}());
	exports.UpperCasePipe = UpperCasePipe;
	//# sourceMappingURL=uppercase_pipe.js.map

/***/ },
/* 139 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	exports.FILL_STYLE_FLAG = 'true'; // TODO (matsko): change to boolean
	exports.ANY_STATE = '*';
	exports.DEFAULT_STATE = '*';
	exports.EMPTY_STATE = 'void';
	//# sourceMappingURL=animation_constants.js.map

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var math_1 = __webpack_require__(215);
	var AnimationGroupPlayer = (function () {
	    function AnimationGroupPlayer(_players) {
	        var _this = this;
	        this._players = _players;
	        this._subscriptions = [];
	        this._finished = false;
	        this._started = false;
	        this.parentPlayer = null;
	        var count = 0;
	        var total = this._players.length;
	        if (total == 0) {
	            lang_1.scheduleMicroTask(function () { return _this._onFinish(); });
	        }
	        else {
	            this._players.forEach(function (player) {
	                player.parentPlayer = _this;
	                player.onDone(function () {
	                    if (++count >= total) {
	                        _this._onFinish();
	                    }
	                });
	            });
	        }
	    }
	    AnimationGroupPlayer.prototype._onFinish = function () {
	        if (!this._finished) {
	            this._finished = true;
	            if (!lang_1.isPresent(this.parentPlayer)) {
	                this.destroy();
	            }
	            this._subscriptions.forEach(function (subscription) { return subscription(); });
	            this._subscriptions = [];
	        }
	    };
	    AnimationGroupPlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };
	    AnimationGroupPlayer.prototype.onDone = function (fn) { this._subscriptions.push(fn); };
	    AnimationGroupPlayer.prototype.hasStarted = function () { return this._started; };
	    AnimationGroupPlayer.prototype.play = function () {
	        if (!lang_1.isPresent(this.parentPlayer)) {
	            this.init();
	        }
	        this._started = true;
	        this._players.forEach(function (player) { return player.play(); });
	    };
	    AnimationGroupPlayer.prototype.pause = function () { this._players.forEach(function (player) { return player.pause(); }); };
	    AnimationGroupPlayer.prototype.restart = function () { this._players.forEach(function (player) { return player.restart(); }); };
	    AnimationGroupPlayer.prototype.finish = function () {
	        this._onFinish();
	        this._players.forEach(function (player) { return player.finish(); });
	    };
	    AnimationGroupPlayer.prototype.destroy = function () {
	        this._onFinish();
	        this._players.forEach(function (player) { return player.destroy(); });
	    };
	    AnimationGroupPlayer.prototype.reset = function () { this._players.forEach(function (player) { return player.reset(); }); };
	    AnimationGroupPlayer.prototype.setPosition = function (p /** TODO #9100 */) {
	        this._players.forEach(function (player) { player.setPosition(p); });
	    };
	    AnimationGroupPlayer.prototype.getPosition = function () {
	        var min = 0;
	        this._players.forEach(function (player) {
	            var p = player.getPosition();
	            min = math_1.Math.min(p, min);
	        });
	        return min;
	    };
	    return AnimationGroupPlayer;
	}());
	exports.AnimationGroupPlayer = AnimationGroupPlayer;
	//# sourceMappingURL=animation_group_player.js.map

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	/**
	 * @experimental Animation support is experimental.
	 */
	exports.AUTO_STYLE = '*';
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link trigger trigger
	 * animation function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationEntryMetadata = (function () {
	    function AnimationEntryMetadata(name, definitions) {
	        this.name = name;
	        this.definitions = definitions;
	    }
	    return AnimationEntryMetadata;
	}());
	exports.AnimationEntryMetadata = AnimationEntryMetadata;
	/**
	 * @experimental Animation support is experimental.
	 */
	var AnimationStateMetadata = (function () {
	    function AnimationStateMetadata() {
	    }
	    return AnimationStateMetadata;
	}());
	exports.AnimationStateMetadata = AnimationStateMetadata;
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link state state animation
	 * function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationStateDeclarationMetadata = (function (_super) {
	    __extends(AnimationStateDeclarationMetadata, _super);
	    function AnimationStateDeclarationMetadata(stateNameExpr, styles) {
	        _super.call(this);
	        this.stateNameExpr = stateNameExpr;
	        this.styles = styles;
	    }
	    return AnimationStateDeclarationMetadata;
	}(AnimationStateMetadata));
	exports.AnimationStateDeclarationMetadata = AnimationStateDeclarationMetadata;
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the
	 * {@link transition transition animation function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationStateTransitionMetadata = (function (_super) {
	    __extends(AnimationStateTransitionMetadata, _super);
	    function AnimationStateTransitionMetadata(stateChangeExpr, steps) {
	        _super.call(this);
	        this.stateChangeExpr = stateChangeExpr;
	        this.steps = steps;
	    }
	    return AnimationStateTransitionMetadata;
	}(AnimationStateMetadata));
	exports.AnimationStateTransitionMetadata = AnimationStateTransitionMetadata;
	/**
	 * @experimental Animation support is experimental.
	 */
	var AnimationMetadata = (function () {
	    function AnimationMetadata() {
	    }
	    return AnimationMetadata;
	}());
	exports.AnimationMetadata = AnimationMetadata;
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link keyframes keyframes
	 * animation function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationKeyframesSequenceMetadata = (function (_super) {
	    __extends(AnimationKeyframesSequenceMetadata, _super);
	    function AnimationKeyframesSequenceMetadata(steps) {
	        _super.call(this);
	        this.steps = steps;
	    }
	    return AnimationKeyframesSequenceMetadata;
	}(AnimationMetadata));
	exports.AnimationKeyframesSequenceMetadata = AnimationKeyframesSequenceMetadata;
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link style style animation
	 * function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationStyleMetadata = (function (_super) {
	    __extends(AnimationStyleMetadata, _super);
	    function AnimationStyleMetadata(styles, offset) {
	        if (offset === void 0) { offset = null; }
	        _super.call(this);
	        this.styles = styles;
	        this.offset = offset;
	    }
	    return AnimationStyleMetadata;
	}(AnimationMetadata));
	exports.AnimationStyleMetadata = AnimationStyleMetadata;
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link animate animate
	 * animation function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationAnimateMetadata = (function (_super) {
	    __extends(AnimationAnimateMetadata, _super);
	    function AnimationAnimateMetadata(timings, styles) {
	        _super.call(this);
	        this.timings = timings;
	        this.styles = styles;
	    }
	    return AnimationAnimateMetadata;
	}(AnimationMetadata));
	exports.AnimationAnimateMetadata = AnimationAnimateMetadata;
	/**
	 * @experimental Animation support is experimental.
	 */
	var AnimationWithStepsMetadata = (function (_super) {
	    __extends(AnimationWithStepsMetadata, _super);
	    function AnimationWithStepsMetadata() {
	        _super.call(this);
	    }
	    Object.defineProperty(AnimationWithStepsMetadata.prototype, "steps", {
	        get: function () { throw new exceptions_1.BaseException('NOT IMPLEMENTED: Base Class'); },
	        enumerable: true,
	        configurable: true
	    });
	    return AnimationWithStepsMetadata;
	}(AnimationMetadata));
	exports.AnimationWithStepsMetadata = AnimationWithStepsMetadata;
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link sequence sequence
	 * animation function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationSequenceMetadata = (function (_super) {
	    __extends(AnimationSequenceMetadata, _super);
	    function AnimationSequenceMetadata(_steps) {
	        _super.call(this);
	        this._steps = _steps;
	    }
	    Object.defineProperty(AnimationSequenceMetadata.prototype, "steps", {
	        get: function () { return this._steps; },
	        enumerable: true,
	        configurable: true
	    });
	    return AnimationSequenceMetadata;
	}(AnimationWithStepsMetadata));
	exports.AnimationSequenceMetadata = AnimationSequenceMetadata;
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link group group animation
	 * function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationGroupMetadata = (function (_super) {
	    __extends(AnimationGroupMetadata, _super);
	    function AnimationGroupMetadata(_steps) {
	        _super.call(this);
	        this._steps = _steps;
	    }
	    Object.defineProperty(AnimationGroupMetadata.prototype, "steps", {
	        get: function () { return this._steps; },
	        enumerable: true,
	        configurable: true
	    });
	    return AnimationGroupMetadata;
	}(AnimationWithStepsMetadata));
	exports.AnimationGroupMetadata = AnimationGroupMetadata;
	/**
	 * `animate` is an animation-specific function that is designed to be used inside of Angular2's
	 * animation
	 * DSL language. If this information is new, please navigate to the
	 * {@link ComponentMetadata#animations-anchor component animations metadata
	 * page} to gain a better understanding of how animations in Angular2 are used.
	 *
	 * `animate` specifies an animation step that will apply the provided `styles` data for a given
	 * amount of
	 * time based on the provided `timing` expression value. Calls to `animate` are expected to be
	 * used within {@link sequence an animation sequence}, {@link group group}, or {@link transition
	 * transition}.
	 *
	 * ### Usage
	 *
	 * The `animate` function accepts two input parameters: `timing` and `styles`:
	 *
	 * - `timing` is a string based value that can be a combination of a duration with optional
	 * delay and easing values. The format for the expression breaks down to `duration delay easing`
	 * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,
	 * delay=100, easing=ease-out`.
	 * If a numeric value is provided then that will be used as the `duration` value in millisecond
	 * form.
	 * - `styles` is the style input data which can either be a call to {@link style style} or {@link
	 * keyframes keyframes}.
	 * If left empty then the styles from the destination state will be collected and used (this is
	 * useful when
	 * describing an animation step that will complete an animation by {@link
	 * transition#the-final-animate-call animating to the final state}).
	 *
	 * ```typescript
	 * // various functions for specifying timing data
	 * animate(500, style(...))
	 * animate("1s", style(...))
	 * animate("100ms 0.5s", style(...))
	 * animate("5s ease", style(...))
	 * animate("5s 10ms cubic-bezier(.17,.67,.88,.1)", style(...))
	 *
	 * // either style() of keyframes() can be used
	 * animate(500, style({ background: "red" }))
	 * animate(500, keyframes([
	 *   style({ background: "blue" })),
	 *   style({ background: "red" }))
	 * ])
	 * ```
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	 *
	 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * @experimental Animation support is experimental.
	 */
	function animate(timing, styles) {
	    if (styles === void 0) { styles = null; }
	    var stylesEntry = styles;
	    if (!lang_1.isPresent(stylesEntry)) {
	        var EMPTY_STYLE = {};
	        stylesEntry = new AnimationStyleMetadata([EMPTY_STYLE], 1);
	    }
	    return new AnimationAnimateMetadata(timing, stylesEntry);
	}
	exports.animate = animate;
	/**
	 * `group` is an animation-specific function that is designed to be used inside of Angular2's
	 * animation
	 * DSL language. If this information is new, please navigate to the
	 * {@link ComponentMetadata#animations-anchor component animations metadata
	 * page} to gain a better understanding of how animations in Angular2 are used.
	 *
	 * `group` specifies a list of animation steps that are all run in parallel. Grouped animations
	 * are useful when a series of styles must be animated/closed off
	 * at different statrting/ending times.
	 *
	 * The `group` function can either be used within a {@link sequence sequence} or a {@link transition
	 * transition}
	 * and it will only continue to the next instruction once all of the inner animation steps
	 * have completed.
	 *
	 * ### Usage
	 *
	 * The `steps` data that is passed into the `group` animation function can either consist
	 * of {@link style style} or {@link animate animate} function calls. Each call to `style()` or
	 * `animate()`
	 * within a group will be executed instantly (use {@link keyframes keyframes} or a
	 * {@link animate#usage animate() with a delay value} to offset styles to be applied at a later
	 * time).
	 *
	 * ```typescript
	 * group([
	 *   animate("1s", { background: "black" }))
	 *   animate("2s", { color: "white" }))
	 * ])
	 * ```
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	 *
	 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * @experimental Animation support is experimental.
	 */
	function group(steps) {
	    return new AnimationGroupMetadata(steps);
	}
	exports.group = group;
	/**
	 * `sequence` is an animation-specific function that is designed to be used inside of Angular2's
	 * animation
	 * DSL language. If this information is new, please navigate to the
	 * {@link ComponentMetadata#animations-anchor component animations metadata
	 * page} to gain a better understanding of how animations in Angular2 are used.
	 *
	 * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used
	 * by default when an array is passed as animation data into {@link transition transition}.)
	 *
	 * The `sequence` function can either be used within a {@link group group} or a {@link transition
	 * transition}
	 * and it will only continue to the next instruction once each of the inner animation steps
	 * have completed.
	 *
	 * To perform animation styling in parallel with other animation steps then
	 * have a look at the {@link group group} animation function.
	 *
	 * ### Usage
	 *
	 * The `steps` data that is passed into the `sequence` animation function can either consist
	 * of {@link style style} or {@link animate animate} function calls. A call to `style()` will apply
	 * the
	 * provided styling data immediately while a call to `animate()` will apply its styling
	 * data over a given time depending on its timing data.
	 *
	 * ```typescript
	 * sequence([
	 *   style({ opacity: 0 })),
	 *   animate("1s", { opacity: 1 }))
	 * ])
	 * ```
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	 *
	 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * @experimental Animation support is experimental.
	 */
	function sequence(steps) {
	    return new AnimationSequenceMetadata(steps);
	}
	exports.sequence = sequence;
	/**
	 * `style` is an animation-specific function that is designed to be used inside of Angular2's
	 * animation
	 * DSL language. If this information is new, please navigate to the
	 * {@link ComponentMetadata#animations-anchor component animations metadata
	 * page} to gain a better understanding of how animations in Angular2 are used.
	 *
	 * `style` declares a key/value object containing CSS properties/styles that can then
	 * be used for {@link state animation states}, within an {@link sequence animation sequence}, or as
	 * styling data for both {@link animate animate} and {@link keyframes keyframes}.
	 *
	 * ### Usage
	 *
	 * `style` takes in a key/value string map as data and expects one or more CSS property/value
	 * pairs to be defined.
	 *
	 * ```typescript
	 * // string values are used for css properties
	 * style({ background: "red", color: "blue" })
	 *
	 * // numerical (pixel) values are also supported
	 * style({ width: 100, height: 0 })
	 * ```
	 *
	 * #### Auto-styles (using `*`)
	 *
	 * When an asterix (`*`) character is used as a value then it will be detected from the element
	 * being animated
	 * and applied as animation data when the animation starts.
	 *
	 * This feature proves useful for a state depending on layout and/or environment factors; in such
	 * cases
	 * the styles are calculated just before the animation starts.
	 *
	 * ```typescript
	 * // the steps below will animate from 0 to the
	 * // actual height of the element
	 * style({ height: 0 }),
	 * animate("1s", style({ height: "*" }))
	 * ```
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	 *
	 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * @experimental Animation support is experimental.
	 */
	function style(tokens) {
	    var input;
	    var offset = null;
	    if (lang_1.isString(tokens)) {
	        input = [tokens];
	    }
	    else {
	        if (lang_1.isArray(tokens)) {
	            input = tokens;
	        }
	        else {
	            input = [tokens];
	        }
	        input.forEach(function (entry) {
	            var entryOffset = entry['offset'];
	            if (lang_1.isPresent(entryOffset)) {
	                offset = offset == null ? lang_1.NumberWrapper.parseFloat(entryOffset) : offset;
	            }
	        });
	    }
	    return new AnimationStyleMetadata(input, offset);
	}
	exports.style = style;
	/**
	 * `state` is an animation-specific function that is designed to be used inside of Angular2's
	 * animation
	 * DSL language. If this information is new, please navigate to the
	 * {@link ComponentMetadata#animations-anchor component animations metadata
	 * page} to gain a better understanding of how animations in Angular2 are used.
	 *
	 * `state` declares an animation state within the given trigger. When a state is
	 * active within a component then its associated styles will persist on
	 * the element that the trigger is attached to (even when the animation ends).
	 *
	 * To animate between states, have a look at the animation {@link transition transition}
	 * DSL function. To register states to an animation trigger please have a look
	 * at the {@link trigger trigger} function.
	 *
	 * #### The `void` state
	 *
	 * The `void` state value is a reserved word that angular uses to determine when the element is not
	 * apart
	 * of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the
	 * associated element
	 * is void).
	 *
	 * #### The `*` (default) state
	 *
	 * The `*` state (when styled) is a fallback state that will be used if
	 * the state that is being animated is not declared within the trigger.
	 *
	 * ### Usage
	 *
	 * `state` will declare an animation state with its associated styles
	 * within the given trigger.
	 *
	 * - `stateNameExpr` can be one or more state names separated by commas.
	 * - `styles` refers to the {@link style styling data} that will be persisted on the element once
	 * the state
	 * has been reached.
	 *
	 * ```typescript
	 * // "void" is a reserved name for a state and is used to represent
	 * // the state in which an element is detached from from the application.
	 * state("void", style({ height: 0 }))
	 *
	 * // user-defined states
	 * state("closed", style({ height: 0 }))
	 * state("open, visible", style({ height: "*" }))
	 * ```
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	 *
	 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * @experimental Animation support is experimental.
	 */
	function state(stateNameExpr, styles) {
	    return new AnimationStateDeclarationMetadata(stateNameExpr, styles);
	}
	exports.state = state;
	/**
	 * `keyframes` is an animation-specific function that is designed to be used inside of Angular2's
	 * animation
	 * DSL language. If this information is new, please navigate to the
	 * {@link ComponentMetadata#animations-anchor component animations metadata
	 * page} to gain a better understanding of how animations in Angular2 are used.
	 *
	 * `keyframes` specifies a collection of {@link style style} entries each optionally characterized
	 * by an `offset` value.
	 *
	 * ### Usage
	 *
	 * The `keyframes` animation function is designed to be used alongside the {@link animate animate}
	 * animation function. Instead of applying animations from where they are
	 * currently to their destination, keyframes can describe how each style entry is applied
	 * and at what point within the animation arc (much like CSS Keyframe Animations do).
	 *
	 * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at
	 * what percentage of the animate time the styles will be applied.
	 *
	 * ```typescript
	 * // the provided offset values describe when each backgroundColor value is applied.
	 * animate("5s", keyframes([
	 *   style({ backgroundColor: "red", offset: 0 }),
	 *   style({ backgroundColor: "blue", offset: 0.2 }),
	 *   style({ backgroundColor: "orange", offset: 0.3 }),
	 *   style({ backgroundColor: "black", offset: 1 })
	 * ]))
	 * ```
	 *
	 * Alternatively, if there are no `offset` values used within the style entries then the offsets
	 * will
	 * be calculated automatically.
	 *
	 * ```typescript
	 * animate("5s", keyframes([
	 *   style({ backgroundColor: "red" }) // offset = 0
	 *   style({ backgroundColor: "blue" }) // offset = 0.33
	 *   style({ backgroundColor: "orange" }) // offset = 0.66
	 *   style({ backgroundColor: "black" }) // offset = 1
	 * ]))
	 * ```
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	 *
	 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * @experimental Animation support is experimental.
	 */
	function keyframes(steps) {
	    return new AnimationKeyframesSequenceMetadata(steps);
	}
	exports.keyframes = keyframes;
	/**
	 * `transition` is an animation-specific function that is designed to be used inside of Angular2's
	 * animation
	 * DSL language. If this information is new, please navigate to the
	 * {@link ComponentMetadata#animations-anchor component animations metadata
	 * page} to gain a better understanding of how animations in Angular2 are used.
	 *
	 * `transition` declares the {@link sequence sequence of animation steps} that will be run when the
	 * provided
	 * `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 => state2`
	 * which consists
	 * of two known states (use an asterix (`*`) to refer to a dynamic starting and/or ending state).
	 *
	 * Animation transitions are placed within an {@link trigger animation trigger}. For an transition
	 * to animate to
	 * a state value and persist its styles then one or more {@link state animation states} is expected
	 * to be defined.
	 *
	 * ### Usage
	 *
	 * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on
	 * what the
	 * previous state is and what the current state has become. In other words, if a transition is
	 * defined that
	 * matches the old/current state criteria then the associated animation will be triggered.
	 *
	 * ```typescript
	 * // all transition/state changes are defined within an animation trigger
	 * trigger("myAnimationTrigger", [
	 *   // if a state is defined then its styles will be persisted when the
	 *   // animation has fully completed itself
	 *   state("on", style({ background: "green" })),
	 *   state("off", style({ background: "grey" })),
	 *
	 *   // a transition animation that will be kicked off when the state value
	 *   // bound to "myAnimationTrigger" changes from "on" to "off"
	 *   transition("on => off", animate(500)),
	 *
	 *   // it is also possible to do run the same animation for both directions
	 *   transition("on <=> off", animate(500)),
	 *
	 *   // or to define multiple states pairs separated by commas
	 *   transition("on => off, off => void", animate(500)),
	 *
	 *   // this is a catch-all state change for when an element is inserted into
	 *   // the page and the destination state is unknown
	 *   transition("void => *", [
	 *     style({ opacity: 0 }),
	 *     animate(500)
	 *   ]),
	 *
	 *   // this will capture a state change between any states
	 *   transition("* => *", animate("1s 0s")),
	 * ])
	 * ```
	 *
	 * The template associated with this component will make use of the `myAnimationTrigger`
	 * animation trigger by binding to an element within its template code.
	 *
	 * ```html
	 * <!-- somewhere inside of my-component-tpl.html -->
	 * <div [@myAnimationTrigger]="myStatusExp">...</div>
	 * ```
	 *
	 * #### The final `animate` call
	 *
	 * If the final step within the transition steps is a call to `animate()` that **only**
	 * uses a timing value with **no style data** then it will be automatically used as the final
	 * animation
	 * arc for the element to animate itself to the final state. This involves an automatic mix of
	 * adding/removing CSS styles so that the element will be in the exact state it should be for the
	 * applied state to be presented correctly.
	 *
	 * ```
	 * // start off by hiding the element, but make sure that it animates properly to whatever state
	 * // is currently active for "myAnimationTrigger"
	 * transition("void => *", [
	 *   style({ opacity: 0 }),
	 *   animate(500)
	 * ])
	 * ```
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	 *
	 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * @experimental Animation support is experimental.
	 */
	function transition(stateChangeExpr, steps) {
	    var animationData = lang_1.isArray(steps) ? new AnimationSequenceMetadata(steps) :
	        steps;
	    return new AnimationStateTransitionMetadata(stateChangeExpr, animationData);
	}
	exports.transition = transition;
	/**
	 * `trigger` is an animation-specific function that is designed to be used inside of Angular2's
	 * animation
	 * DSL language. If this information is new, please navigate to the
	 * {@link ComponentMetadata#animations-anchor component animations metadata
	 * page} to gain a better understanding of how animations in Angular2 are used.
	 *
	 * `trigger` Creates an animation trigger which will a list of {@link state state} and {@link
	 * transition transition}
	 * entries that will be evaluated when the expression bound to the trigger changes.
	 *
	 * Triggers are registered within the component annotation data under the
	 * {@link ComponentMetadata#animations-anchor animations section}. An animation trigger can
	 * be placed on an element within a template by referencing the name of the
	 * trigger followed by the expression value that the trigger is bound to
	 * (in the form of `[@triggerName]="expression"`.
	 *
	 * ### Usage
	 *
	 * `trigger` will create an animation trigger reference based on the provided `name` value.
	 * The provided `animation` value is expected to be an array consisting of {@link state state} and
	 * {@link transition transition}
	 * declarations.
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'my-component',
	 *   templateUrl: 'my-component-tpl.html',
	 *   animations: [
	 *     trigger("myAnimationTrigger", [
	 *       state(...),
	 *       state(...),
	 *       transition(...),
	 *       transition(...)
	 *     ])
	 *   ]
	 * })
	 * class MyComponent {
	 *   myStatusExp = "something";
	 * }
	 * ```
	 *
	 * The template associated with this component will make use of the `myAnimationTrigger`
	 * animation trigger by binding to an element within its template code.
	 *
	 * ```html
	 * <!-- somewhere inside of my-component-tpl.html -->
	 * <div [@myAnimationTrigger]="myStatusExp">...</div>
	 * ```
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	 *
	 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * @experimental Animation support is experimental.
	 */
	function trigger(name, animation) {
	    return new AnimationEntryMetadata(name, animation);
	}
	exports.trigger = trigger;
	//# sourceMappingURL=metadata.js.map

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	var DefaultKeyValueDifferFactory = (function () {
	    function DefaultKeyValueDifferFactory() {
	    }
	    DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || lang_1.isJsObject(obj); };
	    DefaultKeyValueDifferFactory.prototype.create = function (cdRef) { return new DefaultKeyValueDiffer(); };
	    return DefaultKeyValueDifferFactory;
	}());
	exports.DefaultKeyValueDifferFactory = DefaultKeyValueDifferFactory;
	var DefaultKeyValueDiffer = (function () {
	    function DefaultKeyValueDiffer() {
	        this._records = new Map();
	        this._mapHead = null;
	        this._previousMapHead = null;
	        this._changesHead = null;
	        this._changesTail = null;
	        this._additionsHead = null;
	        this._additionsTail = null;
	        this._removalsHead = null;
	        this._removalsTail = null;
	    }
	    Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
	        get: function () {
	            return this._additionsHead !== null || this._changesHead !== null ||
	                this._removalsHead !== null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {
	        var record;
	        for (record = this._mapHead; record !== null; record = record._next) {
	            fn(record);
	        }
	    };
	    DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {
	        var record;
	        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
	            fn(record);
	        }
	    };
	    DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {
	        var record;
	        for (record = this._changesHead; record !== null; record = record._nextChanged) {
	            fn(record);
	        }
	    };
	    DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {
	        var record;
	        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	            fn(record);
	        }
	    };
	    DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {
	        var record;
	        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	            fn(record);
	        }
	    };
	    DefaultKeyValueDiffer.prototype.diff = function (map) {
	        if (!map) {
	            map = new Map();
	        }
	        else if (!(map instanceof Map || lang_1.isJsObject(map))) {
	            throw new exceptions_1.BaseException("Error trying to diff '" + map + "'");
	        }
	        return this.check(map) ? this : null;
	    };
	    DefaultKeyValueDiffer.prototype.onDestroy = function () { };
	    DefaultKeyValueDiffer.prototype.check = function (map) {
	        var _this = this;
	        this._reset();
	        var records = this._records;
	        var oldSeqRecord = this._mapHead;
	        var lastOldSeqRecord = null;
	        var lastNewSeqRecord = null;
	        var seqChanged = false;
	        this._forEach(map, function (value, key) {
	            var newSeqRecord;
	            if (oldSeqRecord && key === oldSeqRecord.key) {
	                newSeqRecord = oldSeqRecord;
	                _this._maybeAddToChanges(newSeqRecord, value);
	            }
	            else {
	                seqChanged = true;
	                if (oldSeqRecord !== null) {
	                    _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
	                    _this._addToRemovals(oldSeqRecord);
	                }
	                if (records.has(key)) {
	                    newSeqRecord = records.get(key);
	                    _this._maybeAddToChanges(newSeqRecord, value);
	                }
	                else {
	                    newSeqRecord = new KeyValueChangeRecord(key);
	                    records.set(key, newSeqRecord);
	                    newSeqRecord.currentValue = value;
	                    _this._addToAdditions(newSeqRecord);
	                }
	            }
	            if (seqChanged) {
	                if (_this._isInRemovals(newSeqRecord)) {
	                    _this._removeFromRemovals(newSeqRecord);
	                }
	                if (lastNewSeqRecord == null) {
	                    _this._mapHead = newSeqRecord;
	                }
	                else {
	                    lastNewSeqRecord._next = newSeqRecord;
	                }
	            }
	            lastOldSeqRecord = oldSeqRecord;
	            lastNewSeqRecord = newSeqRecord;
	            oldSeqRecord = oldSeqRecord && oldSeqRecord._next;
	        });
	        this._truncate(lastOldSeqRecord, oldSeqRecord);
	        return this.isDirty;
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._reset = function () {
	        if (this.isDirty) {
	            var record = void 0;
	            // Record the state of the mapping
	            for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
	                record._nextPrevious = record._next;
	            }
	            for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                record.previousValue = record.currentValue;
	            }
	            for (record = this._additionsHead; record != null; record = record._nextAdded) {
	                record.previousValue = record.currentValue;
	            }
	            this._changesHead = this._changesTail = null;
	            this._additionsHead = this._additionsTail = null;
	            this._removalsHead = this._removalsTail = null;
	        }
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._truncate = function (lastRecord, record) {
	        while (record !== null) {
	            if (lastRecord === null) {
	                this._mapHead = null;
	            }
	            else {
	                lastRecord._next = null;
	            }
	            var nextRecord = record._next;
	            this._addToRemovals(record);
	            lastRecord = record;
	            record = nextRecord;
	        }
	        for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
	            rec.previousValue = rec.currentValue;
	            rec.currentValue = null;
	            this._records.delete(rec.key);
	        }
	    };
	    DefaultKeyValueDiffer.prototype._maybeAddToChanges = function (record, newValue) {
	        if (!lang_1.looseIdentical(newValue, record.currentValue)) {
	            record.previousValue = record.currentValue;
	            record.currentValue = newValue;
	            this._addToChanges(record);
	        }
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._isInRemovals = function (record) {
	        return record === this._removalsHead || record._nextRemoved !== null ||
	            record._prevRemoved !== null;
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._addToRemovals = function (record) {
	        if (this._removalsHead === null) {
	            this._removalsHead = this._removalsTail = record;
	        }
	        else {
	            this._removalsTail._nextRemoved = record;
	            record._prevRemoved = this._removalsTail;
	            this._removalsTail = record;
	        }
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._removeFromSeq = function (prev, record) {
	        var next = record._next;
	        if (prev === null) {
	            this._mapHead = next;
	        }
	        else {
	            prev._next = next;
	        }
	        record._next = null;
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._removeFromRemovals = function (record) {
	        var prev = record._prevRemoved;
	        var next = record._nextRemoved;
	        if (prev === null) {
	            this._removalsHead = next;
	        }
	        else {
	            prev._nextRemoved = next;
	        }
	        if (next === null) {
	            this._removalsTail = prev;
	        }
	        else {
	            next._prevRemoved = prev;
	        }
	        record._prevRemoved = record._nextRemoved = null;
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {
	        if (this._additionsHead === null) {
	            this._additionsHead = this._additionsTail = record;
	        }
	        else {
	            this._additionsTail._nextAdded = record;
	            this._additionsTail = record;
	        }
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._addToChanges = function (record) {
	        if (this._changesHead === null) {
	            this._changesHead = this._changesTail = record;
	        }
	        else {
	            this._changesTail._nextChanged = record;
	            this._changesTail = record;
	        }
	    };
	    DefaultKeyValueDiffer.prototype.toString = function () {
	        var items = [];
	        var previous = [];
	        var changes = [];
	        var additions = [];
	        var removals = [];
	        var record;
	        for (record = this._mapHead; record !== null; record = record._next) {
	            items.push(lang_1.stringify(record));
	        }
	        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
	            previous.push(lang_1.stringify(record));
	        }
	        for (record = this._changesHead; record !== null; record = record._nextChanged) {
	            changes.push(lang_1.stringify(record));
	        }
	        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	            additions.push(lang_1.stringify(record));
	        }
	        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	            removals.push(lang_1.stringify(record));
	        }
	        return 'map: ' + items.join(', ') + '\n' +
	            'previous: ' + previous.join(', ') + '\n' +
	            'additions: ' + additions.join(', ') + '\n' +
	            'changes: ' + changes.join(', ') + '\n' +
	            'removals: ' + removals.join(', ') + '\n';
	    };
	    /** @internal */
	    DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {
	        if (obj instanceof Map) {
	            obj.forEach(fn);
	        }
	        else {
	            collection_1.StringMapWrapper.forEach(obj, fn);
	        }
	    };
	    return DefaultKeyValueDiffer;
	}());
	exports.DefaultKeyValueDiffer = DefaultKeyValueDiffer;
	/**
	 * @stable
	 */
	var KeyValueChangeRecord = (function () {
	    function KeyValueChangeRecord(key) {
	        this.key = key;
	        this.previousValue = null;
	        this.currentValue = null;
	        /** @internal */
	        this._nextPrevious = null;
	        /** @internal */
	        this._next = null;
	        /** @internal */
	        this._nextAdded = null;
	        /** @internal */
	        this._nextRemoved = null;
	        /** @internal */
	        this._prevRemoved = null;
	        /** @internal */
	        this._nextChanged = null;
	    }
	    KeyValueChangeRecord.prototype.toString = function () {
	        return lang_1.looseIdentical(this.previousValue, this.currentValue) ?
	            lang_1.stringify(this.key) :
	            (lang_1.stringify(this.key) + '[' + lang_1.stringify(this.previousValue) + '->' +
	                lang_1.stringify(this.currentValue) + ']');
	    };
	    return KeyValueChangeRecord;
	}());
	exports.KeyValueChangeRecord = KeyValueChangeRecord;
	//# sourceMappingURL=default_keyvalue_differ.js.map

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var di_1 = __webpack_require__(12);
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	/**
	 * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
	 * @stable
	 */
	var IterableDiffers = (function () {
	    function IterableDiffers(factories) {
	        this.factories = factories;
	    }
	    IterableDiffers.create = function (factories, parent) {
	        if (lang_1.isPresent(parent)) {
	            var copied = collection_1.ListWrapper.clone(parent.factories);
	            factories = factories.concat(copied);
	            return new IterableDiffers(factories);
	        }
	        else {
	            return new IterableDiffers(factories);
	        }
	    };
	    /**
	     * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
	     * inherited {@link IterableDiffers} instance with the provided factories and return a new
	     * {@link IterableDiffers} instance.
	     *
	     * The following example shows how to extend an existing list of factories,
	           * which will only be applied to the injector for this component and its children.
	           * This step is all that's required to make a new {@link IterableDiffer} available.
	     *
	     * ### Example
	     *
	     * ```
	     * @Component({
	     *   viewProviders: [
	     *     IterableDiffers.extend([new ImmutableListDiffer()])
	     *   ]
	     * })
	     * ```
	     */
	    IterableDiffers.extend = function (factories) {
	        return new di_1.Provider(IterableDiffers, {
	            useFactory: function (parent) {
	                if (lang_1.isBlank(parent)) {
	                    // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
	                    // to
	                    // bootstrap(), which would override default pipes instead of extending them.
	                    throw new exceptions_1.BaseException('Cannot extend IterableDiffers without a parent injector');
	                }
	                return IterableDiffers.create(factories, parent);
	            },
	            // Dependency technically isn't optional, but we can provide a better error message this way.
	            deps: [[IterableDiffers, new di_1.SkipSelfMetadata(), new di_1.OptionalMetadata()]]
	        });
	    };
	    IterableDiffers.prototype.find = function (iterable) {
	        var factory = this.factories.find(function (f) { return f.supports(iterable); });
	        if (lang_1.isPresent(factory)) {
	            return factory;
	        }
	        else {
	            throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + iterable + "' of type '" + lang_1.getTypeNameForDebugging(iterable) + "'");
	        }
	    };
	    return IterableDiffers;
	}());
	exports.IterableDiffers = IterableDiffers;
	//# sourceMappingURL=iterable_differs.js.map

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var di_1 = __webpack_require__(12);
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	/**
	 * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
	 * @stable
	 */
	var KeyValueDiffers = (function () {
	    function KeyValueDiffers(factories) {
	        this.factories = factories;
	    }
	    KeyValueDiffers.create = function (factories, parent) {
	        if (lang_1.isPresent(parent)) {
	            var copied = collection_1.ListWrapper.clone(parent.factories);
	            factories = factories.concat(copied);
	            return new KeyValueDiffers(factories);
	        }
	        else {
	            return new KeyValueDiffers(factories);
	        }
	    };
	    /**
	     * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
	     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
	     * {@link KeyValueDiffers} instance.
	     *
	     * The following example shows how to extend an existing list of factories,
	           * which will only be applied to the injector for this component and its children.
	           * This step is all that's required to make a new {@link KeyValueDiffer} available.
	     *
	     * ### Example
	     *
	     * ```
	     * @Component({
	     *   viewProviders: [
	     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
	     *   ]
	     * })
	     * ```
	     */
	    KeyValueDiffers.extend = function (factories) {
	        return new di_1.Provider(KeyValueDiffers, {
	            useFactory: function (parent) {
	                if (lang_1.isBlank(parent)) {
	                    // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
	                    // to
	                    // bootstrap(), which would override default pipes instead of extending them.
	                    throw new exceptions_1.BaseException('Cannot extend KeyValueDiffers without a parent injector');
	                }
	                return KeyValueDiffers.create(factories, parent);
	            },
	            // Dependency technically isn't optional, but we can provide a better error message this way.
	            deps: [[KeyValueDiffers, new di_1.SkipSelfMetadata(), new di_1.OptionalMetadata()]]
	        });
	    };
	    KeyValueDiffers.prototype.find = function (kv) {
	        var factory = this.factories.find(function (f) { return f.supports(kv); });
	        if (lang_1.isPresent(factory)) {
	            return factory;
	        }
	        else {
	            throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + kv + "'");
	        }
	    };
	    return KeyValueDiffers;
	}());
	exports.KeyValueDiffers = KeyValueDiffers;
	//# sourceMappingURL=keyvalue_differs.js.map

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var collection_1 = __webpack_require__(6);
	var lang_1 = __webpack_require__(2);
	var EventListener = (function () {
	    function EventListener(name, callback) {
	        this.name = name;
	        this.callback = callback;
	    }
	    ;
	    return EventListener;
	}());
	exports.EventListener = EventListener;
	/**
	 * @experimental All debugging apis are currently experimental.
	 */
	var DebugNode = (function () {
	    function DebugNode(nativeNode, parent, _debugInfo) {
	        this._debugInfo = _debugInfo;
	        this.nativeNode = nativeNode;
	        if (lang_1.isPresent(parent) && parent instanceof DebugElement) {
	            parent.addChild(this);
	        }
	        else {
	            this.parent = null;
	        }
	        this.listeners = [];
	    }
	    Object.defineProperty(DebugNode.prototype, "injector", {
	        get: function () { return lang_1.isPresent(this._debugInfo) ? this._debugInfo.injector : null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "componentInstance", {
	        get: function () {
	            return lang_1.isPresent(this._debugInfo) ? this._debugInfo.component : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "context", {
	        get: function () { return lang_1.isPresent(this._debugInfo) ? this._debugInfo.context : null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "references", {
	        get: function () {
	            return lang_1.isPresent(this._debugInfo) ? this._debugInfo.references : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "providerTokens", {
	        get: function () {
	            return lang_1.isPresent(this._debugInfo) ? this._debugInfo.providerTokens : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "source", {
	        get: function () { return lang_1.isPresent(this._debugInfo) ? this._debugInfo.source : null; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Use injector.get(token) instead.
	     *
	     * @deprecated
	     */
	    DebugNode.prototype.inject = function (token) { return this.injector.get(token); };
	    return DebugNode;
	}());
	exports.DebugNode = DebugNode;
	/**
	 * @experimental All debugging apis are currently experimental.
	 */
	var DebugElement = (function (_super) {
	    __extends(DebugElement, _super);
	    function DebugElement(nativeNode, parent, _debugInfo) {
	        _super.call(this, nativeNode, parent, _debugInfo);
	        this.properties = {};
	        this.attributes = {};
	        this.classes = {};
	        this.styles = {};
	        this.childNodes = [];
	        this.nativeElement = nativeNode;
	    }
	    DebugElement.prototype.addChild = function (child) {
	        if (lang_1.isPresent(child)) {
	            this.childNodes.push(child);
	            child.parent = this;
	        }
	    };
	    DebugElement.prototype.removeChild = function (child) {
	        var childIndex = this.childNodes.indexOf(child);
	        if (childIndex !== -1) {
	            child.parent = null;
	            this.childNodes.splice(childIndex, 1);
	        }
	    };
	    DebugElement.prototype.insertChildrenAfter = function (child, newChildren) {
	        var siblingIndex = this.childNodes.indexOf(child);
	        if (siblingIndex !== -1) {
	            var previousChildren = this.childNodes.slice(0, siblingIndex + 1);
	            var nextChildren = this.childNodes.slice(siblingIndex + 1);
	            this.childNodes =
	                collection_1.ListWrapper.concat(collection_1.ListWrapper.concat(previousChildren, newChildren), nextChildren);
	            for (var i = 0; i < newChildren.length; ++i) {
	                var newChild = newChildren[i];
	                if (lang_1.isPresent(newChild.parent)) {
	                    newChild.parent.removeChild(newChild);
	                }
	                newChild.parent = this;
	            }
	        }
	    };
	    DebugElement.prototype.query = function (predicate) {
	        var results = this.queryAll(predicate);
	        return results.length > 0 ? results[0] : null;
	    };
	    DebugElement.prototype.queryAll = function (predicate) {
	        var matches = [];
	        _queryElementChildren(this, predicate, matches);
	        return matches;
	    };
	    DebugElement.prototype.queryAllNodes = function (predicate) {
	        var matches = [];
	        _queryNodeChildren(this, predicate, matches);
	        return matches;
	    };
	    Object.defineProperty(DebugElement.prototype, "children", {
	        get: function () {
	            var children = [];
	            this.childNodes.forEach(function (node) {
	                if (node instanceof DebugElement) {
	                    children.push(node);
	                }
	            });
	            return children;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DebugElement.prototype.triggerEventHandler = function (eventName, eventObj) {
	        this.listeners.forEach(function (listener) {
	            if (listener.name == eventName) {
	                listener.callback(eventObj);
	            }
	        });
	    };
	    return DebugElement;
	}(DebugNode));
	exports.DebugElement = DebugElement;
	/**
	 * @experimental
	 */
	function asNativeElements(debugEls) {
	    return debugEls.map(function (el) { return el.nativeElement; });
	}
	exports.asNativeElements = asNativeElements;
	function _queryElementChildren(element, predicate, matches) {
	    element.childNodes.forEach(function (node) {
	        if (node instanceof DebugElement) {
	            if (predicate(node)) {
	                matches.push(node);
	            }
	            _queryElementChildren(node, predicate, matches);
	        }
	    });
	}
	function _queryNodeChildren(parentNode, predicate, matches) {
	    if (parentNode instanceof DebugElement) {
	        parentNode.childNodes.forEach(function (node) {
	            if (predicate(node)) {
	                matches.push(node);
	            }
	            if (node instanceof DebugElement) {
	                _queryNodeChildren(node, predicate, matches);
	            }
	        });
	    }
	}
	// Need to keep the nodes in a global Map so that multiple angular apps are supported.
	var _nativeNodeToDebugNode = new Map();
	/**
	 * @experimental
	 */
	function getDebugNode(nativeNode) {
	    return _nativeNodeToDebugNode.get(nativeNode);
	}
	exports.getDebugNode = getDebugNode;
	function getAllDebugNodes() {
	    return collection_1.MapWrapper.values(_nativeNodeToDebugNode);
	}
	exports.getAllDebugNodes = getAllDebugNodes;
	function indexDebugNode(node) {
	    _nativeNodeToDebugNode.set(node.nativeNode, node);
	}
	exports.indexDebugNode = indexDebugNode;
	function removeDebugNodeFromIndex(node) {
	    _nativeNodeToDebugNode.delete(node.nativeNode);
	}
	exports.removeDebugNodeFromIndex = removeDebugNodeFromIndex;
	//# sourceMappingURL=debug_node.js.map

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var decorators_1 = __webpack_require__(30); // so that metadata is gathered for this class
	var OpaqueToken = (function () {
	    function OpaqueToken(_desc) {
	        this._desc = _desc;
	    }
	    OpaqueToken.prototype.toString = function () { return "Token " + this._desc; };
	    /** @nocollapse */
	    OpaqueToken.decorators = [
	        { type: decorators_1.Injectable },
	    ];
	    /** @nocollapse */
	    OpaqueToken.ctorParameters = [
	        null,
	    ];
	    return OpaqueToken;
	}());
	exports.OpaqueToken = OpaqueToken;
	//# sourceMappingURL=opaque_token.js.map

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var provider_1 = __webpack_require__(89);
	function isProviderLiteral(obj) {
	    return obj && typeof obj == 'object' && obj.provide;
	}
	exports.isProviderLiteral = isProviderLiteral;
	function createProvider(obj) {
	    return new provider_1.Provider(obj.provide, obj);
	}
	exports.createProvider = createProvider;
	//# sourceMappingURL=provider_util.js.map

/***/ },
/* 148 */
123,
/* 149 */
[294, 148, 6, 2],
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	var view_utils_1 = __webpack_require__(56);
	/**
	 * Represents an instance of a Component created via a {@link ComponentFactory}.
	 *
	 * `ComponentRef` provides access to the Component Instance as well other objects related to this
	 * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}
	 * method.
	 * @stable
	 */
	var ComponentRef = (function () {
	    function ComponentRef() {
	    }
	    Object.defineProperty(ComponentRef.prototype, "location", {
	        /**
	         * Location of the Host Element of this Component Instance.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentRef.prototype, "injector", {
	        /**
	         * The injector on which the component instance exists.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentRef.prototype, "instance", {
	        /**
	         * The instance of the Component.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(ComponentRef.prototype, "hostView", {
	        /**
	         * The {@link ViewRef} of the Host View of this Component instance.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(ComponentRef.prototype, "changeDetectorRef", {
	        /**
	         * The {@link ChangeDetectorRef} of the Component instance.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentRef.prototype, "componentType", {
	        /**
	         * The component type.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    return ComponentRef;
	}());
	exports.ComponentRef = ComponentRef;
	var ComponentRef_ = (function (_super) {
	    __extends(ComponentRef_, _super);
	    function ComponentRef_(_hostElement, _componentType) {
	        _super.call(this);
	        this._hostElement = _hostElement;
	        this._componentType = _componentType;
	    }
	    Object.defineProperty(ComponentRef_.prototype, "location", {
	        get: function () { return this._hostElement.elementRef; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentRef_.prototype, "injector", {
	        get: function () { return this._hostElement.injector; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentRef_.prototype, "instance", {
	        get: function () { return this._hostElement.component; },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(ComponentRef_.prototype, "hostView", {
	        get: function () { return this._hostElement.parentView.ref; },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(ComponentRef_.prototype, "changeDetectorRef", {
	        get: function () { return this._hostElement.parentView.ref; },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(ComponentRef_.prototype, "componentType", {
	        get: function () { return this._componentType; },
	        enumerable: true,
	        configurable: true
	    });
	    ComponentRef_.prototype.destroy = function () { this._hostElement.parentView.destroy(); };
	    ComponentRef_.prototype.onDestroy = function (callback) { this.hostView.onDestroy(callback); };
	    return ComponentRef_;
	}(ComponentRef));
	exports.ComponentRef_ = ComponentRef_;
	/**
	 * @experimental
	 */
	var EMPTY_CONTEXT = new Object();
	/**
	 * @stable
	 */
	var ComponentFactory = (function () {
	    function ComponentFactory(selector, _viewFactory, _componentType) {
	        this.selector = selector;
	        this._viewFactory = _viewFactory;
	        this._componentType = _componentType;
	    }
	    Object.defineProperty(ComponentFactory.prototype, "componentType", {
	        get: function () { return this._componentType; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Creates a new component.
	     */
	    ComponentFactory.prototype.create = function (injector, projectableNodes, rootSelectorOrNode) {
	        if (projectableNodes === void 0) { projectableNodes = null; }
	        if (rootSelectorOrNode === void 0) { rootSelectorOrNode = null; }
	        var vu = injector.get(view_utils_1.ViewUtils);
	        if (lang_1.isBlank(projectableNodes)) {
	            projectableNodes = [];
	        }
	        // Note: Host views don't need a declarationAppElement!
	        var hostView = this._viewFactory(vu, injector, null);
	        var hostElement = hostView.create(EMPTY_CONTEXT, projectableNodes, rootSelectorOrNode);
	        return new ComponentRef_(hostElement, this._componentType);
	    };
	    return ComponentFactory;
	}());
	exports.ComponentFactory = ComponentFactory;
	//# sourceMappingURL=component_factory.js.map

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var lang_1 = __webpack_require__(2);
	var view_type_1 = __webpack_require__(55);
	var StaticNodeDebugInfo = (function () {
	    function StaticNodeDebugInfo(providerTokens, componentToken, refTokens) {
	        this.providerTokens = providerTokens;
	        this.componentToken = componentToken;
	        this.refTokens = refTokens;
	    }
	    return StaticNodeDebugInfo;
	}());
	exports.StaticNodeDebugInfo = StaticNodeDebugInfo;
	var DebugContext = (function () {
	    function DebugContext(_view, _nodeIndex, _tplRow, _tplCol) {
	        this._view = _view;
	        this._nodeIndex = _nodeIndex;
	        this._tplRow = _tplRow;
	        this._tplCol = _tplCol;
	    }
	    Object.defineProperty(DebugContext.prototype, "_staticNodeInfo", {
	        get: function () {
	            return lang_1.isPresent(this._nodeIndex) ? this._view.staticNodeDebugInfos[this._nodeIndex] : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext.prototype, "context", {
	        get: function () { return this._view.context; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext.prototype, "component", {
	        get: function () {
	            var staticNodeInfo = this._staticNodeInfo;
	            if (lang_1.isPresent(staticNodeInfo) && lang_1.isPresent(staticNodeInfo.componentToken)) {
	                return this.injector.get(staticNodeInfo.componentToken);
	            }
	            return null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext.prototype, "componentRenderElement", {
	        get: function () {
	            var componentView = this._view;
	            while (lang_1.isPresent(componentView.declarationAppElement) &&
	                componentView.type !== view_type_1.ViewType.COMPONENT) {
	                componentView = componentView.declarationAppElement.parentView;
	            }
	            return lang_1.isPresent(componentView.declarationAppElement) ?
	                componentView.declarationAppElement.nativeElement :
	                null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext.prototype, "injector", {
	        get: function () { return this._view.injector(this._nodeIndex); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext.prototype, "renderNode", {
	        get: function () {
	            if (lang_1.isPresent(this._nodeIndex) && this._view.allNodes) {
	                return this._view.allNodes[this._nodeIndex];
	            }
	            else {
	                return null;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext.prototype, "providerTokens", {
	        get: function () {
	            var staticNodeInfo = this._staticNodeInfo;
	            return lang_1.isPresent(staticNodeInfo) ? staticNodeInfo.providerTokens : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext.prototype, "source", {
	        get: function () {
	            return this._view.componentType.templateUrl + ":" + this._tplRow + ":" + this._tplCol;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext.prototype, "references", {
	        get: function () {
	            var _this = this;
	            var varValues = {};
	            var staticNodeInfo = this._staticNodeInfo;
	            if (lang_1.isPresent(staticNodeInfo)) {
	                var refs = staticNodeInfo.refTokens;
	                collection_1.StringMapWrapper.forEach(refs, function (refToken, refName) {
	                    var varValue;
	                    if (lang_1.isBlank(refToken)) {
	                        varValue = _this._view.allNodes ? _this._view.allNodes[_this._nodeIndex] : null;
	                    }
	                    else {
	                        varValue = _this._view.injectorGet(refToken, _this._nodeIndex, null);
	                    }
	                    varValues[refName] = varValue;
	                });
	            }
	            return varValues;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return DebugContext;
	}());
	exports.DebugContext = DebugContext;
	//# sourceMappingURL=debug_context.js.map

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var di_1 = __webpack_require__(12);
	var lang_1 = __webpack_require__(2);
	var compiler_1 = __webpack_require__(31);
	/**
	 * Use ComponentFactoryResolver and ViewContainerRef directly.
	 *
	 * @deprecated
	 */
	var DynamicComponentLoader = (function () {
	    function DynamicComponentLoader() {
	    }
	    return DynamicComponentLoader;
	}());
	exports.DynamicComponentLoader = DynamicComponentLoader;
	var DynamicComponentLoader_ = (function (_super) {
	    __extends(DynamicComponentLoader_, _super);
	    function DynamicComponentLoader_(_compiler) {
	        _super.call(this);
	        this._compiler = _compiler;
	    }
	    DynamicComponentLoader_.prototype.loadAsRoot = function (type, overrideSelectorOrNode, injector, onDispose, projectableNodes) {
	        return this._compiler.compileComponentAsync(type).then(function (componentFactory) {
	            var componentRef = componentFactory.create(injector, projectableNodes, lang_1.isPresent(overrideSelectorOrNode) ? overrideSelectorOrNode : componentFactory.selector);
	            if (lang_1.isPresent(onDispose)) {
	                componentRef.onDestroy(onDispose);
	            }
	            return componentRef;
	        });
	    };
	    DynamicComponentLoader_.prototype.loadNextToLocation = function (type, location, providers, projectableNodes) {
	        if (providers === void 0) { providers = null; }
	        if (projectableNodes === void 0) { projectableNodes = null; }
	        return this._compiler.compileComponentAsync(type).then(function (componentFactory) {
	            var contextInjector = location.parentInjector;
	            var childInjector = lang_1.isPresent(providers) && providers.length > 0 ?
	                di_1.ReflectiveInjector.fromResolvedProviders(providers, contextInjector) :
	                contextInjector;
	            return location.createComponent(componentFactory, location.length, childInjector, projectableNodes);
	        });
	    };
	    /** @nocollapse */
	    DynamicComponentLoader_.decorators = [
	        { type: di_1.Injectable },
	    ];
	    /** @nocollapse */
	    DynamicComponentLoader_.ctorParameters = [
	        { type: compiler_1.Compiler, },
	    ];
	    return DynamicComponentLoader_;
	}(DynamicComponentLoader));
	exports.DynamicComponentLoader_ = DynamicComponentLoader_;
	//# sourceMappingURL=dynamic_component_loader.js.map

/***/ },
/* 153 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * A wrapper around a native element inside of a View.
	 *
	 * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
	 * element.
	 *
	 * @security Permitting direct access to the DOM can make your application more vulnerable to
	 * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the
	 * [Security Guide](http://g.co/ng/security).
	 *
	 * @stable
	 */
	// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,
	// i.e. users have to ask for what they need. With that, we can build better analysis tools
	// and could do better codegen in the future.
	var ElementRef = (function () {
	    function ElementRef(nativeElement) {
	        this.nativeElement = nativeElement;
	    }
	    return ElementRef;
	}());
	exports.ElementRef = ElementRef;
	//# sourceMappingURL=element_ref.js.map

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var injector_1 = __webpack_require__(53);
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	var component_factory_resolver_1 = __webpack_require__(54);
	/**
	 * Represents an instance of an NgModule created via a {@link NgModuleFactory}.
	 *
	 * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this
	 * NgModule Instance.
	 *
	 * @experimental
	 */
	var NgModuleRef = (function () {
	    function NgModuleRef() {
	    }
	    Object.defineProperty(NgModuleRef.prototype, "injector", {
	        /**
	         * The injector that contains all of the providers of the NgModule.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgModuleRef.prototype, "componentFactoryResolver", {
	        /**
	         * The ComponentFactoryResolver to get hold of the ComponentFactories
	         * delcared in the `entryComponents` property of the module.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgModuleRef.prototype, "instance", {
	        /**
	         * The NgModule instance.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    return NgModuleRef;
	}());
	exports.NgModuleRef = NgModuleRef;
	/**
	 * @experimental
	 */
	var NgModuleFactory = (function () {
	    function NgModuleFactory(_injectorClass, _moduleype) {
	        this._injectorClass = _injectorClass;
	        this._moduleype = _moduleype;
	    }
	    Object.defineProperty(NgModuleFactory.prototype, "moduleType", {
	        get: function () { return this._moduleype; },
	        enumerable: true,
	        configurable: true
	    });
	    NgModuleFactory.prototype.create = function (parentInjector) {
	        if (!parentInjector) {
	            parentInjector = injector_1.Injector.NULL;
	        }
	        var instance = new this._injectorClass(parentInjector);
	        instance.create();
	        return instance;
	    };
	    return NgModuleFactory;
	}());
	exports.NgModuleFactory = NgModuleFactory;
	var _UNDEFINED = new Object();
	var NgModuleInjector = (function (_super) {
	    __extends(NgModuleInjector, _super);
	    function NgModuleInjector(parent, factories, bootstrapFactories) {
	        _super.call(this, factories, parent.get(component_factory_resolver_1.ComponentFactoryResolver, component_factory_resolver_1.ComponentFactoryResolver.NULL));
	        this.parent = parent;
	        this.bootstrapFactories = bootstrapFactories;
	        this._destroyListeners = [];
	        this._destroyed = false;
	    }
	    NgModuleInjector.prototype.create = function () { this.instance = this.createInternal(); };
	    NgModuleInjector.prototype.get = function (token, notFoundValue) {
	        if (notFoundValue === void 0) { notFoundValue = injector_1.THROW_IF_NOT_FOUND; }
	        if (token === injector_1.Injector || token === component_factory_resolver_1.ComponentFactoryResolver) {
	            return this;
	        }
	        var result = this.getInternal(token, _UNDEFINED);
	        return result === _UNDEFINED ? this.parent.get(token, notFoundValue) : result;
	    };
	    Object.defineProperty(NgModuleInjector.prototype, "injector", {
	        get: function () { return this; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgModuleInjector.prototype, "componentFactoryResolver", {
	        get: function () { return this; },
	        enumerable: true,
	        configurable: true
	    });
	    NgModuleInjector.prototype.destroy = function () {
	        if (this._destroyed) {
	            throw new exceptions_1.BaseException("The ng module " + lang_1.stringify(this.instance.constructor) + " has already been destroyed.");
	        }
	        this._destroyed = true;
	        this.destroyInternal();
	        this._destroyListeners.forEach(function (listener) { return listener(); });
	    };
	    NgModuleInjector.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
	    return NgModuleInjector;
	}(component_factory_resolver_1.CodegenComponentFactoryResolver));
	exports.NgModuleInjector = NgModuleInjector;
	//# sourceMappingURL=ng_module_factory.js.map

/***/ },
/* 155 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Represents an Embedded Template that can be used to instantiate Embedded Views.
	 *
	 * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or
	 * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the
	 * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the
	 * `TemplateRef` from a Component or a Directive via {@link Query}.
	 *
	 * To instantiate Embedded Views based on a Template, use
	 * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
	 * View Container.
	 * @stable
	 */
	var TemplateRef = (function () {
	    function TemplateRef() {
	    }
	    Object.defineProperty(TemplateRef.prototype, "elementRef", {
	        /**
	         * The location in the View where the Embedded View logically belongs to.
	         *
	         * The data-binding and injection contexts of Embedded Views created from this `TemplateRef`
	         * inherit from the contexts of this location.
	         *
	         * Typically new Embedded Views are attached to the View Container of this location, but in
	         * advanced use-cases, the View can be attached to a different container while keeping the
	         * data-binding and injection context from the original location.
	         *
	         */
	        // TODO(i): rename to anchor or location
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    return TemplateRef;
	}());
	exports.TemplateRef = TemplateRef;
	var TemplateRef_ = (function (_super) {
	    __extends(TemplateRef_, _super);
	    function TemplateRef_(_appElement, _viewFactory) {
	        _super.call(this);
	        this._appElement = _appElement;
	        this._viewFactory = _viewFactory;
	    }
	    TemplateRef_.prototype.createEmbeddedView = function (context) {
	        var view = this._viewFactory(this._appElement.parentView.viewUtils, this._appElement.parentInjector, this._appElement);
	        view.create(context || {}, null, null);
	        return view.ref;
	    };
	    Object.defineProperty(TemplateRef_.prototype, "elementRef", {
	        get: function () { return this._appElement.elementRef; },
	        enumerable: true,
	        configurable: true
	    });
	    return TemplateRef_;
	}(TemplateRef));
	exports.TemplateRef_ = TemplateRef_;
	//# sourceMappingURL=template_ref.js.map

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	var profile_1 = __webpack_require__(57);
	/**
	 * Represents a container where one or more Views can be attached.
	 *
	 * The container can contain two kinds of Views. Host Views, created by instantiating a
	 * {@link Component} via {@link #createComponent}, and Embedded Views, created by instantiating an
	 * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.
	 *
	 * The location of the View Container within the containing View is specified by the Anchor
	 * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
	 * have a single View Container.
	 *
	 * Root elements of Views attached to this container become siblings of the Anchor Element in
	 * the Rendered View.
	 *
	 * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected
	 * with `ViewContainerRef` on the Element, or you obtain it via a {@link ViewChild} query.
	 * @stable
	 */
	var ViewContainerRef = (function () {
	    function ViewContainerRef() {
	    }
	    Object.defineProperty(ViewContainerRef.prototype, "element", {
	        /**
	         * Anchor element that specifies the location of this container in the containing View.
	         * <!-- TODO: rename to anchorElement -->
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewContainerRef.prototype, "injector", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewContainerRef.prototype, "parentInjector", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewContainerRef.prototype, "length", {
	        /**
	         * Returns the number of Views currently attached to this container.
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    return ViewContainerRef;
	}());
	exports.ViewContainerRef = ViewContainerRef;
	var ViewContainerRef_ = (function () {
	    function ViewContainerRef_(_element) {
	        this._element = _element;
	        /** @internal */
	        this._createComponentInContainerScope = profile_1.wtfCreateScope('ViewContainerRef#createComponent()');
	        /** @internal */
	        this._insertScope = profile_1.wtfCreateScope('ViewContainerRef#insert()');
	        /** @internal */
	        this._removeScope = profile_1.wtfCreateScope('ViewContainerRef#remove()');
	        /** @internal */
	        this._detachScope = profile_1.wtfCreateScope('ViewContainerRef#detach()');
	    }
	    ViewContainerRef_.prototype.get = function (index) { return this._element.nestedViews[index].ref; };
	    Object.defineProperty(ViewContainerRef_.prototype, "length", {
	        get: function () {
	            var views = this._element.nestedViews;
	            return lang_1.isPresent(views) ? views.length : 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewContainerRef_.prototype, "element", {
	        get: function () { return this._element.elementRef; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewContainerRef_.prototype, "injector", {
	        get: function () { return this._element.injector; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewContainerRef_.prototype, "parentInjector", {
	        get: function () { return this._element.parentInjector; },
	        enumerable: true,
	        configurable: true
	    });
	    // TODO(rado): profile and decide whether bounds checks should be added
	    // to the methods below.
	    ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {
	        if (context === void 0) { context = null; }
	        if (index === void 0) { index = -1; }
	        var viewRef = templateRef.createEmbeddedView(context);
	        this.insert(viewRef, index);
	        return viewRef;
	    };
	    ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes) {
	        if (index === void 0) { index = -1; }
	        if (injector === void 0) { injector = null; }
	        if (projectableNodes === void 0) { projectableNodes = null; }
	        var s = this._createComponentInContainerScope();
	        var contextInjector = lang_1.isPresent(injector) ? injector : this._element.parentInjector;
	        var componentRef = componentFactory.create(contextInjector, projectableNodes);
	        this.insert(componentRef.hostView, index);
	        return profile_1.wtfLeave(s, componentRef);
	    };
	    // TODO(i): refactor insert+remove into move
	    ViewContainerRef_.prototype.insert = function (viewRef, index) {
	        if (index === void 0) { index = -1; }
	        var s = this._insertScope();
	        if (index == -1)
	            index = this.length;
	        var viewRef_ = viewRef;
	        this._element.attachView(viewRef_.internalView, index);
	        return profile_1.wtfLeave(s, viewRef_);
	    };
	    ViewContainerRef_.prototype.move = function (viewRef, currentIndex) {
	        var s = this._insertScope();
	        if (currentIndex == -1)
	            return;
	        var viewRef_ = viewRef;
	        this._element.moveView(viewRef_.internalView, currentIndex);
	        return profile_1.wtfLeave(s, viewRef_);
	    };
	    ViewContainerRef_.prototype.indexOf = function (viewRef) {
	        return collection_1.ListWrapper.indexOf(this._element.nestedViews, viewRef.internalView);
	    };
	    // TODO(i): rename to destroy
	    ViewContainerRef_.prototype.remove = function (index) {
	        if (index === void 0) { index = -1; }
	        var s = this._removeScope();
	        if (index == -1)
	            index = this.length - 1;
	        var view = this._element.detachView(index);
	        view.destroy();
	        // view is intentionally not returned to the client.
	        profile_1.wtfLeave(s);
	    };
	    // TODO(i): refactor insert+remove into move
	    ViewContainerRef_.prototype.detach = function (index) {
	        if (index === void 0) { index = -1; }
	        var s = this._detachScope();
	        if (index == -1)
	            index = this.length - 1;
	        var view = this._element.detachView(index);
	        return profile_1.wtfLeave(s, view.ref);
	    };
	    ViewContainerRef_.prototype.clear = function () {
	        for (var i = this.length - 1; i >= 0; i--) {
	            this.remove(i);
	        }
	    };
	    return ViewContainerRef_;
	}());
	exports.ViewContainerRef_ = ViewContainerRef_;
	//# sourceMappingURL=view_container_ref.js.map

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var constants_1 = __webpack_require__(50);
	var exceptions_1 = __webpack_require__(4);
	/**
	 * @stable
	 */
	var ViewRef = (function () {
	    function ViewRef() {
	    }
	    Object.defineProperty(ViewRef.prototype, "destroyed", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    return ViewRef;
	}());
	exports.ViewRef = ViewRef;
	/**
	 * Represents an Angular View.
	 *
	 * <!-- TODO: move the next two paragraphs to the dev guide -->
	 * A View is a fundamental building block of the application UI. It is the smallest grouping of
	 * Elements which are created and destroyed together.
	 *
	 * Properties of elements in a View can change, but the structure (number and order) of elements in
	 * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
	 * removing nested Views via a {@link ViewContainerRef}. Each View can contain many View Containers.
	 * <!-- /TODO -->
	 *
	 * ### Example
	 *
	 * Given this template...
	 *
	 * ```
	 * Count: {{items.length}}
	 * <ul>
	 *   <li *ngFor="let  item of items">{{item}}</li>
	 * </ul>
	 * ```
	 *
	 * We have two {@link TemplateRef}s:
	 *
	 * Outer {@link TemplateRef}:
	 * ```
	 * Count: {{items.length}}
	 * <ul>
	 *   <template ngFor let-item [ngForOf]="items"></template>
	 * </ul>
	 * ```
	 *
	 * Inner {@link TemplateRef}:
	 * ```
	 *   <li>{{item}}</li>
	 * ```
	 *
	 * Notice that the original template is broken down into two separate {@link TemplateRef}s.
	 *
	 * The outer/inner {@link TemplateRef}s are then assembled into views like so:
	 *
	 * ```
	 * <!-- ViewRef: outer-0 -->
	 * Count: 2
	 * <ul>
	 *   <template view-container-ref></template>
	 *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
	 *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
	 * </ul>
	 * <!-- /ViewRef: outer-0 -->
	 * ```
	 * @experimental
	 */
	var EmbeddedViewRef = (function (_super) {
	    __extends(EmbeddedViewRef, _super);
	    function EmbeddedViewRef() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(EmbeddedViewRef.prototype, "context", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EmbeddedViewRef.prototype, "rootNodes", {
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    return EmbeddedViewRef;
	}(ViewRef));
	exports.EmbeddedViewRef = EmbeddedViewRef;
	var ViewRef_ = (function () {
	    function ViewRef_(_view) {
	        this._view = _view;
	        this._view = _view;
	        this._originalMode = this._view.cdMode;
	    }
	    Object.defineProperty(ViewRef_.prototype, "internalView", {
	        get: function () { return this._view; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewRef_.prototype, "rootNodes", {
	        get: function () { return this._view.flatRootNodes; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewRef_.prototype, "context", {
	        get: function () { return this._view.context; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewRef_.prototype, "destroyed", {
	        get: function () { return this._view.destroyed; },
	        enumerable: true,
	        configurable: true
	    });
	    ViewRef_.prototype.markForCheck = function () { this._view.markPathToRootAsCheckOnce(); };
	    ViewRef_.prototype.detach = function () { this._view.cdMode = constants_1.ChangeDetectorStatus.Detached; };
	    ViewRef_.prototype.detectChanges = function () { this._view.detectChanges(false); };
	    ViewRef_.prototype.checkNoChanges = function () { this._view.detectChanges(true); };
	    ViewRef_.prototype.reattach = function () {
	        this._view.cdMode = this._originalMode;
	        this.markForCheck();
	    };
	    ViewRef_.prototype.onDestroy = function (callback) { this._view.disposables.push(callback); };
	    ViewRef_.prototype.destroy = function () { this._view.destroy(); };
	    return ViewRef_;
	}());
	exports.ViewRef_ = ViewRef_;
	//# sourceMappingURL=view_ref.js.map

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var di_1 = __webpack_require__(159);
	var directives_1 = __webpack_require__(160);
	var ng_module_1 = __webpack_require__(162);
	var decorators_1 = __webpack_require__(58);
	var di_2 = __webpack_require__(159);
	exports.ANALYZE_FOR_ENTRY_COMPONENTS = di_2.ANALYZE_FOR_ENTRY_COMPONENTS;
	exports.AttributeMetadata = di_2.AttributeMetadata;
	exports.ContentChildMetadata = di_2.ContentChildMetadata;
	exports.ContentChildrenMetadata = di_2.ContentChildrenMetadata;
	exports.QueryMetadata = di_2.QueryMetadata;
	exports.ViewChildMetadata = di_2.ViewChildMetadata;
	exports.ViewChildrenMetadata = di_2.ViewChildrenMetadata;
	exports.ViewQueryMetadata = di_2.ViewQueryMetadata;
	var directives_2 = __webpack_require__(160);
	exports.ComponentMetadata = directives_2.ComponentMetadata;
	exports.DirectiveMetadata = directives_2.DirectiveMetadata;
	exports.HostBindingMetadata = directives_2.HostBindingMetadata;
	exports.HostListenerMetadata = directives_2.HostListenerMetadata;
	exports.InputMetadata = directives_2.InputMetadata;
	exports.OutputMetadata = directives_2.OutputMetadata;
	exports.PipeMetadata = directives_2.PipeMetadata;
	var lifecycle_hooks_1 = __webpack_require__(161);
	exports.AfterContentChecked = lifecycle_hooks_1.AfterContentChecked;
	exports.AfterContentInit = lifecycle_hooks_1.AfterContentInit;
	exports.AfterViewChecked = lifecycle_hooks_1.AfterViewChecked;
	exports.AfterViewInit = lifecycle_hooks_1.AfterViewInit;
	exports.DoCheck = lifecycle_hooks_1.DoCheck;
	exports.OnChanges = lifecycle_hooks_1.OnChanges;
	exports.OnDestroy = lifecycle_hooks_1.OnDestroy;
	exports.OnInit = lifecycle_hooks_1.OnInit;
	var ng_module_2 = __webpack_require__(162);
	exports.CUSTOM_ELEMENTS_SCHEMA = ng_module_2.CUSTOM_ELEMENTS_SCHEMA;
	exports.NgModuleMetadata = ng_module_2.NgModuleMetadata;
	var view_1 = __webpack_require__(163);
	exports.ViewEncapsulation = view_1.ViewEncapsulation;
	exports.ViewMetadata = view_1.ViewMetadata;
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ComponentMetadata.
	/**
	 * Declare reusable UI building blocks for an application.
	 *
	 * Each Angular component requires a single `@Component` annotation. The `@Component`
	 * annotation specifies when a component is instantiated, and which properties and hostListeners it
	 * binds to.
	 *
	 * When a component is instantiated, Angular
	 * - creates a shadow DOM for the component.
	 * - loads the selected template into the shadow DOM.
	 * - creates all the injectable objects configured with `providers` and `viewProviders`.
	 *
	 * All template expressions and statements are then evaluated against the component instance.
	 *
	 * ## Lifecycle hooks
	 *
	 * When the component class implements some {@linkDocs guide/lifecycle-hooks} the
	 * callbacks are called by the change detection at defined points in time during the life of the
	 * component.
	 *
	 * ### Example
	 *
	 * {@example core/ts/metadata/metadata.ts region='component'}
	 * @stable
	 * @Annotation
	 */
	exports.Component = decorators_1.makeDecorator(directives_1.ComponentMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from DirectiveMetadata.
	/**
	 * Directives allow you to attach behavior to elements in the DOM.
	 *
	 * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.
	 *
	 * A directive consists of a single directive annotation and a controller class. When the
	 * directive's `selector` matches
	 * elements in the DOM, the following steps occur:
	 *
	 * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor
	 * arguments.
	 * 2. Angular instantiates directives for each matched element using `ElementInjector` in a
	 * depth-first order,
	 *    as declared in the HTML.
	 *
	 * ## Understanding How Injection Works
	 *
	 * There are three stages of injection resolution.
	 * - *Pre-existing Injectors*:
	 *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if
	 * the dependency was
	 *     specified as `@Optional`, returns `null`.
	 *   - The platform injector resolves browser singleton resources, such as: cookies, title,
	 * location, and others.
	 * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow
	 * the same parent-child hierarchy
	 *     as the component instances in the DOM.
	 * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each
	 * element has an `ElementInjector`
	 *     which follow the same parent-child hierarchy as the DOM elements themselves.
	 *
	 * When a template is instantiated, it also must instantiate the corresponding directives in a
	 * depth-first order. The
	 * current `ElementInjector` resolves the constructor dependencies for each directive.
	 *
	 * Angular then resolves dependencies as follows, according to the order in which they appear in the
	 * {@link ComponentMetadata}:
	 *
	 * 1. Dependencies on the current element
	 * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary
	 * 3. Dependencies on component injectors and their parents until it encounters the root component
	 * 4. Dependencies on pre-existing injectors
	 *
	 *
	 * The `ElementInjector` can inject other directives, element-specific special objects, or it can
	 * delegate to the parent
	 * injector.
	 *
	 * To inject other directives, declare the constructor parameter as:
	 * - `directive:DirectiveType`: a directive on the current element only
	 * - `@Host() directive:DirectiveType`: any directive that matches the type between the current
	 * element and the
	 *    Shadow DOM root.
	 * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child
	 * directives.
	 * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any
	 * child directives.
	 *
	 * To inject element-specific special objects, declare the constructor parameter as:
	 * - `element: ElementRef` to obtain a reference to logical element in the view.
	 * - `viewContainer: ViewContainerRef` to control child template instantiation, for
	 * {@link DirectiveMetadata} directives only
	 * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.
	 *
	 * ### Example
	 *
	 * The following example demonstrates how dependency injection resolves constructor arguments in
	 * practice.
	 *
	 *
	 * Assume this HTML template:
	 *
	 * ```
	 * <div dependency="1">
	 *   <div dependency="2">
	 *     <div dependency="3" my-directive>
	 *       <div dependency="4">
	 *         <div dependency="5"></div>
	 *       </div>
	 *       <div dependency="6"></div>
	 *     </div>
	 *   </div>
	 * </div>
	 * ```
	 *
	 * With the following `dependency` decorator and `SomeService` injectable class.
	 *
	 * ```
	 * @Injectable()
	 * class SomeService {
	 * }
	 *
	 * @Directive({
	 *   selector: '[dependency]',
	 *   inputs: [
	 *     'id: dependency'
	 *   ]
	 * })
	 * class Dependency {
	 *   id:string;
	 * }
	 * ```
	 *
	 * Let's step through the different ways in which `MyDirective` could be declared...
	 *
	 *
	 * ### No injection
	 *
	 * Here the constructor is declared with no arguments, therefore nothing is injected into
	 * `MyDirective`.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor() {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with no dependencies.
	 *
	 *
	 * ### Component-level injection
	 *
	 * Directives can inject any injectable instance from the closest component injector or any of its
	 * parents.
	 *
	 * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type
	 * from the parent
	 * component's injector.
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(someService: SomeService) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a dependency on `SomeService`.
	 *
	 *
	 * ### Injecting a directive from the current element
	 *
	 * Directives can inject other directives declared on the current element.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(dependency: Dependency) {
	 *     expect(dependency.id).toEqual(3);
	 *   }
	 * }
	 * ```
	 * This directive would be instantiated with `Dependency` declared at the same element, in this case
	 * `dependency="3"`.
	 *
	 * ### Injecting a directive from any ancestor elements
	 *
	 * Directives can inject other directives declared on any ancestor element (in the current Shadow
	 * DOM), i.e. on the current element, the
	 * parent element, or its parents.
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Host() dependency: Dependency) {
	 *     expect(dependency.id).toEqual(2);
	 *   }
	 * }
	 * ```
	 *
	 * `@Host` checks the current element, the parent, as well as its parents recursively. If
	 * `dependency="2"` didn't
	 * exist on the direct parent, this injection would
	 * have returned
	 * `dependency="1"`.
	 *
	 *
	 * ### Injecting a live collection of direct child directives
	 *
	 *
	 * A directive can also query for other child directives. Since parent directives are instantiated
	 * before child directives, a directive can't simply inject the list of child directives. Instead,
	 * the directive injects a {@link QueryList}, which updates its contents as children are added,
	 * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ngFor`, an
	 * `ngIf`, or an `ngSwitch`.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and
	 * 6. Here, `Dependency` 5 would not be included, because it is not a direct child.
	 *
	 * ### Injecting a live collection of descendant directives
	 *
	 * By passing the descendant flag to `@Query` above, we can include the children of the child
	 * elements.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.
	 *
	 * ### Optional injection
	 *
	 * The normal behavior of directives is to return an error when a specified dependency cannot be
	 * resolved. If you
	 * would like to inject `null` on unresolved dependency instead, you can annotate that dependency
	 * with `@Optional()`.
	 * This explicitly permits the author of a template to treat some of the surrounding directives as
	 * optional.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Optional() dependency:Dependency) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a `Dependency` directive found on the current element.
	 * If none can be
	 * found, the injector supplies `null` instead of throwing an error.
	 *
	 * ### Example
	 *
	 * Here we use a decorator directive to simply define basic tool-tip behavior.
	 *
	 * ```
	 * @Directive({
	 *   selector: '[tooltip]',
	 *   inputs: [
	 *     'text: tooltip'
	 *   ],
	 *   host: {
	 *     '(mouseenter)': 'onMouseEnter()',
	 *     '(mouseleave)': 'onMouseLeave()'
	 *   }
	 * })
	 * class Tooltip{
	 *   text:string;
	 *   overlay:Overlay; // NOT YET IMPLEMENTED
	 *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED
	 *
	 *   constructor(overlayManager:OverlayManager) {
	 *     this.overlayManager = overlayManager;
	 *   }
	 *
	 *   onMouseEnter() {
	 *     // exact signature to be determined
	 *     this.overlay = this.overlayManager.open(text, ...);
	 *   }
	 *
	 *   onMouseLeave() {
	 *     this.overlay.close();
	 *     this.overlay = null;
	 *   }
	 * }
	 * ```
	 * In our HTML template, we can then add this behavior to a `<div>` or any other element with the
	 * `tooltip` selector,
	 * like so:
	 *
	 * ```
	 * <div tooltip="some text here"></div>
	 * ```
	 *
	 * Directives can also control the instantiation, destruction, and positioning of inline template
	 * elements:
	 *
	 * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at
	 * runtime.
	 * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a
	 * location in the current view
	 * where these actions are performed.
	 *
	 * Views are always created as children of the current {@link ComponentMetadata}, and as siblings of
	 * the
	 * `<template>` element. Thus a
	 * directive in a child view cannot inject the directive that created it.
	 *
	 * Since directives that create views via ViewContainers are common in Angular, and using the full
	 * `<template>` element syntax is wordy, Angular
	 * also supports a shorthand notation: `<li *foo="bar">` and `<li template="foo: bar">` are
	 * equivalent.
	 *
	 * Thus,
	 *
	 * ```
	 * <ul>
	 *   <li *foo="bar" title="text"></li>
	 * </ul>
	 * ```
	 *
	 * Expands in use to:
	 *
	 * ```
	 * <ul>
	 *   <template [foo]="bar">
	 *     <li title="text"></li>
	 *   </template>
	 * </ul>
	 * ```
	 *
	 * Notice that although the shorthand places `*foo="bar"` within the `<li>` element, the binding for
	 * the directive
	 * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.
	 *
	 * ## Lifecycle hooks
	 *
	 * When the directive class implements some {@linkDocs guide/lifecycle-hooks} the
	 * callbacks are called by the change detection at defined points in time during the life of the
	 * directive.
	 *
	 * ### Example
	 *
	 * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.
	 *
	 * Here is a simple directive that triggers on an `unless` selector:
	 *
	 * ```
	 * @Directive({
	 *   selector: '[unless]',
	 *   inputs: ['unless']
	 * })
	 * export class Unless {
	 *   viewContainer: ViewContainerRef;
	 *   templateRef: TemplateRef;
	 *   prevCondition: boolean;
	 *
	 *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {
	 *     this.viewContainer = viewContainer;
	 *     this.templateRef = templateRef;
	 *     this.prevCondition = null;
	 *   }
	 *
	 *   set unless(newCondition) {
	 *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
	 *       this.prevCondition = true;
	 *       this.viewContainer.clear();
	 *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
	 *       this.prevCondition = false;
	 *       this.viewContainer.create(this.templateRef);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * We can then use this `unless` selector in a template:
	 * ```
	 * <ul>
	 *   <li *unless="expr"></li>
	 * </ul>
	 * ```
	 *
	 * Once the directive instantiates the child view, the shorthand notation for the template expands
	 * and the result is:
	 *
	 * ```
	 * <ul>
	 *   <template [unless]="exp">
	 *     <li></li>
	 *   </template>
	 *   <li></li>
	 * </ul>
	 * ```
	 *
	 * Note also that although the `<li></li>` template still exists inside the `<template></template>`,
	 * the instantiated
	 * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.
	 * @stable
	 * @Annotation
	 */
	exports.Directive = decorators_1.makeDecorator(directives_1.DirectiveMetadata);
	/**
	 * Specifies that a constant attribute value should be injected.
	 *
	 * The directive can inject constant string literals of host element attributes.
	 *
	 * ### Example
	 *
	 * Suppose we have an `<input>` element and want to know its `type`.
	 *
	 * ```html
	 * <input type="text">
	 * ```
	 *
	 * A decorator can inject string literal `text` like so:
	 *
	 * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}
	 * @stable
	 * @Annotation
	 */
	exports.Attribute = decorators_1.makeParamDecorator(di_1.AttributeMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from QueryMetadata.
	/**
	 * Declares an injectable parameter to be a live list of directives or variable
	 * bindings from the content children of a directive.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
	 *
	 * Assume that `<tabs>` component would like to get a list its children `<pane>`
	 * components as shown in this example:
	 *
	 * ```html
	 * <tabs>
	 *   <pane title="Overview">...</pane>
	 *   <pane *ngFor="let o of objects" [title]="o.title">{{o.text}}</pane>
	 * </tabs>
	 * ```
	 *
	 * The preferred solution is to query for `Pane` directives using this decorator.
	 *
	 * ```javascript
	 * @Component({
	 *   selector: 'pane',
	 *   inputs: ['title']
	 * })
	 * class Pane {
	 *   title:string;
	 * }
	 *
	 * @Component({
	 *  selector: 'tabs',
	 *  template: `
	 *    <ul>
	 *      <li *ngFor="let pane of panes">{{pane.title}}</li>
	 *    </ul>
	 *    <ng-content></ng-content>
	 *  `
	 * })
	 * class Tabs {
	 *   panes: QueryList<Pane>;
	 *   constructor(@Query(Pane) panes:QueryList<Pane>) {
	 *     this.panes = panes;
	 *   }
	 * }
	 * ```
	 *
	 * A query can look for variable bindings by passing in a string with desired binding symbol.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/sT2j25cH1dURAyBRCKx1?p=preview))
	 * ```html
	 * <seeker>
	 *   <div #findme>...</div>
	 * </seeker>
	 *
	 * @Component({ selector: 'seeker' })
	 * class seeker {
	 *   constructor(@Query('findme') elList: QueryList<ElementRef>) {...}
	 * }
	 * ```
	 *
	 * In this case the object that is injected depend on the type of the variable
	 * binding. It can be an ElementRef, a directive or a component.
	 *
	 * Passing in a comma separated list of variable bindings will query for all of them.
	 *
	 * ```html
	 * <seeker>
	 *   <div #findMe>...</div>
	 *   <div #findMeToo>...</div>
	 * </seeker>
	 *
	 *  @Component({
	 *   selector: 'seeker'
	 * })
	 * class Seeker {
	 *   constructor(@Query('findMe, findMeToo') elList: QueryList<ElementRef>) {...}
	 * }
	 * ```
	 *
	 * Configure whether query looks for direct children or all descendants
	 * of the querying element, by using the `descendants` parameter.
	 * It is set to `false` by default.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/wtGeB977bv7qvA5FTYl9?p=preview))
	 * ```html
	 * <container #first>
	 *   <item>a</item>
	 *   <item>b</item>
	 *   <container #second>
	 *     <item>c</item>
	 *   </container>
	 * </container>
	 * ```
	 *
	 * When querying for items, the first container will see only `a` and `b` by default,
	 * but with `Query(TextDirective, {descendants: true})` it will see `c` too.
	 *
	 * The queried directives are kept in a depth-first pre-order with respect to their
	 * positions in the DOM.
	 *
	 * Query does not look deep into any subcomponent views.
	 *
	 * Query is updated as part of the change-detection cycle. Since change detection
	 * happens after construction of a directive, QueryList will always be empty when observed in the
	 * constructor.
	 *
	 * The injected object is an unmodifiable live list.
	 * See {@link QueryList} for more details.
	 * @deprecated
	 * @Annotation
	 */
	exports.Query = decorators_1.makeParamDecorator(di_1.QueryMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ContentChildrenMetadata.
	/**
	 * Configures a content query.
	 *
	 * Content queries are set before the `ngAfterContentInit` callback is called.
	 *
	 * ### Example
	 *
	 * ```
	 * @Directive({
	 *   selector: 'someDir'
	 * })
	 * class SomeDir {
	 *   @ContentChildren(ChildDirective) contentChildren: QueryList<ChildDirective>;
	 *
	 *   ngAfterContentInit() {
	 *     // contentChildren is set
	 *   }
	 * }
	 * ```
	 * @stable
	 * @Annotation
	 */
	exports.ContentChildren = decorators_1.makePropDecorator(di_1.ContentChildrenMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ContentChildMetadata.
	/**
	 * Configures a content query.
	 *
	 * Content queries are set before the `ngAfterContentInit` callback is called.
	 *
	 * ### Example
	 *
	 * ```
	 * @Directive({
	 *   selector: 'someDir'
	 * })
	 * class SomeDir {
	 *   @ContentChild(ChildDirective) contentChild;
	 *   @ContentChild('container_ref') containerChild
	 *
	 *   ngAfterContentInit() {
	 *     // contentChild is set
	 *     // containerChild is set
	 *   }
	 * }
	 * ```
	 *
	 * ```html
	 * <container #container_ref>
	 *   <item>a</item>
	 *   <item>b</item>
	 * </container>
	 * ```
	 * @stable
	 * @Annotation
	 */
	exports.ContentChild = decorators_1.makePropDecorator(di_1.ContentChildMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewChildrenMetadata.
	/**
	 * Declares a list of child element references.
	 *
	 * Angular automatically updates the list when the DOM is updated.
	 *
	 * `ViewChildren` takes a argument to select elements.
	 *
	 * - If the argument is a type, directives or components with the type will be bound.
	 *
	 * - If the argument is a string, the string is interpreted as a list of comma-separated selectors.
	 * For each selector, an element containing the matching template variable (e.g. `#child`) will be
	 * bound.
	 *
	 * View children are set before the `ngAfterViewInit` callback is called.
	 *
	 * ### Example
	 *
	 * With type selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: `
	 *     <child-cmp></child-cmp>
	 *     <child-cmp></child-cmp>
	 *     <child-cmp></child-cmp>
	 *   `,
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChildren(ChildCmp) children:QueryList<ChildCmp>;
	 *
	 *   ngAfterViewInit() {
	 *     // children are set
	 *     this.children.toArray().forEach((child)=>child.doSomething());
	 *   }
	 * }
	 * ```
	 *
	 * With string selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: `
	 *     <child-cmp #child1></child-cmp>
	 *     <child-cmp #child2></child-cmp>
	 *     <child-cmp #child3></child-cmp>
	 *   `,
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChildren('child1,child2,child3') children:QueryList<ChildCmp>;
	 *
	 *   ngAfterViewInit() {
	 *     // children are set
	 *     this.children.toArray().forEach((child)=>child.doSomething());
	 *   }
	 * }
	 * ```
	 *
	 * See also: [ViewChildrenMetadata]
	 * @stable
	 * @Annotation
	 */
	exports.ViewChildren = decorators_1.makePropDecorator(di_1.ViewChildrenMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewChildMetadata.
	/**
	 * Declares a reference to a child element.
	 *
	 * `ViewChildren` takes a argument to select elements.
	 *
	 * - If the argument is a type, a directive or a component with the type will be bound.
	 *
	 * - If the argument is a string, the string is interpreted as a selector. An element containing the
	 * matching template variable (e.g. `#child`) will be bound.
	 *
	 * In either case, `@ViewChild()` assigns the first (looking from above) element if there are
	 * multiple matches.
	 *
	 * View child is set before the `ngAfterViewInit` callback is called.
	 *
	 * ### Example
	 *
	 * With type selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: '<child-cmp></child-cmp>',
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChild(ChildCmp) child:ChildCmp;
	 *
	 *   ngAfterViewInit() {
	 *     // child is set
	 *     this.child.doSomething();
	 *   }
	 * }
	 * ```
	 *
	 * With string selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: '<child-cmp #child></child-cmp>',
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChild('child') child:ChildCmp;
	 *
	 *   ngAfterViewInit() {
	 *     // child is set
	 *     this.child.doSomething();
	 *   }
	 * }
	 * ```
	 * See also: [ViewChildMetadata]
	 * @stable
	 * @Annotation
	 */
	exports.ViewChild = decorators_1.makePropDecorator(di_1.ViewChildMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewQueryMetadata.
	/**
	 * Similar to {@link QueryMetadata}, but querying the component view, instead of
	 * the content children.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/eNsFHDf7YjyM6IzKxM1j?p=preview))
	 *
	 * ```javascript
	 * @Component({
	 *   ...,
	 *   template: `
	 *     <item> a </item>
	 *     <item> b </item>
	 *     <item> c </item>
	 *   `
	 * })
	 * class MyComponent {
	 *   shown: boolean;
	 *
	 *   constructor(private @Query(Item) items:QueryList<Item>) {
	 *     items.changes.subscribe(() => console.log(items.length));
	 *   }
	 * }
	 * ```
	 *
	 * Supports the same querying parameters as {@link QueryMetadata}, except
	 * `descendants`. This always queries the whole view.
	 *
	 * As `shown` is flipped between true and false, items will contain zero of one
	 * items.
	 *
	 * Specifies that a {@link QueryList} should be injected.
	 *
	 * The injected object is an iterable and observable live list.
	 * See {@link QueryList} for more details.
	 * @deprecated
	 * @Annotation
	 */
	exports.ViewQuery = decorators_1.makeParamDecorator(di_1.ViewQueryMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from PipeMetadata.
	/**
	 * Declare reusable pipe function.
	 *
	 * ### Example
	 *
	 * {@example core/ts/metadata/metadata.ts region='pipe'}
	 * @stable
	 * @Annotation
	 */
	exports.Pipe = decorators_1.makeDecorator(directives_1.PipeMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from InputMetadata.
	/**
	 * Declares a data-bound input property.
	 *
	 * Angular automatically updates data-bound properties during change detection.
	 *
	 * `InputMetadata` takes an optional parameter that specifies the name
	 * used when instantiating a component in the template. When not provided,
	 * the name of the decorated property is used.
	 *
	 * ### Example
	 *
	 * The following example creates a component with two input properties.
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'bank-account',
	 *   template: `
	 *     Bank Name: {{bankName}}
	 *     Account Id: {{id}}
	 *   `
	 * })
	 * class BankAccount {
	 *   @Input() bankName: string;
	 *   @Input('account-id') id: string;
	 *
	 *   // this property is not bound, and won't be automatically updated by Angular
	 *   normalizedBankName: string;
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
	 *   `,
	 *   directives: [BankAccount]
	 * })
	 * class App {}
	 *
	 * bootstrap(App);
	 * ```
	 * @stable
	 * @Annotation
	 */
	exports.Input = decorators_1.makePropDecorator(directives_1.InputMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from OutputMetadata.
	/**
	 * Declares an event-bound output property.
	 *
	 * When an output property emits an event, an event handler attached to that event
	 * the template is invoked.
	 *
	 * `OutputMetadata` takes an optional parameter that specifies the name
	 * used when instantiating a component in the template. When not provided,
	 * the name of the decorated property is used.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * @Directive({
	 *   selector: 'interval-dir',
	 * })
	 * class IntervalDir {
	 *   @Output() everySecond = new EventEmitter();
	 *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();
	 *
	 *   constructor() {
	 *     setInterval(() => this.everySecond.emit("event"), 1000);
	 *     setInterval(() => this.five5Secs.emit("event"), 5000);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <interval-dir (everySecond)="everySecond()" (everyFiveSeconds)="everyFiveSeconds()">
	 *     </interval-dir>
	 *   `,
	 *   directives: [IntervalDir]
	 * })
	 * class App {
	 *   everySecond() { console.log('second'); }
	 *   everyFiveSeconds() { console.log('five seconds'); }
	 * }
	 * bootstrap(App);
	 * ```
	 * @stable
	 * @Annotation
	 */
	exports.Output = decorators_1.makePropDecorator(directives_1.OutputMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from HostBindingMetadata.
	/**
	 * Declares a host property binding.
	 *
	 * Angular automatically checks host property bindings during change detection.
	 * If a binding changes, it will update the host element of the directive.
	 *
	 * `HostBindingMetadata` takes an optional parameter that specifies the property
	 * name of the host element that will be updated. When not provided,
	 * the class property name is used.
	 *
	 * ### Example
	 *
	 * The following example creates a directive that sets the `valid` and `invalid` classes
	 * on the DOM element that has ngModel directive on it.
	 *
	 * ```typescript
	 * @Directive({selector: '[ngModel]'})
	 * class NgModelStatus {
	 *   constructor(public control:NgModel) {}
	 *   @HostBinding('class.valid') get valid() { return this.control.valid; }
	 *   @HostBinding('class.invalid') get invalid() { return this.control.invalid; }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<input [(ngModel)]="prop">`,
	 *   directives: [FORM_DIRECTIVES, NgModelStatus]
	 * })
	 * class App {
	 *   prop;
	 * }
	 *
	 * bootstrap(App);
	 * ```
	 * @stable
	 * @Annotation
	 */
	exports.HostBinding = decorators_1.makePropDecorator(directives_1.HostBindingMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from HostListenerMetadata.
	/**
	 * Declares a host listener.
	 *
	 * Angular will invoke the decorated method when the host element emits the specified event.
	 *
	 * If the decorated method returns `false`, then `preventDefault` is applied on the DOM
	 * event.
	 *
	 * ### Example
	 *
	 * The following example declares a directive that attaches a click listener to the button and
	 * counts clicks.
	 *
	 * ```typescript
	 * @Directive({selector: 'button[counting]'})
	 * class CountClicks {
	 *   numberOfClicks = 0;
	 *
	 *   @HostListener('click', ['$event.target'])
	 *   onClick(btn) {
	 *     console.log("button", btn, "number of clicks:", this.numberOfClicks++);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<button counting>Increment</button>`,
	 *   directives: [CountClicks]
	 * })
	 * class App {}
	 *
	 * bootstrap(App);
	 * ```
	 * @stable
	 * @Annotation
	 */
	exports.HostListener = decorators_1.makePropDecorator(directives_1.HostListenerMetadata);
	/**
	 * Declares an ng module.
	 * @experimental
	 * @Annotation
	 */
	exports.NgModule = decorators_1.makeDecorator(ng_module_1.NgModuleMetadata);
	//# sourceMappingURL=metadata.js.map

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var forward_ref_1 = __webpack_require__(52);
	var metadata_1 = __webpack_require__(22);
	var opaque_token_1 = __webpack_require__(146);
	var lang_1 = __webpack_require__(2);
	/**
	 * This token can be used to create a virtual provider that will populate the
	 * `entryComponents` fields of components and ng modules based on its `useValue`.
	 * All components that are referenced in the `useValue` value (either directly
	 * or in a nested array or map) will be added to the `entryComponents` property.
	 *
	 * ### Example
	 * The following example shows how the router can populate the `entryComponents`
	 * field of an NgModule based on the router configuration which refers
	 * to components.
	 *
	 * ```typescript
	 * // helper function inside the router
	 * function provideRoutes(routes) {
	 *   return [
	 *     {provide: ROUTES, useValue: routes},
	 *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}
	 *   ];
	 * }
	 *
	 * // user code
	 * let routes = [
	 *   {path: '/root', component: RootComp},
	 *   {path: /teams', component: TeamsComp}
	 * ];
	 *
	 * @NgModule({
	 *   providers: [provideRoutes(routes)]
	 * })
	 * class ModuleWithRoutes {}
	 * ```
	 *
	 * @experimental
	 */
	exports.ANALYZE_FOR_ENTRY_COMPONENTS = new opaque_token_1.OpaqueToken('AnalyzeForEntryComponents');
	/**
	 * Specifies that a constant attribute value should be injected.
	 *
	 * The directive can inject constant string literals of host element attributes.
	 *
	 * ### Example
	 *
	 * Suppose we have an `<input>` element and want to know its `type`.
	 *
	 * ```html
	 * <input type="text">
	 * ```
	 *
	 * A decorator can inject string literal `text` like so:
	 *
	 * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}
	 * @stable
	 */
	var AttributeMetadata = (function (_super) {
	    __extends(AttributeMetadata, _super);
	    function AttributeMetadata(attributeName) {
	        _super.call(this);
	        this.attributeName = attributeName;
	    }
	    Object.defineProperty(AttributeMetadata.prototype, "token", {
	        get: function () {
	            // Normally one would default a token to a type of an injected value but here
	            // the type of a variable is "string" and we can't use primitive type as a return value
	            // so we use instance of Attribute instead. This doesn't matter much in practice as arguments
	            // with @Attribute annotation are injected by ElementInjector that doesn't take tokens into
	            // account.
	            return this;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AttributeMetadata.prototype.toString = function () { return "@Attribute(" + lang_1.stringify(this.attributeName) + ")"; };
	    return AttributeMetadata;
	}(metadata_1.DependencyMetadata));
	exports.AttributeMetadata = AttributeMetadata;
	/**
	 * Declares an injectable parameter to be a live list of directives or variable
	 * bindings from the content children of a directive.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
	 *
	 * Assume that `<tabs>` component would like to get a list its children `<pane>`
	 * components as shown in this example:
	 *
	 * ```html
	 * <tabs>
	 *   <pane title="Overview">...</pane>
	 *   <pane *ngFor="let o of objects" [title]="o.title">{{o.text}}</pane>
	 * </tabs>
	 * ```
	 *
	 * The preferred solution is to query for `Pane` directives using this decorator.
	 *
	 * ```javascript
	 * @Component({
	 *   selector: 'pane',
	 *   inputs: ['title']
	 * })
	 * class Pane {
	 *   title:string;
	 * }
	 *
	 * @Component({
	 *  selector: 'tabs',
	 *  template: `
	 *    <ul>
	 *      <li *ngFor="let pane of panes">{{pane.title}}</li>
	 *    </ul>
	 *    <ng-content></ng-content>
	 *  `
	 * })
	 * class Tabs {
	 *   panes: QueryList<Pane>;
	 *   constructor(@Query(Pane) panes:QueryList<Pane>) {
	  *    this.panes = panes;
	  *  }
	 * }
	 * ```
	 *
	 * A query can look for variable bindings by passing in a string with desired binding symbol.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/sT2j25cH1dURAyBRCKx1?p=preview))
	 * ```html
	 * <seeker>
	 *   <div #findme>...</div>
	 * </seeker>
	 *
	 * @Component({ selector: 'seeker' })
	 * class Seeker {
	 *   constructor(@Query('findme') elList: QueryList<ElementRef>) {...}
	 * }
	 * ```
	 *
	 * In this case the object that is injected depend on the type of the variable
	 * binding. It can be an ElementRef, a directive or a component.
	 *
	 * Passing in a comma separated list of variable bindings will query for all of them.
	 *
	 * ```html
	 * <seeker>
	 *   <div #find-me>...</div>
	 *   <div #find-me-too>...</div>
	 * </seeker>
	 *
	 *  @Component({
	 *   selector: 'seeker'
	 * })
	 * class Seeker {
	 *   constructor(@Query('findMe, findMeToo') elList: QueryList<ElementRef>) {...}
	 * }
	 * ```
	 *
	 * Configure whether query looks for direct children or all descendants
	 * of the querying element, by using the `descendants` parameter.
	 * It is set to `false` by default.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/wtGeB977bv7qvA5FTYl9?p=preview))
	 * ```html
	 * <container #first>
	 *   <item>a</item>
	 *   <item>b</item>
	 *   <container #second>
	 *     <item>c</item>
	 *   </container>
	 * </container>
	 * ```
	 *
	 * When querying for items, the first container will see only `a` and `b` by default,
	 * but with `Query(TextDirective, {descendants: true})` it will see `c` too.
	 *
	 * The queried directives are kept in a depth-first pre-order with respect to their
	 * positions in the DOM.
	 *
	 * Query does not look deep into any subcomponent views.
	 *
	 * Query is updated as part of the change-detection cycle. Since change detection
	 * happens after construction of a directive, QueryList will always be empty when observed in the
	 * constructor.
	 *
	 * The injected object is an unmodifiable live list.
	 * See {@link QueryList} for more details.
	 * @deprecated
	 */
	var QueryMetadata = (function (_super) {
	    __extends(QueryMetadata, _super);
	    function QueryMetadata(_selector, _a) {
	        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.first, first = _d === void 0 ? false : _d, _e = _b.read, read = _e === void 0 ? null : _e;
	        _super.call(this);
	        this._selector = _selector;
	        this.descendants = descendants;
	        this.first = first;
	        this.read = read;
	    }
	    Object.defineProperty(QueryMetadata.prototype, "isViewQuery", {
	        /**
	         * always `false` to differentiate it with {@link ViewQueryMetadata}.
	         */
	        get: function () { return false; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryMetadata.prototype, "selector", {
	        /**
	         * what this is querying for.
	         */
	        get: function () { return forward_ref_1.resolveForwardRef(this._selector); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryMetadata.prototype, "isVarBindingQuery", {
	        /**
	         * whether this is querying for a variable binding or a directive.
	         */
	        get: function () { return lang_1.isString(this.selector); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryMetadata.prototype, "varBindings", {
	        /**
	         * returns a list of variable bindings this is querying for.
	         * Only applicable if this is a variable bindings query.
	         */
	        get: function () { return lang_1.StringWrapper.split(this.selector, /\s*,\s*/g); },
	        enumerable: true,
	        configurable: true
	    });
	    QueryMetadata.prototype.toString = function () { return "@Query(" + lang_1.stringify(this.selector) + ")"; };
	    return QueryMetadata;
	}(metadata_1.DependencyMetadata));
	exports.QueryMetadata = QueryMetadata;
	// TODO: add an example after ContentChildren and ViewChildren are in master
	/**
	 * Configures a content query.
	 *
	 * Content queries are set before the `ngAfterContentInit` callback is called.
	 *
	 * ### Example
	 *
	 * ```
	 * @Directive({
	 *   selector: 'someDir'
	 * })
	 * class SomeDir {
	 *   @ContentChildren(ChildDirective) contentChildren: QueryList<ChildDirective>;
	 *
	 *   ngAfterContentInit() {
	 *     // contentChildren is set
	 *   }
	 * }
	 * ```
	 * @stable
	 */
	var ContentChildrenMetadata = (function (_super) {
	    __extends(ContentChildrenMetadata, _super);
	    function ContentChildrenMetadata(_selector, _a) {
	        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.read, read = _d === void 0 ? null : _d;
	        _super.call(this, _selector, { descendants: descendants, read: read });
	    }
	    return ContentChildrenMetadata;
	}(QueryMetadata));
	exports.ContentChildrenMetadata = ContentChildrenMetadata;
	// TODO: add an example after ContentChild and ViewChild are in master
	/**
	 * Configures a content query.
	 *
	 * Content queries are set before the `ngAfterContentInit` callback is called.
	 *
	 * ### Example
	 *
	 * ```
	 * @Directive({
	 *   selector: 'someDir'
	 * })
	 * class SomeDir {
	 *   @ContentChild(ChildDirective) contentChild;
	 *
	 *   ngAfterContentInit() {
	 *     // contentChild is set
	 *   }
	 * }
	 * ```
	 * @stable
	 */
	var ContentChildMetadata = (function (_super) {
	    __extends(ContentChildMetadata, _super);
	    function ContentChildMetadata(_selector, _a) {
	        var _b = (_a === void 0 ? {} : _a).read, read = _b === void 0 ? null : _b;
	        _super.call(this, _selector, { descendants: true, first: true, read: read });
	    }
	    return ContentChildMetadata;
	}(QueryMetadata));
	exports.ContentChildMetadata = ContentChildMetadata;
	/**
	 * Similar to {@link QueryMetadata}, but querying the component view, instead of
	 * the content children.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/eNsFHDf7YjyM6IzKxM1j?p=preview))
	 *
	 * ```javascript
	 * @Component({
	 *   ...,
	 *   template: `
	 *     <item> a </item>
	 *     <item> b </item>
	 *     <item> c </item>
	 *   `
	 * })
	 * class MyComponent {
	 *   shown: boolean;
	 *
	 *   constructor(private @ViewQuery(Item) items:QueryList<Item>) {
	 *     items.changes.subscribe(() => console.log(items.length));
	 *   }
	 * }
	 * ```
	 *
	 * Supports the same querying parameters as {@link QueryMetadata}, except
	 * `descendants`. This always queries the whole view.
	 *
	 * As `shown` is flipped between true and false, items will contain zero of one
	 * items.
	 *
	 * Specifies that a {@link QueryList} should be injected.
	 *
	 * The injected object is an iterable and observable live list.
	 * See {@link QueryList} for more details.
	 * @deprecated
	 */
	var ViewQueryMetadata = (function (_super) {
	    __extends(ViewQueryMetadata, _super);
	    function ViewQueryMetadata(_selector, _a) {
	        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.first, first = _d === void 0 ? false : _d, _e = _b.read, read = _e === void 0 ? null : _e;
	        _super.call(this, _selector, { descendants: descendants, first: first, read: read });
	    }
	    Object.defineProperty(ViewQueryMetadata.prototype, "isViewQuery", {
	        /**
	         * always `true` to differentiate it with {@link QueryMetadata}.
	         */
	        get: function () { return true; },
	        enumerable: true,
	        configurable: true
	    });
	    ViewQueryMetadata.prototype.toString = function () { return "@ViewQuery(" + lang_1.stringify(this.selector) + ")"; };
	    return ViewQueryMetadata;
	}(QueryMetadata));
	exports.ViewQueryMetadata = ViewQueryMetadata;
	/**
	 * Declares a list of child element references.
	 *
	 * Angular automatically updates the list when the DOM is updated.
	 *
	 * `ViewChildren` takes an argument to select elements.
	 *
	 * - If the argument is a type, directives or components with the type will be bound.
	 *
	 * - If the argument is a string, the string is interpreted as a list of comma-separated selectors.
	 * For each selector, an element containing the matching template variable (e.g. `#child`) will be
	 * bound.
	 *
	 * View children are set before the `ngAfterViewInit` callback is called.
	 *
	 * ### Example
	 *
	 * With type selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: `
	 *     <child-cmp></child-cmp>
	 *     <child-cmp></child-cmp>
	 *     <child-cmp></child-cmp>
	 *   `,
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChildren(ChildCmp) children:QueryList<ChildCmp>;
	 *
	 *   ngAfterViewInit() {
	 *     // children are set
	 *     this.children.toArray().forEach((child)=>child.doSomething());
	 *   }
	 * }
	 * ```
	 *
	 * With string selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: `
	 *     <child-cmp #child1></child-cmp>
	 *     <child-cmp #child2></child-cmp>
	 *     <child-cmp #child3></child-cmp>
	 *   `,
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChildren('child1,child2,child3') children:QueryList<ChildCmp>;
	 *
	 *   ngAfterViewInit() {
	 *     // children are set
	 *     this.children.toArray().forEach((child)=>child.doSomething());
	 *   }
	 * }
	 * ```
	 * @stable
	 */
	var ViewChildrenMetadata = (function (_super) {
	    __extends(ViewChildrenMetadata, _super);
	    function ViewChildrenMetadata(_selector, _a) {
	        var _b = (_a === void 0 ? {} : _a).read, read = _b === void 0 ? null : _b;
	        _super.call(this, _selector, { descendants: true, read: read });
	    }
	    return ViewChildrenMetadata;
	}(ViewQueryMetadata));
	exports.ViewChildrenMetadata = ViewChildrenMetadata;
	/**
	 *
	 * Declares a reference of child element.
	 *
	 * `ViewChildren` takes an argument to select elements.
	 *
	 * - If the argument is a type, a directive or a component with the type will be bound.
	 *
	 If the argument is a string, the string is interpreted as a selector. An element containing the
	 matching template variable (e.g. `#child`) will be bound.
	 *
	 * In either case, `@ViewChild()` assigns the first (looking from above) element if there are
	 multiple matches.
	 *
	 * View child is set before the `ngAfterViewInit` callback is called.
	 *
	 * ### Example
	 *
	 * With type selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: '<child-cmp></child-cmp>',
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChild(ChildCmp) child:ChildCmp;
	 *
	 *   ngAfterViewInit() {
	 *     // child is set
	 *     this.child.doSomething();
	 *   }
	 * }
	 * ```
	 *
	 * With string selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: '<child-cmp #child></child-cmp>',
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChild('child') child:ChildCmp;
	 *
	 *   ngAfterViewInit() {
	 *     // child is set
	 *     this.child.doSomething();
	 *   }
	 * }
	 * ```
	 * @stable
	 */
	var ViewChildMetadata = (function (_super) {
	    __extends(ViewChildMetadata, _super);
	    function ViewChildMetadata(_selector, _a) {
	        var _b = (_a === void 0 ? {} : _a).read, read = _b === void 0 ? null : _b;
	        _super.call(this, _selector, { descendants: true, first: true, read: read });
	    }
	    return ViewChildMetadata;
	}(ViewQueryMetadata));
	exports.ViewChildMetadata = ViewChildMetadata;
	//# sourceMappingURL=di.js.map

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var constants_1 = __webpack_require__(50);
	var metadata_1 = __webpack_require__(22);
	var lang_1 = __webpack_require__(2);
	/**
	 * Directives allow you to attach behavior to elements in the DOM.
	 *
	 * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.
	 *
	 * A directive consists of a single directive annotation and a controller class. When the
	 * directive's `selector` matches
	 * elements in the DOM, the following steps occur:
	 *
	 * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor
	 * arguments.
	 * 2. Angular instantiates directives for each matched element using `ElementInjector` in a
	 * depth-first order,
	 *    as declared in the HTML.
	 *
	 * ## Understanding How Injection Works
	 *
	 * There are three stages of injection resolution.
	 * - *Pre-existing Injectors*:
	 *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if
	 * the dependency was
	 *     specified as `@Optional`, returns `null`.
	 *   - The platform injector resolves browser singleton resources, such as: cookies, title,
	 * location, and others.
	 * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow
	 * the same parent-child hierarchy
	 *     as the component instances in the DOM.
	 * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each
	 * element has an `ElementInjector`
	 *     which follow the same parent-child hierarchy as the DOM elements themselves.
	 *
	 * When a template is instantiated, it also must instantiate the corresponding directives in a
	 * depth-first order. The
	 * current `ElementInjector` resolves the constructor dependencies for each directive.
	 *
	 * Angular then resolves dependencies as follows, according to the order in which they appear in the
	 * {@link ComponentMetadata}:
	 *
	 * 1. Dependencies on the current element
	 * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary
	 * 3. Dependencies on component injectors and their parents until it encounters the root component
	 * 4. Dependencies on pre-existing injectors
	 *
	 *
	 * The `ElementInjector` can inject other directives, element-specific special objects, or it can
	 * delegate to the parent
	 * injector.
	 *
	 * To inject other directives, declare the constructor parameter as:
	 * - `directive:DirectiveType`: a directive on the current element only
	 * - `@Host() directive:DirectiveType`: any directive that matches the type between the current
	 * element and the
	 *    Shadow DOM root.
	 * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child
	 * directives.
	 * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any
	 * child directives.
	 *
	 * To inject element-specific special objects, declare the constructor parameter as:
	 * - `element: ElementRef` to obtain a reference to logical element in the view.
	 * - `viewContainer: ViewContainerRef` to control child template instantiation, for
	 * {@link DirectiveMetadata} directives only
	 * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.
	 *
	 * ### Example
	 *
	 * The following example demonstrates how dependency injection resolves constructor arguments in
	 * practice.
	 *
	 *
	 * Assume this HTML template:
	 *
	 * ```
	 * <div dependency="1">
	 *   <div dependency="2">
	 *     <div dependency="3" my-directive>
	 *       <div dependency="4">
	 *         <div dependency="5"></div>
	 *       </div>
	 *       <div dependency="6"></div>
	 *     </div>
	 *   </div>
	 * </div>
	 * ```
	 *
	 * With the following `dependency` decorator and `SomeService` injectable class.
	 *
	 * ```
	 * @Injectable()
	 * class SomeService {
	 * }
	 *
	 * @Directive({
	 *   selector: '[dependency]',
	 *   inputs: [
	 *     'id: dependency'
	 *   ]
	 * })
	 * class Dependency {
	 *   id:string;
	 * }
	 * ```
	 *
	 * Let's step through the different ways in which `MyDirective` could be declared...
	 *
	 *
	 * ### No injection
	 *
	 * Here the constructor is declared with no arguments, therefore nothing is injected into
	 * `MyDirective`.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor() {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with no dependencies.
	 *
	 *
	 * ### Component-level injection
	 *
	 * Directives can inject any injectable instance from the closest component injector or any of its
	 * parents.
	 *
	 * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type
	 * from the parent
	 * component's injector.
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(someService: SomeService) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a dependency on `SomeService`.
	 *
	 *
	 * ### Injecting a directive from the current element
	 *
	 * Directives can inject other directives declared on the current element.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(dependency: Dependency) {
	 *     expect(dependency.id).toEqual(3);
	 *   }
	 * }
	 * ```
	 * This directive would be instantiated with `Dependency` declared at the same element, in this case
	 * `dependency="3"`.
	 *
	 * ### Injecting a directive from any ancestor elements
	 *
	 * Directives can inject other directives declared on any ancestor element (in the current Shadow
	 * DOM), i.e. on the current element, the
	 * parent element, or its parents.
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Host() dependency: Dependency) {
	 *     expect(dependency.id).toEqual(2);
	 *   }
	 * }
	 * ```
	 *
	 * `@Host` checks the current element, the parent, as well as its parents recursively. If
	 * `dependency="2"` didn't
	 * exist on the direct parent, this injection would
	 * have returned
	 * `dependency="1"`.
	 *
	 *
	 * ### Injecting a live collection of direct child directives
	 *
	 *
	 * A directive can also query for other child directives. Since parent directives are instantiated
	 * before child directives, a directive can't simply inject the list of child directives. Instead,
	 * the directive injects a {@link QueryList}, which updates its contents as children are added,
	 * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ngFor`, an
	 * `ngIf`, or an `ngSwitch`.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and
	 * `Dependency` 6. Here, `Dependency` 5 would not be included, because it is not a direct child.
	 *
	 * ### Injecting a live collection of descendant directives
	 *
	 * By passing the descendant flag to `@Query` above, we can include the children of the child
	 * elements.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.
	 *
	 * ### Optional injection
	 *
	 * The normal behavior of directives is to return an error when a specified dependency cannot be
	 * resolved. If you
	 * would like to inject `null` on unresolved dependency instead, you can annotate that dependency
	 * with `@Optional()`.
	 * This explicitly permits the author of a template to treat some of the surrounding directives as
	 * optional.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Optional() dependency:Dependency) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a `Dependency` directive found on the current element.
	 * If none can be
	 * found, the injector supplies `null` instead of throwing an error.
	 *
	 * ### Example
	 *
	 * Here we use a decorator directive to simply define basic tool-tip behavior.
	 *
	 * ```
	 * @Directive({
	 *   selector: '[tooltip]',
	 *   inputs: [
	 *     'text: tooltip'
	 *   ],
	 *   host: {
	 *     '(mouseenter)': 'onMouseEnter()',
	 *     '(mouseleave)': 'onMouseLeave()'
	 *   }
	 * })
	 * class Tooltip{
	 *   text:string;
	 *   overlay:Overlay; // NOT YET IMPLEMENTED
	 *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED
	 *
	 *   constructor(overlayManager:OverlayManager) {
	 *     this.overlay = overlay;
	 *   }
	 *
	 *   onMouseEnter() {
	 *     // exact signature to be determined
	 *     this.overlay = this.overlayManager.open(text, ...);
	 *   }
	 *
	 *   onMouseLeave() {
	 *     this.overlay.close();
	 *     this.overlay = null;
	 *   }
	 * }
	 * ```
	 * In our HTML template, we can then add this behavior to a `<div>` or any other element with the
	 * `tooltip` selector,
	 * like so:
	 *
	 * ```
	 * <div tooltip="some text here"></div>
	 * ```
	 *
	 * Directives can also control the instantiation, destruction, and positioning of inline template
	 * elements:
	 *
	 * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at
	 * runtime.
	 * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a
	 * location in the current view
	 * where these actions are performed.
	 *
	 * Views are always created as children of the current {@link ComponentMetadata}, and as siblings of
	 * the
	 * `<template>` element. Thus a
	 * directive in a child view cannot inject the directive that created it.
	 *
	 * Since directives that create views via ViewContainers are common in Angular, and using the full
	 * `<template>` element syntax is wordy, Angular
	 * also supports a shorthand notation: `<li *foo="bar">` and `<li template="foo: bar">` are
	 * equivalent.
	 *
	 * Thus,
	 *
	 * ```
	 * <ul>
	 *   <li *foo="bar" title="text"></li>
	 * </ul>
	 * ```
	 *
	 * Expands in use to:
	 *
	 * ```
	 * <ul>
	 *   <template [foo]="bar">
	 *     <li title="text"></li>
	 *   </template>
	 * </ul>
	 * ```
	 *
	 * Notice that although the shorthand places `*foo="bar"` within the `<li>` element, the binding for
	 * the directive
	 * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.
	 *
	 * ## Lifecycle hooks
	 *
	 * When the directive class implements some {@linkDocs guide/lifecycle-hooks} the
	 * callbacks are called by the change detection at defined points in time during the life of the
	 * directive.
	 *
	 * ### Example
	 *
	 * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.
	 *
	 * Here is a simple directive that triggers on an `unless` selector:
	 *
	 * ```
	 * @Directive({
	 *   selector: '[unless]',
	 *   inputs: ['unless']
	 * })
	 * export class Unless {
	 *   viewContainer: ViewContainerRef;
	 *   templateRef: TemplateRef;
	 *   prevCondition: boolean;
	 *
	 *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {
	 *     this.viewContainer = viewContainer;
	 *     this.templateRef = templateRef;
	 *     this.prevCondition = null;
	 *   }
	 *
	 *   set unless(newCondition) {
	 *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
	 *       this.prevCondition = true;
	 *       this.viewContainer.clear();
	 *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
	 *       this.prevCondition = false;
	 *       this.viewContainer.create(this.templateRef);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * We can then use this `unless` selector in a template:
	 * ```
	 * <ul>
	 *   <li *unless="expr"></li>
	 * </ul>
	 * ```
	 *
	 * Once the directive instantiates the child view, the shorthand notation for the template expands
	 * and the result is:
	 *
	 * ```
	 * <ul>
	 *   <template [unless]="exp">
	 *     <li></li>
	 *   </template>
	 *   <li></li>
	 * </ul>
	 * ```
	 *
	 * Note also that although the `<li></li>` template still exists inside the `<template></template>`,
	 * the instantiated
	 * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.
	 * @stable
	 */
	var DirectiveMetadata = (function (_super) {
	    __extends(DirectiveMetadata, _super);
	    function DirectiveMetadata(_a) {
	        var _b = _a === void 0 ? {} : _a, selector = _b.selector, inputs = _b.inputs, outputs = _b.outputs, properties = _b.properties, events = _b.events, host = _b.host, providers = _b.providers, exportAs = _b.exportAs, queries = _b.queries;
	        _super.call(this);
	        this.selector = selector;
	        this._inputs = inputs;
	        this._properties = properties;
	        this._outputs = outputs;
	        this._events = events;
	        this.host = host;
	        this.exportAs = exportAs;
	        this.queries = queries;
	        this._providers = providers;
	    }
	    Object.defineProperty(DirectiveMetadata.prototype, "inputs", {
	        /**
	         * Enumerates the set of data-bound input properties for a directive
	         *
	         * Angular automatically updates input properties during change detection.
	         *
	         * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`
	         * configuration:
	         *
	         * - `directiveProperty` specifies the component property where the value is written.
	         * - `bindingProperty` specifies the DOM property where the value is read from.
	         *
	         * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/ivhfXY?p=preview))
	         *
	         * The following example creates a component with two data-bound properties.
	         *
	         * ```typescript
	         * @Component({
	         *   selector: 'bank-account',
	         *   inputs: ['bankName', 'id: account-id'],
	         *   template: `
	         *     Bank Name: {{bankName}}
	         *     Account Id: {{id}}
	         *   `
	         * })
	         * class BankAccount {
	         *   bankName: string;
	         *   id: string;
	         *
	         *   // this property is not bound, and won't be automatically updated by Angular
	         *   normalizedBankName: string;
	         * }
	         *
	         * @Component({
	         *   selector: 'app',
	         *   template: `
	         *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
	         *   `,
	         *   directives: [BankAccount]
	         * })
	         * class App {}
	         *
	         * bootstrap(App);
	         * ```
	         *
	         */
	        get: function () {
	            return lang_1.isPresent(this._properties) && this._properties.length > 0 ? this._properties :
	                this._inputs;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectiveMetadata.prototype, "properties", {
	        /**
	         * Use `inputs` instead
	         *
	         * @deprecated
	         */
	        get: function () { return this.inputs; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectiveMetadata.prototype, "outputs", {
	        /**
	         * Enumerates the set of event-bound output properties.
	         *
	         * When an output property emits an event, an event handler attached to that event
	         * the template is invoked.
	         *
	         * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`
	         * configuration:
	         *
	         * - `directiveProperty` specifies the component property that emits events.
	         * - `bindingProperty` specifies the DOM property the event handler is attached to.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/d5CNq7?p=preview))
	         *
	         * ```typescript
	         * @Directive({
	         *   selector: 'interval-dir',
	         *   outputs: ['everySecond', 'five5Secs: everyFiveSeconds']
	         * })
	         * class IntervalDir {
	         *   everySecond = new EventEmitter();
	         *   five5Secs = new EventEmitter();
	         *
	         *   constructor() {
	         *     setInterval(() => this.everySecond.emit("event"), 1000);
	         *     setInterval(() => this.five5Secs.emit("event"), 5000);
	         *   }
	         * }
	         *
	         * @Component({
	         *   selector: 'app',
	         *   template: `
	         *     <interval-dir (everySecond)="everySecond()" (everyFiveSeconds)="everyFiveSeconds()">
	         *     </interval-dir>
	         *   `,
	         *   directives: [IntervalDir]
	         * })
	         * class App {
	         *   everySecond() { console.log('second'); }
	         *   everyFiveSeconds() { console.log('five seconds'); }
	         * }
	         * bootstrap(App);
	         * ```
	         *
	         */
	        get: function () {
	            return lang_1.isPresent(this._events) && this._events.length > 0 ? this._events : this._outputs;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectiveMetadata.prototype, "events", {
	        /**
	         * Use `outputs` instead
	         *
	         * @deprecated
	         */
	        get: function () { return this.outputs; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectiveMetadata.prototype, "providers", {
	        /**
	         * Defines the set of injectable objects that are visible to a Directive and its light DOM
	         * children.
	         *
	         * ## Simple Example
	         *
	         * Here is an example of a class that can be injected:
	         *
	         * ```
	         * class Greeter {
	         *    greet(name:string) {
	         *      return 'Hello ' + name + '!';
	         *    }
	         * }
	         *
	         * @Directive({
	         *   selector: 'greet',
	         *   providers: [
	         *     Greeter
	         *   ]
	         * })
	         * class HelloWorld {
	         *   greeter:Greeter;
	         *
	         *   constructor(greeter:Greeter) {
	         *     this.greeter = greeter;
	         *   }
	         * }
	         * ```
	         */
	        get: function () { return this._providers; },
	        enumerable: true,
	        configurable: true
	    });
	    return DirectiveMetadata;
	}(metadata_1.InjectableMetadata));
	exports.DirectiveMetadata = DirectiveMetadata;
	/**
	 * Declare reusable UI building blocks for an application.
	 *
	 * Each Angular component requires a single `@Component` annotation. The
	 * `@Component`
	 * annotation specifies when a component is instantiated, and which properties and hostListeners it
	 * binds to.
	 *
	 * When a component is instantiated, Angular
	 * - creates a shadow DOM for the component.
	 * - loads the selected template into the shadow DOM.
	 * - creates all the injectable objects configured with `providers` and `viewProviders`.
	 *
	 * All template expressions and statements are then evaluated against the component instance.
	 *
	 * ## Lifecycle hooks
	 *
	 * When the component class implements some {@linkDocs guide/lifecycle-hooks} the
	 * callbacks are called by the change detection at defined points in time during the life of the
	 * component.
	 *
	 * ### Example
	 *
	 * {@example core/ts/metadata/metadata.ts region='component'}
	 * @stable
	 */
	var ComponentMetadata = (function (_super) {
	    __extends(ComponentMetadata, _super);
	    function ComponentMetadata(_a) {
	        var _b = _a === void 0 ? {} : _a, selector = _b.selector, inputs = _b.inputs, outputs = _b.outputs, properties = _b.properties, events = _b.events, host = _b.host, exportAs = _b.exportAs, moduleId = _b.moduleId, providers = _b.providers, viewProviders = _b.viewProviders, _c = _b.changeDetection, changeDetection = _c === void 0 ? constants_1.ChangeDetectionStrategy.Default : _c, queries = _b.queries, templateUrl = _b.templateUrl, template = _b.template, styleUrls = _b.styleUrls, styles = _b.styles, animations = _b.animations, directives = _b.directives, pipes = _b.pipes, encapsulation = _b.encapsulation, interpolation = _b.interpolation, entryComponents = _b.entryComponents;
	        _super.call(this, {
	            selector: selector,
	            inputs: inputs,
	            outputs: outputs,
	            properties: properties,
	            events: events,
	            host: host,
	            exportAs: exportAs,
	            providers: providers,
	            queries: queries
	        });
	        this.changeDetection = changeDetection;
	        this._viewProviders = viewProviders;
	        this.templateUrl = templateUrl;
	        this.template = template;
	        this.styleUrls = styleUrls;
	        this.styles = styles;
	        this.directives = directives;
	        this.pipes = pipes;
	        this.encapsulation = encapsulation;
	        this.moduleId = moduleId;
	        this.animations = animations;
	        this.interpolation = interpolation;
	        this.entryComponents = entryComponents;
	    }
	    Object.defineProperty(ComponentMetadata.prototype, "viewProviders", {
	        /**
	         * Defines the set of injectable objects that are visible to its view DOM children.
	         *
	         * ## Simple Example
	         *
	         * Here is an example of a class that can be injected:
	         *
	         * ```
	         * class Greeter {
	         *    greet(name:string) {
	         *      return 'Hello ' + name + '!';
	         *    }
	         * }
	         *
	         * @Directive({
	         *   selector: 'needs-greeter'
	         * })
	         * class NeedsGreeter {
	         *   greeter:Greeter;
	         *
	         *   constructor(greeter:Greeter) {
	         *     this.greeter = greeter;
	         *   }
	         * }
	         *
	         * @Component({
	         *   selector: 'greet',
	         *   viewProviders: [
	         *     Greeter
	         *   ],
	         *   template: `<needs-greeter></needs-greeter>`,
	         *   directives: [NeedsGreeter]
	         * })
	         * class HelloWorld {
	         * }
	         *
	         * ```
	         */
	        get: function () { return this._viewProviders; },
	        enumerable: true,
	        configurable: true
	    });
	    return ComponentMetadata;
	}(DirectiveMetadata));
	exports.ComponentMetadata = ComponentMetadata;
	/**
	 * Declare reusable pipe function.
	 *
	 * A "pure" pipe is only re-evaluated when either the input or any of the arguments change.
	 *
	 * When not specified, pipes default to being pure.
	 *
	 * ### Example
	 *
	 * {@example core/ts/metadata/metadata.ts region='pipe'}
	 * @stable
	 */
	var PipeMetadata = (function (_super) {
	    __extends(PipeMetadata, _super);
	    function PipeMetadata(_a) {
	        var name = _a.name, pure = _a.pure;
	        _super.call(this);
	        this.name = name;
	        this._pure = pure;
	    }
	    Object.defineProperty(PipeMetadata.prototype, "pure", {
	        get: function () { return lang_1.isPresent(this._pure) ? this._pure : true; },
	        enumerable: true,
	        configurable: true
	    });
	    return PipeMetadata;
	}(metadata_1.InjectableMetadata));
	exports.PipeMetadata = PipeMetadata;
	/**
	 * Declares a data-bound input property.
	 *
	 * Angular automatically updates data-bound properties during change detection.
	 *
	 * `InputMetadata` takes an optional parameter that specifies the name
	 * used when instantiating a component in the template. When not provided,
	 * the name of the decorated property is used.
	 *
	 * ### Example
	 *
	 * The following example creates a component with two input properties.
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'bank-account',
	 *   template: `
	 *     Bank Name: {{bankName}}
	 *     Account Id: {{id}}
	 *   `
	 * })
	 * class BankAccount {
	 *   @Input() bankName: string;
	 *   @Input('account-id') id: string;
	 *
	 *   // this property is not bound, and won't be automatically updated by Angular
	 *   normalizedBankName: string;
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
	 *   `,
	 *   directives: [BankAccount]
	 * })
	 * class App {}
	 *
	 * bootstrap(App);
	 * ```
	 * @stable
	 */
	var InputMetadata = (function () {
	    function InputMetadata(
	        /**
	         * Name used when instantiating a component in the template.
	         */
	        bindingPropertyName) {
	        this.bindingPropertyName = bindingPropertyName;
	    }
	    return InputMetadata;
	}());
	exports.InputMetadata = InputMetadata;
	/**
	 * Declares an event-bound output property.
	 *
	 * When an output property emits an event, an event handler attached to that event
	 * the template is invoked.
	 *
	 * `OutputMetadata` takes an optional parameter that specifies the name
	 * used when instantiating a component in the template. When not provided,
	 * the name of the decorated property is used.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * @Directive({
	 *   selector: 'interval-dir',
	 * })
	 * class IntervalDir {
	 *   @Output() everySecond = new EventEmitter();
	 *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();
	 *
	 *   constructor() {
	 *     setInterval(() => this.everySecond.emit("event"), 1000);
	 *     setInterval(() => this.five5Secs.emit("event"), 5000);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <interval-dir (everySecond)="everySecond()" (everyFiveSeconds)="everyFiveSeconds()">
	 *     </interval-dir>
	 *   `,
	 *   directives: [IntervalDir]
	 * })
	 * class App {
	 *   everySecond() { console.log('second'); }
	 *   everyFiveSeconds() { console.log('five seconds'); }
	 * }
	 * bootstrap(App);
	 * ```
	 * @stable
	 */
	var OutputMetadata = (function () {
	    function OutputMetadata(bindingPropertyName) {
	        this.bindingPropertyName = bindingPropertyName;
	    }
	    return OutputMetadata;
	}());
	exports.OutputMetadata = OutputMetadata;
	/**
	 * Declares a host property binding.
	 *
	 * Angular automatically checks host property bindings during change detection.
	 * If a binding changes, it will update the host element of the directive.
	 *
	 * `HostBindingMetadata` takes an optional parameter that specifies the property
	 * name of the host element that will be updated. When not provided,
	 * the class property name is used.
	 *
	 * ### Example
	 *
	 * The following example creates a directive that sets the `valid` and `invalid` classes
	 * on the DOM element that has ngModel directive on it.
	 *
	 * ```typescript
	 * @Directive({selector: '[ngModel]'})
	 * class NgModelStatus {
	 *   constructor(public control:NgModel) {}
	 *   @HostBinding('class.valid') get valid { return this.control.valid; }
	 *   @HostBinding('class.invalid') get invalid { return this.control.invalid; }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<input [(ngModel)]="prop">`,
	 *   directives: [FORM_DIRECTIVES, NgModelStatus]
	 * })
	 * class App {
	 *   prop;
	 * }
	 *
	 * bootstrap(App);
	 * ```
	 * @stable
	 */
	var HostBindingMetadata = (function () {
	    function HostBindingMetadata(hostPropertyName) {
	        this.hostPropertyName = hostPropertyName;
	    }
	    return HostBindingMetadata;
	}());
	exports.HostBindingMetadata = HostBindingMetadata;
	/**
	 * Declares a host listener.
	 *
	 * Angular will invoke the decorated method when the host element emits the specified event.
	 *
	 * If the decorated method returns `false`, then `preventDefault` is applied on the DOM
	 * event.
	 *
	 * ### Example
	 *
	 * The following example declares a directive that attaches a click listener to the button and
	 * counts clicks.
	 *
	 * ```typescript
	 * @Directive({selector: 'button[counting]'})
	 * class CountClicks {
	 *   numberOfClicks = 0;
	 *
	 *   @HostListener('click', ['$event.target'])
	 *   onClick(btn) {
	 *     console.log("button", btn, "number of clicks:", this.numberOfClicks++);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<button counting>Increment</button>`,
	 *   directives: [CountClicks]
	 * })
	 * class App {}
	 *
	 * bootstrap(App);
	 * ```
	 * @stable
	 */
	var HostListenerMetadata = (function () {
	    function HostListenerMetadata(eventName, args) {
	        this.eventName = eventName;
	        this.args = args;
	    }
	    return HostListenerMetadata;
	}());
	exports.HostListenerMetadata = HostListenerMetadata;
	//# sourceMappingURL=directives.js.map

/***/ },
/* 161 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * @stable
	 */
	(function (LifecycleHooks) {
	    LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
	    LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
	    LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
	    LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
	    LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
	    LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
	    LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
	    LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
	})(exports.LifecycleHooks || (exports.LifecycleHooks = {}));
	var LifecycleHooks = exports.LifecycleHooks;
	exports.LIFECYCLE_HOOKS_VALUES = [
	    LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,
	    LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,
	    LifecycleHooks.AfterViewChecked
	];
	/**
	 * Lifecycle hooks are guaranteed to be called in the following order:
	 * - `OnChanges` (if any bindings have changed),
	 * - `OnInit` (after the first check only),
	 * - `DoCheck`,
	 * - `AfterContentInit`,
	 * - `AfterContentChecked`,
	 * - `AfterViewInit`,
	 * - `AfterViewChecked`,
	 * - `OnDestroy` (at the very end before destruction)
	 */
	/**
	 * Implement this interface to get notified when any data-bound property of your directive changes.
	 *
	 * `ngOnChanges` is called right after the data-bound properties have been checked and before view
	 * and content children are checked if at least one of them has changed.
	 *
	 * The `changes` parameter contains an entry for each of the changed data-bound property. The key is
	 * the property name and the value is an instance of {@link SimpleChange}.
	 *
	 * ### Example ([live example](http://plnkr.co/edit/AHrB6opLqHDBPkt4KpdT?p=preview)):
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'my-cmp',
	 *   template: `<p>myProp = {{myProp}}</p>`
	 * })
	 * class MyComponent implements OnChanges {
	 *   @Input() myProp: any;
	 *
	 *   ngOnChanges(changes: SimpleChanges) {
	 *     console.log('ngOnChanges - myProp = ' + changes['myProp'].currentValue);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <button (click)="value = value + 1">Change MyComponent</button>
	 *     <my-cmp [my-prop]="value"></my-cmp>`,
	 *   directives: [MyComponent]
	 * })
	 * export class App {
	 *   value = 0;
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 * @stable
	 */
	var OnChanges = (function () {
	    function OnChanges() {
	    }
	    return OnChanges;
	}());
	exports.OnChanges = OnChanges;
	/**
	 * Implement this interface to execute custom initialization logic after your directive's
	 * data-bound properties have been initialized.
	 *
	 * `ngOnInit` is called right after the directive's data-bound properties have been checked for the
	 * first time, and before any of its children have been checked. It is invoked only once when the
	 * directive is instantiated.
	 *
	 * ### Example ([live example](http://plnkr.co/edit/1MBypRryXd64v4pV03Yn?p=preview))
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'my-cmp',
	 *   template: `<p>my-component</p>`
	 * })
	 * class MyComponent implements OnInit, OnDestroy {
	 *   ngOnInit() {
	 *     console.log('ngOnInit');
	 *   }
	 *
	 *   ngOnDestroy() {
	 *     console.log('ngOnDestroy');
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <button (click)="hasChild = !hasChild">
	 *       {{hasChild ? 'Destroy' : 'Create'}} MyComponent
	 *     </button>
	 *     <my-cmp *ngIf="hasChild"></my-cmp>`,
	 *   directives: [MyComponent, NgIf]
	 * })
	 * export class App {
	 *   hasChild = true;
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 *  ```
	 * @stable
	 */
	var OnInit = (function () {
	    function OnInit() {
	    }
	    return OnInit;
	}());
	exports.OnInit = OnInit;
	/**
	 * Implement this interface to supplement the default change detection algorithm in your directive.
	 *
	 * `ngDoCheck` gets called to check the changes in the directives in addition to the default
	 * algorithm.
	 *
	 * The default change detection algorithm looks for differences by comparing bound-property values
	 * by reference across change detection runs.
	 *
	 * Note that a directive typically should not use both `DoCheck` and {@link OnChanges} to respond to
	 * changes on the same input. `ngOnChanges` will continue to be called when the default change
	 * detector
	 * detects changes, so it is usually unnecessary to respond to changes on the same input in both
	 * hooks.
	 * Reaction to the changes have to be handled from within the `ngDoCheck` callback.
	 *
	 * You can use {@link KeyValueDiffers} and {@link IterableDiffers} to help add your custom check
	 * mechanisms.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/QpnIlF0CR2i5bcYbHEUJ?p=preview))
	 *
	 * In the following example `ngDoCheck` uses an {@link IterableDiffers} to detect the updates to the
	 * array `list`:
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'custom-check',
	 *   template: `
	 *     <p>Changes:</p>
	 *     <ul>
	 *       <li *ngFor="let line of logs">{{line}}</li>
	 *     </ul>`,
	 *   directives: [NgFor]
	 * })
	 * class CustomCheckComponent implements DoCheck {
	 *   @Input() list: any[];
	 *   differ: any;
	 *   logs = [];
	 *
	 *   constructor(differs: IterableDiffers) {
	 *     this.differ = differs.find([]).create(null);
	 *   }
	 *
	 *   ngDoCheck() {
	 *     var changes = this.differ.diff(this.list);
	 *
	 *     if (changes) {
	 *       changes.forEachAddedItem(r => this.logs.push('added ' + r.item));
	 *       changes.forEachRemovedItem(r => this.logs.push('removed ' + r.item))
	 *     }
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <button (click)="list.push(list.length)">Push</button>
	 *     <button (click)="list.pop()">Pop</button>
	 *     <custom-check [list]="list"></custom-check>`,
	 *   directives: [CustomCheckComponent]
	 * })
	 * export class App {
	 *   list = [];
	 * }
	 * ```
	 * @stable
	 */
	var DoCheck = (function () {
	    function DoCheck() {
	    }
	    return DoCheck;
	}());
	exports.DoCheck = DoCheck;
	/**
	 * Implement this interface to get notified when your directive is destroyed.
	 *
	 * `ngOnDestroy` callback is typically used for any custom cleanup that needs to occur when the
	 * instance is destroyed
	 *
	 * ### Example ([live example](http://plnkr.co/edit/1MBypRryXd64v4pV03Yn?p=preview))
	 *
	 * ```typesript
	 * @Component({
	 *   selector: 'my-cmp',
	 *   template: `<p>my-component</p>`
	 * })
	 * class MyComponent implements OnInit, OnDestroy {
	 *   ngOnInit() {
	 *     console.log('ngOnInit');
	 *   }
	 *
	 *   ngOnDestroy() {
	 *     console.log('ngOnDestroy');
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <button (click)="hasChild = !hasChild">
	 *       {{hasChild ? 'Destroy' : 'Create'}} MyComponent
	 *     </button>
	 *     <my-cmp *ngIf="hasChild"></my-cmp>`,
	 *   directives: [MyComponent, NgIf]
	 * })
	 * export class App {
	 *   hasChild = true;
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 *
	 *
	 * To create a stateful Pipe, you should implement this interface and set the `pure`
	 * parameter to `false` in the {@link PipeMetadata}.
	 *
	 * A stateful pipe may produce different output, given the same input. It is
	 * likely that a stateful pipe may contain state that should be cleaned up when
	 * a binding is destroyed. For example, a subscription to a stream of data may need to
	 * be disposed, or an interval may need to be cleared.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/i8pm5brO4sPaLxBx56MR?p=preview))
	 *
	 * In this example, a pipe is created to countdown its input value, updating it every
	 * 50ms. Because it maintains an internal interval, it automatically clears
	 * the interval when the binding is destroyed or the countdown completes.
	 *
	 * ```
	 * import {OnDestroy, Pipe, PipeTransform} from '@angular/core'
	 * @Pipe({name: 'countdown', pure: false})
	 * class CountDown implements PipeTransform, OnDestroy {
	 *   remainingTime:Number;
	 *   interval:SetInterval;
	 *   ngOnDestroy() {
	 *     if (this.interval) {
	 *       clearInterval(this.interval);
	 *     }
	 *   }
	 *   transform(value: any, args: any[] = []) {
	 *     if (!parseInt(value, 10)) return null;
	 *     if (typeof this.remainingTime !== 'number') {
	 *       this.remainingTime = parseInt(value, 10);
	 *     }
	 *     if (!this.interval) {
	 *       this.interval = setInterval(() => {
	 *         this.remainingTime-=50;
	 *         if (this.remainingTime <= 0) {
	 *           this.remainingTime = 0;
	 *           clearInterval(this.interval);
	 *           delete this.interval;
	 *         }
	 *       }, 50);
	 *     }
	 *     return this.remainingTime;
	 *   }
	 * }
	 * ```
	 *
	 * Invoking `{{ 10000 | countdown }}` would cause the value to be decremented by 50,
	 * every 50ms, until it reaches 0.
	 *
	 * @stable
	 */
	var OnDestroy = (function () {
	    function OnDestroy() {
	    }
	    return OnDestroy;
	}());
	exports.OnDestroy = OnDestroy;
	/**
	 * Implement this interface to get notified when your directive's content has been fully
	 * initialized.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/plamXUpsLQbIXpViZhUO?p=preview))
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: `{{where}} child`
	 * })
	 * class ChildComponent {
	 *   @Input() where: string;
	 * }
	 *
	 * @Component({
	 *   selector: 'parent-cmp',
	 *   template: `<ng-content></ng-content>`
	 * })
	 * class ParentComponent implements AfterContentInit {
	 *   @ContentChild(ChildComponent) contentChild: ChildComponent;
	 *
	 *   constructor() {
	 *     // contentChild is not initialized yet
	 *     console.log(this.getMessage(this.contentChild));
	 *   }
	 *
	 *   ngAfterContentInit() {
	 *     // contentChild is updated after the content has been checked
	 *     console.log('AfterContentInit: ' + this.getMessage(this.contentChild));
	 *   }
	 *
	 *   private getMessage(cmp: ChildComponent): string {
	 *     return cmp ? cmp.where + ' child' : 'no child';
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <parent-cmp>
	 *       <child-cmp where="content"></child-cmp>
	 *     </parent-cmp>`,
	 *   directives: [ParentComponent, ChildComponent]
	 * })
	 * export class App {
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 * @stable
	 */
	var AfterContentInit = (function () {
	    function AfterContentInit() {
	    }
	    return AfterContentInit;
	}());
	exports.AfterContentInit = AfterContentInit;
	/**
	 * Implement this interface to get notified after every check of your directive's content.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/tGdrytNEKQnecIPkD7NU?p=preview))
	 *
	 * ```typescript
	 * @Component({selector: 'child-cmp', template: `{{where}} child`})
	 * class ChildComponent {
	 *   @Input() where: string;
	 * }
	 *
	 * @Component({selector: 'parent-cmp', template: `<ng-content></ng-content>`})
	 * class ParentComponent implements AfterContentChecked {
	 *   @ContentChild(ChildComponent) contentChild: ChildComponent;
	 *
	 *   constructor() {
	 *     // contentChild is not initialized yet
	 *     console.log(this.getMessage(this.contentChild));
	 *   }
	 *
	 *   ngAfterContentChecked() {
	 *     // contentChild is updated after the content has been checked
	 *     console.log('AfterContentChecked: ' + this.getMessage(this.contentChild));
	 *   }
	 *
	 *   private getMessage(cmp: ChildComponent): string {
	 *     return cmp ? cmp.where + ' child' : 'no child';
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <parent-cmp>
	 *       <button (click)="hasContent = !hasContent">Toggle content child</button>
	 *       <child-cmp *ngIf="hasContent" where="content"></child-cmp>
	 *     </parent-cmp>`,
	 *   directives: [NgIf, ParentComponent, ChildComponent]
	 * })
	 * export class App {
	 *   hasContent = true;
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 * @stable
	 */
	var AfterContentChecked = (function () {
	    function AfterContentChecked() {
	    }
	    return AfterContentChecked;
	}());
	exports.AfterContentChecked = AfterContentChecked;
	/**
	 * Implement this interface to get notified when your component's view has been fully initialized.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/LhTKVMEM0fkJgyp4CI1W?p=preview))
	 *
	 * ```typescript
	 * @Component({selector: 'child-cmp', template: `{{where}} child`})
	 * class ChildComponent {
	 *   @Input() where: string;
	 * }
	 *
	 * @Component({
	 *   selector: 'parent-cmp',
	 *   template: `<child-cmp where="view"></child-cmp>`,
	 *   directives: [ChildComponent]
	 * })
	 * class ParentComponent implements AfterViewInit {
	 *   @ViewChild(ChildComponent) viewChild: ChildComponent;
	 *
	 *   constructor() {
	 *     // viewChild is not initialized yet
	 *     console.log(this.getMessage(this.viewChild));
	 *   }
	 *
	 *   ngAfterViewInit() {
	 *     // viewChild is updated after the view has been initialized
	 *     console.log('ngAfterViewInit: ' + this.getMessage(this.viewChild));
	 *   }
	 *
	 *   private getMessage(cmp: ChildComponent): string {
	 *     return cmp ? cmp.where + ' child' : 'no child';
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<parent-cmp></parent-cmp>`,
	 *   directives: [ParentComponent]
	 * })
	 * export class App {
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 * @stable
	 */
	var AfterViewInit = (function () {
	    function AfterViewInit() {
	    }
	    return AfterViewInit;
	}());
	exports.AfterViewInit = AfterViewInit;
	/**
	 * Implement this interface to get notified after every check of your component's view.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/0qDGHcPQkc25CXhTNzKU?p=preview))
	 *
	 * ```typescript
	 * @Component({selector: 'child-cmp', template: `{{where}} child`})
	 * class ChildComponent {
	 *   @Input() where: string;
	 * }
	 *
	 * @Component({
	 *   selector: 'parent-cmp',
	 *   template: `
	 *     <button (click)="showView = !showView">Toggle view child</button>
	 *     <child-cmp *ngIf="showView" where="view"></child-cmp>`,
	 *   directives: [NgIf, ChildComponent]
	 * })
	 * class ParentComponent implements AfterViewChecked {
	 *   @ViewChild(ChildComponent) viewChild: ChildComponent;
	 *   showView = true;
	 *
	 *   constructor() {
	 *     // viewChild is not initialized yet
	 *     console.log(this.getMessage(this.viewChild));
	 *   }
	 *
	 *   ngAfterViewChecked() {
	 *     // viewChild is updated after the view has been checked
	 *     console.log('AfterViewChecked: ' + this.getMessage(this.viewChild));
	 *   }
	 *
	 *   private getMessage(cmp: ChildComponent): string {
	 *     return cmp ? cmp.where + ' child' : 'no child';
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<parent-cmp></parent-cmp>`,
	 *   directives: [ParentComponent]
	 * })
	 * export class App {
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 * @stable
	 */
	var AfterViewChecked = (function () {
	    function AfterViewChecked() {
	    }
	    return AfterViewChecked;
	}());
	exports.AfterViewChecked = AfterViewChecked;
	//# sourceMappingURL=lifecycle_hooks.js.map

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var metadata_1 = __webpack_require__(22);
	/**
	 * Defines a schema that will allow any property on elements with a `-` in their name,
	 * which is the common rule for custom elements.
	 *
	 * @experimental
	 */
	exports.CUSTOM_ELEMENTS_SCHEMA = {
	    name: 'custom-elements'
	};
	/**
	 * Declares an Angular Module.
	 * @experimental
	 */
	var NgModuleMetadata = (function (_super) {
	    __extends(NgModuleMetadata, _super);
	    function NgModuleMetadata(options) {
	        if (options === void 0) { options = {}; }
	        // We cannot use destructuring of the constructor argument because `exports` is a
	        // protected symbol in CommonJS and closure tries to aggressively optimize it away.
	        _super.call(this);
	        this._providers = options.providers;
	        this.declarations = options.declarations;
	        this.imports = options.imports;
	        this.exports = options.exports;
	        this.entryComponents = options.entryComponents;
	        this.bootstrap = options.bootstrap;
	        this.schemas = options.schemas;
	    }
	    Object.defineProperty(NgModuleMetadata.prototype, "providers", {
	        /**
	         * Defines the set of injectable objects that are available in the injector
	         * of this module.
	         *
	         * ## Simple Example
	         *
	         * Here is an example of a class that can be injected:
	         *
	         * ```
	         * class Greeter {
	         *    greet(name:string) {
	         *      return 'Hello ' + name + '!';
	         *    }
	         * }
	         *
	         * @NgModule({
	         *   providers: [
	         *     Greeter
	         *   ]
	         * })
	         * class HelloWorld {
	         *   greeter:Greeter;
	         *
	         *   constructor(greeter:Greeter) {
	         *     this.greeter = greeter;
	         *   }
	         * }
	         * ```
	         */
	        get: function () { return this._providers; },
	        enumerable: true,
	        configurable: true
	    });
	    return NgModuleMetadata;
	}(metadata_1.InjectableMetadata));
	exports.NgModuleMetadata = NgModuleMetadata;
	//# sourceMappingURL=ng_module.js.map

/***/ },
/* 163 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * Defines template and style encapsulation options available for Component's {@link Component}.
	 *
	 * See {@link ViewMetadata#encapsulation}.
	 * @stable
	 */
	(function (ViewEncapsulation) {
	    /**
	     * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
	     * Element and pre-processing the style rules provided via
	     * {@link ViewMetadata#styles} or {@link ViewMetadata#stylesUrls}, and adding the new Host Element
	     * attribute to all selectors.
	     *
	     * This is the default option.
	     */
	    ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
	    /**
	     * Use the native encapsulation mechanism of the renderer.
	     *
	     * For the DOM this means using [Shadow DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
	     * creating a ShadowRoot for Component's Host Element.
	     */
	    ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
	    /**
	     * Don't provide any template or style encapsulation.
	     */
	    ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
	})(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));
	var ViewEncapsulation = exports.ViewEncapsulation;
	exports.VIEW_ENCAPSULATION_VALUES = [ViewEncapsulation.Emulated, ViewEncapsulation.Native, ViewEncapsulation.None];
	/**
	 * Metadata properties available for configuring Views.
	 *
	 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
	 * `@View` annotation specifies the HTML template to use, and lists the directives that are active
	 * within the template.
	 *
	 * When a component is instantiated, the template is loaded into the component's shadow root, and
	 * the expressions and statements in the template are evaluated against the component.
	 *
	 * For details on the `@Component` annotation, see {@link ComponentMetadata}.
	 *
	 * ### Example
	 *
	 * ```
	 * @Component({
	 *   selector: 'greet',
	 *   template: 'Hello {{name}}!',
	 *   directives: [GreetUser, Bold]
	 * })
	 * class Greet {
	 *   name: string;
	 *
	 *   constructor() {
	 *     this.name = 'World';
	 *   }
	 * }
	 * ```
	 *
	 * @deprecated Use ComponentMetadata instead.
	 */
	var ViewMetadata = (function () {
	    function ViewMetadata(_a) {
	        var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template, directives = _b.directives, pipes = _b.pipes, encapsulation = _b.encapsulation, styles = _b.styles, styleUrls = _b.styleUrls, animations = _b.animations, interpolation = _b.interpolation;
	        this.templateUrl = templateUrl;
	        this.template = template;
	        this.styleUrls = styleUrls;
	        this.styles = styles;
	        this.directives = directives;
	        this.pipes = pipes;
	        this.encapsulation = encapsulation;
	        this.animations = animations;
	        this.interpolation = interpolation;
	    }
	    return ViewMetadata;
	}());
	exports.ViewMetadata = ViewMetadata;
	//# sourceMappingURL=view.js.map

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var ReflectionCapabilities = (function () {
	    function ReflectionCapabilities(reflect) {
	        this._reflect = lang_1.isPresent(reflect) ? reflect : lang_1.global.Reflect;
	    }
	    ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };
	    ReflectionCapabilities.prototype.factory = function (t) {
	        switch (t.length) {
	            case 0:
	                return function () { return new t(); };
	            case 1:
	                return function (a1) { return new t(a1); };
	            case 2:
	                return function (a1, a2) { return new t(a1, a2); };
	            case 3:
	                return function (a1, a2, a3) { return new t(a1, a2, a3); };
	            case 4:
	                return function (a1, a2, a3, a4) { return new t(a1, a2, a3, a4); };
	            case 5:
	                return function (a1, a2, a3, a4, a5) { return new t(a1, a2, a3, a4, a5); };
	            case 6:
	                return function (a1, a2, a3, a4, a5, a6) {
	                    return new t(a1, a2, a3, a4, a5, a6);
	                };
	            case 7:
	                return function (a1, a2, a3, a4, a5, a6, a7) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7);
	                };
	            case 8:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8);
	                };
	            case 9:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9);
	                };
	            case 10:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	                };
	            case 11:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	                };
	            case 12:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	                };
	            case 13:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	                };
	            case 14:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	                };
	            case 15:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	                };
	            case 16:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
	                };
	            case 17:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
	                };
	            case 18:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
	                };
	            case 19:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
	                };
	            case 20:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
	                };
	        }
	        ;
	        throw new Error("Cannot create a factory for '" + lang_1.stringify(t) + "' because its constructor has more than 20 arguments");
	    };
	    /** @internal */
	    ReflectionCapabilities.prototype._zipTypesAndAnnotations = function (paramTypes /** TODO #9100 */, paramAnnotations /** TODO #9100 */) {
	        var result;
	        if (typeof paramTypes === 'undefined') {
	            result = new Array(paramAnnotations.length);
	        }
	        else {
	            result = new Array(paramTypes.length);
	        }
	        for (var i = 0; i < result.length; i++) {
	            // TS outputs Object for parameters without types, while Traceur omits
	            // the annotations. For now we preserve the Traceur behavior to aid
	            // migration, but this can be revisited.
	            if (typeof paramTypes === 'undefined') {
	                result[i] = [];
	            }
	            else if (paramTypes[i] != Object) {
	                result[i] = [paramTypes[i]];
	            }
	            else {
	                result[i] = [];
	            }
	            if (lang_1.isPresent(paramAnnotations) && lang_1.isPresent(paramAnnotations[i])) {
	                result[i] = result[i].concat(paramAnnotations[i]);
	            }
	        }
	        return result;
	    };
	    ReflectionCapabilities.prototype.parameters = function (typeOrFunc) {
	        // Prefer the direct API.
	        if (lang_1.isPresent(typeOrFunc.parameters)) {
	            return typeOrFunc.parameters;
	        }
	        // API of tsickle for lowering decorators to properties on the class.
	        if (lang_1.isPresent(typeOrFunc.ctorParameters)) {
	            var ctorParameters = typeOrFunc.ctorParameters;
	            var paramTypes_1 = ctorParameters.map(function (ctorParam /** TODO #9100 */) { return ctorParam && ctorParam.type; });
	            var paramAnnotations_1 = ctorParameters.map(function (ctorParam /** TODO #9100 */) {
	                return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators);
	            });
	            return this._zipTypesAndAnnotations(paramTypes_1, paramAnnotations_1);
	        }
	        // API for metadata created by invoking the decorators.
	        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
	            var paramAnnotations = this._reflect.getMetadata('parameters', typeOrFunc);
	            var paramTypes = this._reflect.getMetadata('design:paramtypes', typeOrFunc);
	            if (lang_1.isPresent(paramTypes) || lang_1.isPresent(paramAnnotations)) {
	                return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
	            }
	        }
	        // The array has to be filled with `undefined` because holes would be skipped by `some`
	        var parameters = new Array(typeOrFunc.length);
	        parameters.fill(undefined);
	        return parameters;
	    };
	    ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {
	        // Prefer the direct API.
	        if (lang_1.isPresent(typeOrFunc.annotations)) {
	            var annotations = typeOrFunc.annotations;
	            if (lang_1.isFunction(annotations) && annotations.annotations) {
	                annotations = annotations.annotations;
	            }
	            return annotations;
	        }
	        // API of tsickle for lowering decorators to properties on the class.
	        if (lang_1.isPresent(typeOrFunc.decorators)) {
	            return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
	        }
	        // API for metadata created by invoking the decorators.
	        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
	            var annotations = this._reflect.getMetadata('annotations', typeOrFunc);
	            if (lang_1.isPresent(annotations))
	                return annotations;
	        }
	        return [];
	    };
	    ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {
	        // Prefer the direct API.
	        if (lang_1.isPresent(typeOrFunc.propMetadata)) {
	            var propMetadata = typeOrFunc.propMetadata;
	            if (lang_1.isFunction(propMetadata) && propMetadata.propMetadata) {
	                propMetadata = propMetadata.propMetadata;
	            }
	            return propMetadata;
	        }
	        // API of tsickle for lowering decorators to properties on the class.
	        if (lang_1.isPresent(typeOrFunc.propDecorators)) {
	            var propDecorators_1 = typeOrFunc.propDecorators;
	            var propMetadata_1 = {};
	            Object.keys(propDecorators_1).forEach(function (prop) {
	                propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);
	            });
	            return propMetadata_1;
	        }
	        // API for metadata created by invoking the decorators.
	        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
	            var propMetadata = this._reflect.getMetadata('propMetadata', typeOrFunc);
	            if (lang_1.isPresent(propMetadata))
	                return propMetadata;
	        }
	        return {};
	    };
	    // Note: JavaScript does not support to query for interfaces during runtime.
	    // However, we can't throw here as the reflector will always call this method
	    // when asked for a lifecycle interface as this is what we check in Dart.
	    ReflectionCapabilities.prototype.interfaces = function (type) { return []; };
	    ReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcInterface, lcProperty) {
	        if (!(type instanceof lang_1.Type))
	            return false;
	        var proto = type.prototype;
	        return !!proto[lcProperty];
	    };
	    ReflectionCapabilities.prototype.getter = function (name) { return new Function('o', 'return o.' + name + ';'); };
	    ReflectionCapabilities.prototype.setter = function (name) {
	        return new Function('o', 'v', 'return o.' + name + ' = v;');
	    };
	    ReflectionCapabilities.prototype.method = function (name) {
	        var functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
	        return new Function('o', 'args', functionBody);
	    };
	    // There is not a concept of import uri in Js, but this is useful in developing Dart applications.
	    ReflectionCapabilities.prototype.importUri = function (type) {
	        // StaticSymbol
	        if (typeof type === 'object' && type['filePath']) {
	            return type['filePath'];
	        }
	        // Runtime type
	        return "./" + lang_1.stringify(type);
	    };
	    return ReflectionCapabilities;
	}());
	exports.ReflectionCapabilities = ReflectionCapabilities;
	function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
	    if (!decoratorInvocations) {
	        return [];
	    }
	    return decoratorInvocations.map(function (decoratorInvocation) {
	        var decoratorType = decoratorInvocation.type;
	        var annotationCls = decoratorType.annotationCls;
	        var annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
	        var annotation = Object.create(annotationCls.prototype);
	        annotationCls.apply(annotation, annotationArgs);
	        return annotation;
	    });
	}
	//# sourceMappingURL=reflection_capabilities.js.map

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(4);
	var lang_1 = __webpack_require__(2);
	var reflector_reader_1 = __webpack_require__(98);
	/**
	 * Reflective information about a symbol, including annotations, interfaces, and other metadata.
	 */
	var ReflectionInfo = (function () {
	    function ReflectionInfo(annotations, parameters, factory, interfaces, propMetadata) {
	        this.annotations = annotations;
	        this.parameters = parameters;
	        this.factory = factory;
	        this.interfaces = interfaces;
	        this.propMetadata = propMetadata;
	    }
	    return ReflectionInfo;
	}());
	exports.ReflectionInfo = ReflectionInfo;
	/**
	 * Provides access to reflection data about symbols. Used internally by Angular
	 * to power dependency injection and compilation.
	 */
	var Reflector = (function (_super) {
	    __extends(Reflector, _super);
	    function Reflector(reflectionCapabilities) {
	        _super.call(this);
	        /** @internal */
	        this._injectableInfo = new collection_1.Map();
	        /** @internal */
	        this._getters = new collection_1.Map();
	        /** @internal */
	        this._setters = new collection_1.Map();
	        /** @internal */
	        this._methods = new collection_1.Map();
	        this._usedKeys = null;
	        this.reflectionCapabilities = reflectionCapabilities;
	    }
	    Reflector.prototype.updateCapabilities = function (caps) { this.reflectionCapabilities = caps; };
	    Reflector.prototype.isReflectionEnabled = function () { return this.reflectionCapabilities.isReflectionEnabled(); };
	    /**
	     * Causes `this` reflector to track keys used to access
	     * {@link ReflectionInfo} objects.
	     */
	    Reflector.prototype.trackUsage = function () { this._usedKeys = new collection_1.Set(); };
	    /**
	     * Lists types for which reflection information was not requested since
	     * {@link #trackUsage} was called. This list could later be audited as
	     * potential dead code.
	     */
	    Reflector.prototype.listUnusedKeys = function () {
	        var _this = this;
	        if (this._usedKeys == null) {
	            throw new exceptions_1.BaseException('Usage tracking is disabled');
	        }
	        var allTypes = collection_1.MapWrapper.keys(this._injectableInfo);
	        return allTypes.filter(function (key) { return !collection_1.SetWrapper.has(_this._usedKeys, key); });
	    };
	    Reflector.prototype.registerFunction = function (func, funcInfo) {
	        this._injectableInfo.set(func, funcInfo);
	    };
	    Reflector.prototype.registerType = function (type, typeInfo) {
	        this._injectableInfo.set(type, typeInfo);
	    };
	    Reflector.prototype.registerGetters = function (getters) { _mergeMaps(this._getters, getters); };
	    Reflector.prototype.registerSetters = function (setters) { _mergeMaps(this._setters, setters); };
	    Reflector.prototype.registerMethods = function (methods) { _mergeMaps(this._methods, methods); };
	    Reflector.prototype.factory = function (type) {
	        if (this._containsReflectionInfo(type)) {
	            var res = this._getReflectionInfo(type).factory;
	            return lang_1.isPresent(res) ? res : null;
	        }
	        else {
	            return this.reflectionCapabilities.factory(type);
	        }
	    };
	    Reflector.prototype.parameters = function (typeOrFunc) {
	        if (this._injectableInfo.has(typeOrFunc)) {
	            var res = this._getReflectionInfo(typeOrFunc).parameters;
	            return lang_1.isPresent(res) ? res : [];
	        }
	        else {
	            return this.reflectionCapabilities.parameters(typeOrFunc);
	        }
	    };
	    Reflector.prototype.annotations = function (typeOrFunc) {
	        if (this._injectableInfo.has(typeOrFunc)) {
	            var res = this._getReflectionInfo(typeOrFunc).annotations;
	            return lang_1.isPresent(res) ? res : [];
	        }
	        else {
	            return this.reflectionCapabilities.annotations(typeOrFunc);
	        }
	    };
	    Reflector.prototype.propMetadata = function (typeOrFunc) {
	        if (this._injectableInfo.has(typeOrFunc)) {
	            var res = this._getReflectionInfo(typeOrFunc).propMetadata;
	            return lang_1.isPresent(res) ? res : {};
	        }
	        else {
	            return this.reflectionCapabilities.propMetadata(typeOrFunc);
	        }
	    };
	    Reflector.prototype.interfaces = function (type) {
	        if (this._injectableInfo.has(type)) {
	            var res = this._getReflectionInfo(type).interfaces;
	            return lang_1.isPresent(res) ? res : [];
	        }
	        else {
	            return this.reflectionCapabilities.interfaces(type);
	        }
	    };
	    Reflector.prototype.hasLifecycleHook = function (type, lcInterface, lcProperty) {
	        var interfaces = this.interfaces(type);
	        if (interfaces.indexOf(lcInterface) !== -1) {
	            return true;
	        }
	        else {
	            return this.reflectionCapabilities.hasLifecycleHook(type, lcInterface, lcProperty);
	        }
	    };
	    Reflector.prototype.getter = function (name) {
	        if (this._getters.has(name)) {
	            return this._getters.get(name);
	        }
	        else {
	            return this.reflectionCapabilities.getter(name);
	        }
	    };
	    Reflector.prototype.setter = function (name) {
	        if (this._setters.has(name)) {
	            return this._setters.get(name);
	        }
	        else {
	            return this.reflectionCapabilities.setter(name);
	        }
	    };
	    Reflector.prototype.method = function (name) {
	        if (this._methods.has(name)) {
	            return this._methods.get(name);
	        }
	        else {
	            return this.reflectionCapabilities.method(name);
	        }
	    };
	    /** @internal */
	    Reflector.prototype._getReflectionInfo = function (typeOrFunc) {
	        if (lang_1.isPresent(this._usedKeys)) {
	            this._usedKeys.add(typeOrFunc);
	        }
	        return this._injectableInfo.get(typeOrFunc);
	    };
	    /** @internal */
	    Reflector.prototype._containsReflectionInfo = function (typeOrFunc) { return this._injectableInfo.has(typeOrFunc); };
	    Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };
	    return Reflector;
	}(reflector_reader_1.ReflectorReader));
	exports.Reflector = Reflector;
	function _mergeMaps(target, config) {
	    collection_1.StringMapWrapper.forEach(config, function (v, k) { return target.set(k, v); });
	}
	//# sourceMappingURL=reflector.js.map

/***/ },
/* 166 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property
	 * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly
	 * handled.
	 *
	 * See DomSanitizationService for more details on security in Angular applications.
	 *
	 * @stable
	 */
	(function (SecurityContext) {
	    SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
	    SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
	    SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
	    SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
	    SecurityContext[SecurityContext["URL"] = 4] = "URL";
	    SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
	})(exports.SecurityContext || (exports.SecurityContext = {}));
	var SecurityContext = exports.SecurityContext;
	/**
	 * SanitizationService is used by the views to sanitize potentially dangerous values.
	 *
	 * @stable
	 */
	var SanitizationService = (function () {
	    function SanitizationService() {
	    }
	    return SanitizationService;
	}());
	exports.SanitizationService = SanitizationService;
	//# sourceMappingURL=security.js.map

/***/ },
/* 167 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * Stores error information; delivered via [NgZone.onError] stream.
	 * @deprecated
	 */
	var NgZoneError = (function () {
	    function NgZoneError(error, stackTrace) {
	        this.error = error;
	        this.stackTrace = stackTrace;
	    }
	    return NgZoneError;
	}());
	exports.NgZoneError = NgZoneError;
	var NgZoneImpl = (function () {
	    function NgZoneImpl(_a) {
	        var _this = this;
	        var trace = _a.trace, onEnter = _a.onEnter, onLeave = _a.onLeave, setMicrotask = _a.setMicrotask, setMacrotask = _a.setMacrotask, onError = _a.onError;
	        this.onEnter = onEnter;
	        this.onLeave = onLeave;
	        this.setMicrotask = setMicrotask;
	        this.setMacrotask = setMacrotask;
	        this.onError = onError;
	        if (Zone) {
	            this.outer = this.inner = Zone.current;
	            if (Zone['wtfZoneSpec']) {
	                this.inner = this.inner.fork(Zone['wtfZoneSpec']);
	            }
	            if (trace && Zone['longStackTraceZoneSpec']) {
	                this.inner = this.inner.fork(Zone['longStackTraceZoneSpec']);
	            }
	            this.inner = this.inner.fork({
	                name: 'angular',
	                properties: { 'isAngularZone': true },
	                onInvokeTask: function (delegate, current, target, task, applyThis, applyArgs) {
	                    try {
	                        _this.onEnter();
	                        return delegate.invokeTask(target, task, applyThis, applyArgs);
	                    }
	                    finally {
	                        _this.onLeave();
	                    }
	                },
	                onInvoke: function (delegate, current, target, callback, applyThis, applyArgs, source) {
	                    try {
	                        _this.onEnter();
	                        return delegate.invoke(target, callback, applyThis, applyArgs, source);
	                    }
	                    finally {
	                        _this.onLeave();
	                    }
	                },
	                onHasTask: function (delegate, current, target, hasTaskState) {
	                    delegate.hasTask(target, hasTaskState);
	                    if (current == target) {
	                        // We are only interested in hasTask events which originate from our zone
	                        // (A child hasTask event is not interesting to us)
	                        if (hasTaskState.change == 'microTask') {
	                            _this.setMicrotask(hasTaskState.microTask);
	                        }
	                        else if (hasTaskState.change == 'macroTask') {
	                            _this.setMacrotask(hasTaskState.macroTask);
	                        }
	                    }
	                },
	                onHandleError: function (delegate, current, target, error) {
	                    delegate.handleError(target, error);
	                    _this.onError(new NgZoneError(error, error.stack));
	                    return false;
	                }
	            });
	        }
	        else {
	            throw new Error('Angular requires Zone.js polyfill.');
	        }
	    }
	    NgZoneImpl.isInAngularZone = function () { return Zone.current.get('isAngularZone') === true; };
	    NgZoneImpl.prototype.runInner = function (fn) { return this.inner.run(fn); };
	    ;
	    NgZoneImpl.prototype.runInnerGuarded = function (fn) { return this.inner.runGuarded(fn); };
	    ;
	    NgZoneImpl.prototype.runOuter = function (fn) { return this.outer.run(fn); };
	    ;
	    return NgZoneImpl;
	}());
	exports.NgZoneImpl = NgZoneImpl;
	//# sourceMappingURL=ng_zone_impl.js.map

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(11);
	var _nextRequestId = 0;
	exports.JSONP_HOME = '__ng_jsonp__';
	var _jsonpConnections = null;
	function _getJsonpConnections() {
	    if (_jsonpConnections === null) {
	        _jsonpConnections = lang_1.global[exports.JSONP_HOME] = {};
	    }
	    return _jsonpConnections;
	}
	var BrowserJsonp = (function () {
	    function BrowserJsonp() {
	    }
	    // Construct a <script> element with the specified URL
	    BrowserJsonp.prototype.build = function (url) {
	        var node = document.createElement('script');
	        node.src = url;
	        return node;
	    };
	    BrowserJsonp.prototype.nextRequestID = function () { return "__req" + _nextRequestId++; };
	    BrowserJsonp.prototype.requestCallback = function (id) { return exports.JSONP_HOME + "." + id + ".finished"; };
	    BrowserJsonp.prototype.exposeConnection = function (id, connection) {
	        var connections = _getJsonpConnections();
	        connections[id] = connection;
	    };
	    BrowserJsonp.prototype.removeConnection = function (id) {
	        var connections = _getJsonpConnections();
	        connections[id] = null;
	    };
	    // Attach the <script> element to the DOM
	    BrowserJsonp.prototype.send = function (node) { document.body.appendChild((node)); };
	    // Remove <script> element from the DOM
	    BrowserJsonp.prototype.cleanup = function (node) {
	        if (node.parentNode) {
	            node.parentNode.removeChild((node));
	        }
	    };
	    /** @nocollapse */
	    BrowserJsonp.decorators = [
	        { type: core_1.Injectable },
	    ];
	    return BrowserJsonp;
	}());
	exports.BrowserJsonp = BrowserJsonp;
	//# sourceMappingURL=browser_jsonp.js.map

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var Observable_1 = __webpack_require__(24);
	var base_response_options_1 = __webpack_require__(59);
	var enums_1 = __webpack_require__(18);
	var exceptions_1 = __webpack_require__(60);
	var lang_1 = __webpack_require__(11);
	var interfaces_1 = __webpack_require__(33);
	var static_response_1 = __webpack_require__(105);
	var browser_jsonp_1 = __webpack_require__(168);
	var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';
	var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use GET request method.';
	/**
	 * Abstract base class for an in-flight JSONP request.
	 *
	 * @experimental
	 */
	var JSONPConnection = (function () {
	    function JSONPConnection() {
	    }
	    return JSONPConnection;
	}());
	exports.JSONPConnection = JSONPConnection;
	var JSONPConnection_ = (function (_super) {
	    __extends(JSONPConnection_, _super);
	    function JSONPConnection_(req, _dom, baseResponseOptions) {
	        var _this = this;
	        _super.call(this);
	        this._dom = _dom;
	        this.baseResponseOptions = baseResponseOptions;
	        this._finished = false;
	        if (req.method !== enums_1.RequestMethod.Get) {
	            throw exceptions_1.makeTypeError(JSONP_ERR_WRONG_METHOD);
	        }
	        this.request = req;
	        this.response = new Observable_1.Observable(function (responseObserver) {
	            _this.readyState = enums_1.ReadyState.Loading;
	            var id = _this._id = _dom.nextRequestID();
	            _dom.exposeConnection(id, _this);
	            // Workaround Dart
	            // url = url.replace(/=JSONP_CALLBACK(&|$)/, `generated method`);
	            var callback = _dom.requestCallback(_this._id);
	            var url = req.url;
	            if (url.indexOf('=JSONP_CALLBACK&') > -1) {
	                url = lang_1.StringWrapper.replace(url, '=JSONP_CALLBACK&', "=" + callback + "&");
	            }
	            else if (url.lastIndexOf('=JSONP_CALLBACK') === url.length - '=JSONP_CALLBACK'.length) {
	                url = url.substring(0, url.length - '=JSONP_CALLBACK'.length) + ("=" + callback);
	            }
	            var script = _this._script = _dom.build(url);
	            var onLoad = function (event) {
	                if (_this.readyState === enums_1.ReadyState.Cancelled)
	                    return;
	                _this.readyState = enums_1.ReadyState.Done;
	                _dom.cleanup(script);
	                if (!_this._finished) {
	                    var responseOptions_1 = new base_response_options_1.ResponseOptions({ body: JSONP_ERR_NO_CALLBACK, type: enums_1.ResponseType.Error, url: url });
	                    if (lang_1.isPresent(baseResponseOptions)) {
	                        responseOptions_1 = baseResponseOptions.merge(responseOptions_1);
	                    }
	                    responseObserver.error(new static_response_1.Response(responseOptions_1));
	                    return;
	                }
	                var responseOptions = new base_response_options_1.ResponseOptions({ body: _this._responseData, url: url });
	                if (lang_1.isPresent(_this.baseResponseOptions)) {
	                    responseOptions = _this.baseResponseOptions.merge(responseOptions);
	                }
	                responseObserver.next(new static_response_1.Response(responseOptions));
	                responseObserver.complete();
	            };
	            var onError = function (error) {
	                if (_this.readyState === enums_1.ReadyState.Cancelled)
	                    return;
	                _this.readyState = enums_1.ReadyState.Done;
	                _dom.cleanup(script);
	                var responseOptions = new base_response_options_1.ResponseOptions({ body: error.message, type: enums_1.ResponseType.Error });
	                if (lang_1.isPresent(baseResponseOptions)) {
	                    responseOptions = baseResponseOptions.merge(responseOptions);
	                }
	                responseObserver.error(new static_response_1.Response(responseOptions));
	            };
	            script.addEventListener('load', onLoad);
	            script.addEventListener('error', onError);
	            _dom.send(script);
	            return function () {
	                _this.readyState = enums_1.ReadyState.Cancelled;
	                script.removeEventListener('load', onLoad);
	                script.removeEventListener('error', onError);
	                if (lang_1.isPresent(script)) {
	                    _this._dom.cleanup(script);
	                }
	            };
	        });
	    }
	    JSONPConnection_.prototype.finished = function (data) {
	        // Don't leak connections
	        this._finished = true;
	        this._dom.removeConnection(this._id);
	        if (this.readyState === enums_1.ReadyState.Cancelled)
	            return;
	        this._responseData = data;
	    };
	    return JSONPConnection_;
	}(JSONPConnection));
	exports.JSONPConnection_ = JSONPConnection_;
	/**
	 * A {@link ConnectionBackend} that uses the JSONP strategy of making requests.
	 *
	 * @experimental
	 */
	var JSONPBackend = (function (_super) {
	    __extends(JSONPBackend, _super);
	    function JSONPBackend() {
	        _super.apply(this, arguments);
	    }
	    return JSONPBackend;
	}(interfaces_1.ConnectionBackend));
	exports.JSONPBackend = JSONPBackend;
	var JSONPBackend_ = (function (_super) {
	    __extends(JSONPBackend_, _super);
	    function JSONPBackend_(_browserJSONP, _baseResponseOptions) {
	        _super.call(this);
	        this._browserJSONP = _browserJSONP;
	        this._baseResponseOptions = _baseResponseOptions;
	    }
	    JSONPBackend_.prototype.createConnection = function (request) {
	        return new JSONPConnection_(request, this._browserJSONP, this._baseResponseOptions);
	    };
	    /** @nocollapse */
	    JSONPBackend_.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    JSONPBackend_.ctorParameters = [
	        { type: browser_jsonp_1.BrowserJsonp, },
	        { type: base_response_options_1.ResponseOptions, },
	    ];
	    return JSONPBackend_;
	}(JSONPBackend));
	exports.JSONPBackend_ = JSONPBackend_;
	//# sourceMappingURL=jsonp_backend.js.map

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var platform_browser_1 = __webpack_require__(232);
	var Observable_1 = __webpack_require__(24);
	var base_response_options_1 = __webpack_require__(59);
	var enums_1 = __webpack_require__(18);
	var lang_1 = __webpack_require__(11);
	var headers_1 = __webpack_require__(32);
	var http_utils_1 = __webpack_require__(61);
	var interfaces_1 = __webpack_require__(33);
	var static_response_1 = __webpack_require__(105);
	var browser_xhr_1 = __webpack_require__(102);
	var XSSI_PREFIX = /^\)\]\}',?\n/;
	/**
	 * Creates connections using `XMLHttpRequest`. Given a fully-qualified
	 * request, an `XHRConnection` will immediately create an `XMLHttpRequest` object and send the
	 * request.
	 *
	 * This class would typically not be created or interacted with directly inside applications, though
	 * the {@link MockConnection} may be interacted with in tests.
	 *
	 * @experimental
	 */
	var XHRConnection = (function () {
	    function XHRConnection(req, browserXHR, baseResponseOptions) {
	        var _this = this;
	        this.request = req;
	        this.response = new Observable_1.Observable(function (responseObserver) {
	            var _xhr = browserXHR.build();
	            _xhr.open(enums_1.RequestMethod[req.method].toUpperCase(), req.url);
	            if (lang_1.isPresent(req.withCredentials)) {
	                _xhr.withCredentials = req.withCredentials;
	            }
	            // load event handler
	            var onLoad = function () {
	                // responseText is the old-school way of retrieving response (supported by IE8 & 9)
	                // response/responseType properties were introduced in XHR Level2 spec (supported by
	                // IE10)
	                var body = lang_1.isPresent(_xhr.response) ? _xhr.response : _xhr.responseText;
	                // Implicitly strip a potential XSSI prefix.
	                if (lang_1.isString(body))
	                    body = body.replace(XSSI_PREFIX, '');
	                var headers = headers_1.Headers.fromResponseHeaderString(_xhr.getAllResponseHeaders());
	                var url = http_utils_1.getResponseURL(_xhr);
	                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
	                var status = _xhr.status === 1223 ? 204 : _xhr.status;
	                // fix status code when it is 0 (0 status is undocumented).
	                // Occurs when accessing file resources or on Android 4.1 stock browser
	                // while retrieving files from application cache.
	                if (status === 0) {
	                    status = body ? 200 : 0;
	                }
	                var statusText = _xhr.statusText || 'OK';
	                var responseOptions = new base_response_options_1.ResponseOptions({ body: body, status: status, headers: headers, statusText: statusText, url: url });
	                if (lang_1.isPresent(baseResponseOptions)) {
	                    responseOptions = baseResponseOptions.merge(responseOptions);
	                }
	                var response = new static_response_1.Response(responseOptions);
	                response.ok = http_utils_1.isSuccess(status);
	                if (response.ok) {
	                    responseObserver.next(response);
	                    // TODO(gdi2290): defer complete if array buffer until done
	                    responseObserver.complete();
	                    return;
	                }
	                responseObserver.error(response);
	            };
	            // error event handler
	            var onError = function (err) {
	                var responseOptions = new base_response_options_1.ResponseOptions({
	                    body: err,
	                    type: enums_1.ResponseType.Error,
	                    status: _xhr.status,
	                    statusText: _xhr.statusText,
	                });
	                if (lang_1.isPresent(baseResponseOptions)) {
	                    responseOptions = baseResponseOptions.merge(responseOptions);
	                }
	                responseObserver.error(new static_response_1.Response(responseOptions));
	            };
	            _this.setDetectedContentType(req, _xhr);
	            if (lang_1.isPresent(req.headers)) {
	                req.headers.forEach(function (values, name) { return _xhr.setRequestHeader(name, values.join(',')); });
	            }
	            // Select the correct buffer type to store the response
	            if (lang_1.isPresent(req.responseType) && lang_1.isPresent(_xhr.responseType)) {
	                switch (req.responseType) {
	                    case enums_1.ResponseContentType.ArrayBuffer:
	                        _xhr.responseType = 'arraybuffer';
	                        break;
	                    case enums_1.ResponseContentType.Json:
	                        _xhr.responseType = 'json';
	                        break;
	                    case enums_1.ResponseContentType.Text:
	                        _xhr.responseType = 'text';
	                        break;
	                    case enums_1.ResponseContentType.Blob:
	                        _xhr.responseType = 'blob';
	                        break;
	                    default:
	                        throw new Error('The selected responseType is not supported');
	                }
	            }
	            _xhr.addEventListener('load', onLoad);
	            _xhr.addEventListener('error', onError);
	            _xhr.send(_this.request.getBody());
	            return function () {
	                _xhr.removeEventListener('load', onLoad);
	                _xhr.removeEventListener('error', onError);
	                _xhr.abort();
	            };
	        });
	    }
	    XHRConnection.prototype.setDetectedContentType = function (req /** TODO #9100 */, _xhr /** TODO #9100 */) {
	        // Skip if a custom Content-Type header is provided
	        if (lang_1.isPresent(req.headers) && lang_1.isPresent(req.headers.get('Content-Type'))) {
	            return;
	        }
	        // Set the detected content type
	        switch (req.contentType) {
	            case enums_1.ContentType.NONE:
	                break;
	            case enums_1.ContentType.JSON:
	                _xhr.setRequestHeader('content-type', 'application/json');
	                break;
	            case enums_1.ContentType.FORM:
	                _xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	                break;
	            case enums_1.ContentType.TEXT:
	                _xhr.setRequestHeader('content-type', 'text/plain');
	                break;
	            case enums_1.ContentType.BLOB:
	                var blob = req.blob();
	                if (blob.type) {
	                    _xhr.setRequestHeader('content-type', blob.type);
	                }
	                break;
	        }
	    };
	    return XHRConnection;
	}());
	exports.XHRConnection = XHRConnection;
	/**
	 * `XSRFConfiguration` sets up Cross Site Request Forgery (XSRF) protection for the application
	 * using a cookie. See {@link https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)}
	 * for more information on XSRF.
	 *
	 * Applications can configure custom cookie and header names by binding an instance of this class
	 * with different `cookieName` and `headerName` values. See the main HTTP documentation for more
	 * details.
	 *
	 * @experimental
	 */
	var CookieXSRFStrategy = (function () {
	    function CookieXSRFStrategy(_cookieName, _headerName) {
	        if (_cookieName === void 0) { _cookieName = 'XSRF-TOKEN'; }
	        if (_headerName === void 0) { _headerName = 'X-XSRF-TOKEN'; }
	        this._cookieName = _cookieName;
	        this._headerName = _headerName;
	    }
	    CookieXSRFStrategy.prototype.configureRequest = function (req) {
	        var xsrfToken = platform_browser_1.__platform_browser_private__.getDOM().getCookie(this._cookieName);
	        if (xsrfToken && !req.headers.has(this._headerName)) {
	            req.headers.set(this._headerName, xsrfToken);
	        }
	    };
	    return CookieXSRFStrategy;
	}());
	exports.CookieXSRFStrategy = CookieXSRFStrategy;
	var XHRBackend = (function () {
	    function XHRBackend(_browserXHR, _baseResponseOptions, _xsrfStrategy) {
	        this._browserXHR = _browserXHR;
	        this._baseResponseOptions = _baseResponseOptions;
	        this._xsrfStrategy = _xsrfStrategy;
	    }
	    XHRBackend.prototype.createConnection = function (request) {
	        this._xsrfStrategy.configureRequest(request);
	        return new XHRConnection(request, this._browserXHR, this._baseResponseOptions);
	    };
	    /** @nocollapse */
	    XHRBackend.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    XHRBackend.ctorParameters = [
	        { type: browser_xhr_1.BrowserXhr, },
	        { type: base_response_options_1.ResponseOptions, },
	        { type: interfaces_1.XSRFStrategy, },
	    ];
	    return XHRBackend;
	}());
	exports.XHRBackend = XHRBackend;
	//# sourceMappingURL=xhr_backend.js.map

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(11);
	var http_utils_1 = __webpack_require__(61);
	var url_search_params_1 = __webpack_require__(62);
	/**
	 * HTTP request body used by both {@link Request} and {@link Response}
	 * https://fetch.spec.whatwg.org/#body
	 */
	var Body = (function () {
	    function Body() {
	    }
	    /**
	     * Attempts to return body as parsed `JSON` object, or raises an exception.
	     */
	    Body.prototype.json = function () {
	        if (lang_1.isString(this._body)) {
	            return lang_1.Json.parse(this._body);
	        }
	        if (this._body instanceof ArrayBuffer) {
	            return lang_1.Json.parse(this.text());
	        }
	        return this._body;
	    };
	    /**
	     * Returns the body as a string, presuming `toString()` can be called on the response body.
	     */
	    Body.prototype.text = function () {
	        if (this._body instanceof url_search_params_1.URLSearchParams) {
	            return this._body.toString();
	        }
	        if (this._body instanceof ArrayBuffer) {
	            return String.fromCharCode.apply(null, new Uint16Array(this._body));
	        }
	        if (http_utils_1.isJsObject(this._body)) {
	            return lang_1.Json.stringify(this._body);
	        }
	        return this._body.toString();
	    };
	    /**
	     * Return the body as an ArrayBuffer
	     */
	    Body.prototype.arrayBuffer = function () {
	        if (this._body instanceof ArrayBuffer) {
	            return this._body;
	        }
	        return http_utils_1.stringToArrayBuffer(this.text());
	    };
	    /**
	      * Returns the request's body as a Blob, assuming that body exists.
	      */
	    Body.prototype.blob = function () {
	        if (this._body instanceof Blob) {
	            return this._body;
	        }
	        if (this._body instanceof ArrayBuffer) {
	            return new Blob([this._body]);
	        }
	        throw new Error('The request body isn\'t either a blob or an array buffer');
	    };
	    return Body;
	}());
	exports.Body = Body;
	//# sourceMappingURL=body.js.map

/***/ },
/* 172 */
123,
/* 173 */
[294, 172, 104, 11],
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var exceptions_1 = __webpack_require__(60);
	var lang_1 = __webpack_require__(11);
	var base_request_options_1 = __webpack_require__(103);
	var enums_1 = __webpack_require__(18);
	var interfaces_1 = __webpack_require__(33);
	var static_request_1 = __webpack_require__(175);
	function httpRequest(backend, request) {
	    return backend.createConnection(request).response;
	}
	function mergeOptions(defaultOpts, providedOpts, method, url) {
	    var newOptions = defaultOpts;
	    if (lang_1.isPresent(providedOpts)) {
	        // Hack so Dart can used named parameters
	        return newOptions.merge(new base_request_options_1.RequestOptions({
	            method: providedOpts.method || method,
	            url: providedOpts.url || url,
	            search: providedOpts.search,
	            headers: providedOpts.headers,
	            body: providedOpts.body,
	            withCredentials: providedOpts.withCredentials,
	            responseType: providedOpts.responseType
	        }));
	    }
	    if (lang_1.isPresent(method)) {
	        return newOptions.merge(new base_request_options_1.RequestOptions({ method: method, url: url }));
	    }
	    else {
	        return newOptions.merge(new base_request_options_1.RequestOptions({ url: url }));
	    }
	}
	var Http = (function () {
	    function Http(_backend, _defaultOptions) {
	        this._backend = _backend;
	        this._defaultOptions = _defaultOptions;
	    }
	    /**
	     * Performs any type of http request. First argument is required, and can either be a url or
	     * a {@link Request} instance. If the first argument is a url, an optional {@link RequestOptions}
	     * object can be provided as the 2nd argument. The options object will be merged with the values
	     * of {@link BaseRequestOptions} before performing the request.
	     */
	    Http.prototype.request = function (url, options) {
	        var responseObservable;
	        if (lang_1.isString(url)) {
	            responseObservable = httpRequest(this._backend, new static_request_1.Request(mergeOptions(this._defaultOptions, options, enums_1.RequestMethod.Get, url)));
	        }
	        else if (url instanceof static_request_1.Request) {
	            responseObservable = httpRequest(this._backend, url);
	        }
	        else {
	            throw exceptions_1.makeTypeError('First argument must be a url string or Request instance.');
	        }
	        return responseObservable;
	    };
	    /**
	     * Performs a request with `get` http method.
	     */
	    Http.prototype.get = function (url, options) {
	        return httpRequest(this._backend, new static_request_1.Request(mergeOptions(this._defaultOptions, options, enums_1.RequestMethod.Get, url)));
	    };
	    /**
	     * Performs a request with `post` http method.
	     */
	    Http.prototype.post = function (url, body, options) {
	        return httpRequest(this._backend, new static_request_1.Request(mergeOptions(this._defaultOptions.merge(new base_request_options_1.RequestOptions({ body: body })), options, enums_1.RequestMethod.Post, url)));
	    };
	    /**
	     * Performs a request with `put` http method.
	     */
	    Http.prototype.put = function (url, body, options) {
	        return httpRequest(this._backend, new static_request_1.Request(mergeOptions(this._defaultOptions.merge(new base_request_options_1.RequestOptions({ body: body })), options, enums_1.RequestMethod.Put, url)));
	    };
	    /**
	     * Performs a request with `delete` http method.
	     */
	    Http.prototype.delete = function (url, options) {
	        return httpRequest(this._backend, new static_request_1.Request(mergeOptions(this._defaultOptions, options, enums_1.RequestMethod.Delete, url)));
	    };
	    /**
	     * Performs a request with `patch` http method.
	     */
	    Http.prototype.patch = function (url, body, options) {
	        return httpRequest(this._backend, new static_request_1.Request(mergeOptions(this._defaultOptions.merge(new base_request_options_1.RequestOptions({ body: body })), options, enums_1.RequestMethod.Patch, url)));
	    };
	    /**
	     * Performs a request with `head` http method.
	     */
	    Http.prototype.head = function (url, options) {
	        return httpRequest(this._backend, new static_request_1.Request(mergeOptions(this._defaultOptions, options, enums_1.RequestMethod.Head, url)));
	    };
	    /**
	     * Performs a request with `options` http method.
	     */
	    Http.prototype.options = function (url, options) {
	        return httpRequest(this._backend, new static_request_1.Request(mergeOptions(this._defaultOptions, options, enums_1.RequestMethod.Options, url)));
	    };
	    /** @nocollapse */
	    Http.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    Http.ctorParameters = [
	        { type: interfaces_1.ConnectionBackend, },
	        { type: base_request_options_1.RequestOptions, },
	    ];
	    return Http;
	}());
	exports.Http = Http;
	var Jsonp = (function (_super) {
	    __extends(Jsonp, _super);
	    function Jsonp(backend, defaultOptions) {
	        _super.call(this, backend, defaultOptions);
	    }
	    /**
	     * Performs any type of http request. First argument is required, and can either be a url or
	     * a {@link Request} instance. If the first argument is a url, an optional {@link RequestOptions}
	     * object can be provided as the 2nd argument. The options object will be merged with the values
	     * of {@link BaseRequestOptions} before performing the request.
	     *
	     * @security Regular XHR is the safest alternative to JSONP for most applications, and is
	     * supported by all current browsers. Because JSONP creates a `<script>` element with
	     * contents retrieved from a remote source, attacker-controlled data introduced by an untrusted
	     * source could expose your application to XSS risks. Data exposed by JSONP may also be
	     * readable by malicious third-party websites. In addition, JSONP introduces potential risk for
	     * future security issues (e.g. content sniffing).  For more detail, see the
	     * [Security Guide](http://g.co/ng/security).
	     */
	    Jsonp.prototype.request = function (url, options) {
	        var responseObservable;
	        if (lang_1.isString(url)) {
	            url =
	                new static_request_1.Request(mergeOptions(this._defaultOptions, options, enums_1.RequestMethod.Get, url));
	        }
	        if (url instanceof static_request_1.Request) {
	            if (url.method !== enums_1.RequestMethod.Get) {
	                exceptions_1.makeTypeError('JSONP requests must use GET request method.');
	            }
	            responseObservable = httpRequest(this._backend, url);
	        }
	        else {
	            throw exceptions_1.makeTypeError('First argument must be a url string or Request instance.');
	        }
	        return responseObservable;
	    };
	    /** @nocollapse */
	    Jsonp.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    Jsonp.ctorParameters = [
	        { type: interfaces_1.ConnectionBackend, },
	        { type: base_request_options_1.RequestOptions, },
	    ];
	    return Jsonp;
	}(Http));
	exports.Jsonp = Jsonp;
	//# sourceMappingURL=http.js.map

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var lang_1 = __webpack_require__(11);
	var body_1 = __webpack_require__(171);
	var enums_1 = __webpack_require__(18);
	var headers_1 = __webpack_require__(32);
	var http_utils_1 = __webpack_require__(61);
	var url_search_params_1 = __webpack_require__(62);
	// TODO(jeffbcross): properly implement body accessors
	/**
	 * Creates `Request` instances from provided values.
	 *
	 * The Request's interface is inspired by the Request constructor defined in the [Fetch
	 * Spec](https://fetch.spec.whatwg.org/#request-class),
	 * but is considered a static value whose body can be accessed many times. There are other
	 * differences in the implementation, but this is the most significant.
	 *
	 * `Request` instances are typically created by higher-level classes, like {@link Http} and
	 * {@link Jsonp}, but it may occasionally be useful to explicitly create `Request` instances.
	 * One such example is when creating services that wrap higher-level services, like {@link Http},
	 * where it may be useful to generate a `Request` with arbitrary headers and search params.
	 *
	 * ```typescript
	 * import {Injectable, Injector} from '@angular/core';
	 * import {HTTP_PROVIDERS, Http, Request, RequestMethod} from '@angular/http';
	 *
	 * @Injectable()
	 * class AutoAuthenticator {
	 *   constructor(public http:Http) {}
	 *   request(url:string) {
	 *     return this.http.request(new Request({
	 *       method: RequestMethod.Get,
	 *       url: url,
	 *       search: 'password=123'
	 *     }));
	 *   }
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([HTTP_PROVIDERS, AutoAuthenticator]);
	 * var authenticator = injector.get(AutoAuthenticator);
	 * authenticator.request('people.json').subscribe(res => {
	 *   //URL should have included '?password=123'
	 *   console.log('people', res.json());
	 * });
	 * ```
	 *
	 * @experimental
	 */
	var Request = (function (_super) {
	    __extends(Request, _super);
	    function Request(requestOptions) {
	        _super.call(this);
	        // TODO: assert that url is present
	        var url = requestOptions.url;
	        this.url = requestOptions.url;
	        if (lang_1.isPresent(requestOptions.search)) {
	            var search = requestOptions.search.toString();
	            if (search.length > 0) {
	                var prefix = '?';
	                if (lang_1.StringWrapper.contains(this.url, '?')) {
	                    prefix = (this.url[this.url.length - 1] == '&') ? '' : '&';
	                }
	                // TODO: just delete search-query-looking string in url?
	                this.url = url + prefix + search;
	            }
	        }
	        this._body = requestOptions.body;
	        this.method = http_utils_1.normalizeMethodName(requestOptions.method);
	        // TODO(jeffbcross): implement behavior
	        // Defaults to 'omit', consistent with browser
	        // TODO(jeffbcross): implement behavior
	        this.headers = new headers_1.Headers(requestOptions.headers);
	        this.contentType = this.detectContentType();
	        this.withCredentials = requestOptions.withCredentials;
	        this.responseType = requestOptions.responseType;
	    }
	    /**
	     * Returns the content type enum based on header options.
	     */
	    Request.prototype.detectContentType = function () {
	        switch (this.headers.get('content-type')) {
	            case 'application/json':
	                return enums_1.ContentType.JSON;
	            case 'application/x-www-form-urlencoded':
	                return enums_1.ContentType.FORM;
	            case 'multipart/form-data':
	                return enums_1.ContentType.FORM_DATA;
	            case 'text/plain':
	            case 'text/html':
	                return enums_1.ContentType.TEXT;
	            case 'application/octet-stream':
	                return enums_1.ContentType.BLOB;
	            default:
	                return this.detectContentTypeFromBody();
	        }
	    };
	    /**
	     * Returns the content type of request's body based on its type.
	     */
	    Request.prototype.detectContentTypeFromBody = function () {
	        if (this._body == null) {
	            return enums_1.ContentType.NONE;
	        }
	        else if (this._body instanceof url_search_params_1.URLSearchParams) {
	            return enums_1.ContentType.FORM;
	        }
	        else if (this._body instanceof FormData) {
	            return enums_1.ContentType.FORM_DATA;
	        }
	        else if (this._body instanceof Blob) {
	            return enums_1.ContentType.BLOB;
	        }
	        else if (this._body instanceof ArrayBuffer) {
	            return enums_1.ContentType.ARRAY_BUFFER;
	        }
	        else if (this._body && typeof this._body == 'object') {
	            return enums_1.ContentType.JSON;
	        }
	        else {
	            return enums_1.ContentType.TEXT;
	        }
	    };
	    /**
	     * Returns the request's body according to its type. If body is undefined, return
	     * null.
	     */
	    Request.prototype.getBody = function () {
	        switch (this.contentType) {
	            case enums_1.ContentType.JSON:
	                return this.text();
	            case enums_1.ContentType.FORM:
	                return this.text();
	            case enums_1.ContentType.FORM_DATA:
	                return this._body;
	            case enums_1.ContentType.TEXT:
	                return this.text();
	            case enums_1.ContentType.BLOB:
	                return this.blob();
	            case enums_1.ContentType.ARRAY_BUFFER:
	                return this.arrayBuffer();
	            default:
	                return null;
	        }
	    };
	    return Request;
	}(body_1.Body));
	exports.Request = Request;
	var noop = function () { };
	var w = typeof window == 'object' ? window : noop;
	var FormData = w['FormData'] || noop;
	var Blob = w['Blob'] || noop;
	var ArrayBuffer = w['ArrayBuffer'] || noop;
	//# sourceMappingURL=static_request.js.map

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var dom_adapter_1 = __webpack_require__(7);
	var collection_1 = __webpack_require__(8);
	var lang_1 = __webpack_require__(5);
	var generic_browser_adapter_1 = __webpack_require__(234);
	var _attrToPropMap = {
	    'class': 'className',
	    'innerHtml': 'innerHTML',
	    'readonly': 'readOnly',
	    'tabindex': 'tabIndex'
	};
	var DOM_KEY_LOCATION_NUMPAD = 3;
	// Map to convert some key or keyIdentifier values to what will be returned by getEventKey
	var _keyMap = {
	    // The following values are here for cross-browser compatibility and to match the W3C standard
	    // cf http://www.w3.org/TR/DOM-Level-3-Events-key/
	    '\b': 'Backspace',
	    '\t': 'Tab',
	    '\x7F': 'Delete',
	    '\x1B': 'Escape',
	    'Del': 'Delete',
	    'Esc': 'Escape',
	    'Left': 'ArrowLeft',
	    'Right': 'ArrowRight',
	    'Up': 'ArrowUp',
	    'Down': 'ArrowDown',
	    'Menu': 'ContextMenu',
	    'Scroll': 'ScrollLock',
	    'Win': 'OS'
	};
	// There is a bug in Chrome for numeric keypad keys:
	// https://code.google.com/p/chromium/issues/detail?id=155654
	// 1, 2, 3 ... are reported as A, B, C ...
	var _chromeNumKeyPadMap = {
	    'A': '1',
	    'B': '2',
	    'C': '3',
	    'D': '4',
	    'E': '5',
	    'F': '6',
	    'G': '7',
	    'H': '8',
	    'I': '9',
	    'J': '*',
	    'K': '+',
	    'M': '-',
	    'N': '.',
	    'O': '/',
	    '\x60': '0',
	    '\x90': 'NumLock'
	};
	/**
	 * A `DomAdapter` powered by full browser DOM APIs.
	 */
	/* tslint:disable:requireParameterType */
	var BrowserDomAdapter = (function (_super) {
	    __extends(BrowserDomAdapter, _super);
	    function BrowserDomAdapter() {
	        _super.apply(this, arguments);
	    }
	    BrowserDomAdapter.prototype.parse = function (templateHtml) { throw new Error('parse not implemented'); };
	    BrowserDomAdapter.makeCurrent = function () { dom_adapter_1.setRootDomAdapter(new BrowserDomAdapter()); };
	    BrowserDomAdapter.prototype.hasProperty = function (element /** TODO #9100 */, name) { return name in element; };
	    BrowserDomAdapter.prototype.setProperty = function (el, name, value) { el[name] = value; };
	    BrowserDomAdapter.prototype.getProperty = function (el, name) { return el[name]; };
	    BrowserDomAdapter.prototype.invoke = function (el, methodName, args) {
	        el[methodName].apply(el, args);
	    };
	    // TODO(tbosch): move this into a separate environment class once we have it
	    BrowserDomAdapter.prototype.logError = function (error /** TODO #9100 */) {
	        if (window.console.error) {
	            window.console.error(error);
	        }
	        else {
	            window.console.log(error);
	        }
	    };
	    BrowserDomAdapter.prototype.log = function (error /** TODO #9100 */) { window.console.log(error); };
	    BrowserDomAdapter.prototype.logGroup = function (error /** TODO #9100 */) {
	        if (window.console.group) {
	            window.console.group(error);
	            this.logError(error);
	        }
	        else {
	            window.console.log(error);
	        }
	    };
	    BrowserDomAdapter.prototype.logGroupEnd = function () {
	        if (window.console.groupEnd) {
	            window.console.groupEnd();
	        }
	    };
	    Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {
	        get: function () { return _attrToPropMap; },
	        enumerable: true,
	        configurable: true
	    });
	    BrowserDomAdapter.prototype.query = function (selector) { return document.querySelector(selector); };
	    BrowserDomAdapter.prototype.querySelector = function (el /** TODO #9100 */, selector) {
	        return el.querySelector(selector);
	    };
	    BrowserDomAdapter.prototype.querySelectorAll = function (el /** TODO #9100 */, selector) {
	        return el.querySelectorAll(selector);
	    };
	    BrowserDomAdapter.prototype.on = function (el /** TODO #9100 */, evt /** TODO #9100 */, listener /** TODO #9100 */) {
	        el.addEventListener(evt, listener, false);
	    };
	    BrowserDomAdapter.prototype.onAndCancel = function (el /** TODO #9100 */, evt /** TODO #9100 */, listener /** TODO #9100 */) {
	        el.addEventListener(evt, listener, false);
	        // Needed to follow Dart's subscription semantic, until fix of
	        // https://code.google.com/p/dart/issues/detail?id=17406
	        return function () { el.removeEventListener(evt, listener, false); };
	    };
	    BrowserDomAdapter.prototype.dispatchEvent = function (el /** TODO #9100 */, evt /** TODO #9100 */) { el.dispatchEvent(evt); };
	    BrowserDomAdapter.prototype.createMouseEvent = function (eventType) {
	        var evt = document.createEvent('MouseEvent');
	        evt.initEvent(eventType, true, true);
	        return evt;
	    };
	    BrowserDomAdapter.prototype.createEvent = function (eventType /** TODO #9100 */) {
	        var evt = document.createEvent('Event');
	        evt.initEvent(eventType, true, true);
	        return evt;
	    };
	    BrowserDomAdapter.prototype.preventDefault = function (evt) {
	        evt.preventDefault();
	        evt.returnValue = false;
	    };
	    BrowserDomAdapter.prototype.isPrevented = function (evt) {
	        return evt.defaultPrevented || lang_1.isPresent(evt.returnValue) && !evt.returnValue;
	    };
	    BrowserDomAdapter.prototype.getInnerHTML = function (el /** TODO #9100 */) { return el.innerHTML; };
	    BrowserDomAdapter.prototype.getTemplateContent = function (el /** TODO #9100 */) {
	        return 'content' in el && el instanceof HTMLTemplateElement ? el.content : null;
	    };
	    BrowserDomAdapter.prototype.getOuterHTML = function (el /** TODO #9100 */) { return el.outerHTML; };
	    BrowserDomAdapter.prototype.nodeName = function (node) { return node.nodeName; };
	    BrowserDomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };
	    BrowserDomAdapter.prototype.type = function (node) { return node.type; };
	    BrowserDomAdapter.prototype.content = function (node) {
	        if (this.hasProperty(node, 'content')) {
	            return node.content;
	        }
	        else {
	            return node;
	        }
	    };
	    BrowserDomAdapter.prototype.firstChild = function (el /** TODO #9100 */) { return el.firstChild; };
	    BrowserDomAdapter.prototype.nextSibling = function (el /** TODO #9100 */) { return el.nextSibling; };
	    BrowserDomAdapter.prototype.parentElement = function (el /** TODO #9100 */) { return el.parentNode; };
	    BrowserDomAdapter.prototype.childNodes = function (el /** TODO #9100 */) { return el.childNodes; };
	    BrowserDomAdapter.prototype.childNodesAsList = function (el /** TODO #9100 */) {
	        var childNodes = el.childNodes;
	        var res = collection_1.ListWrapper.createFixedSize(childNodes.length);
	        for (var i = 0; i < childNodes.length; i++) {
	            res[i] = childNodes[i];
	        }
	        return res;
	    };
	    BrowserDomAdapter.prototype.clearNodes = function (el /** TODO #9100 */) {
	        while (el.firstChild) {
	            el.removeChild(el.firstChild);
	        }
	    };
	    BrowserDomAdapter.prototype.appendChild = function (el /** TODO #9100 */, node /** TODO #9100 */) { el.appendChild(node); };
	    BrowserDomAdapter.prototype.removeChild = function (el /** TODO #9100 */, node /** TODO #9100 */) { el.removeChild(node); };
	    BrowserDomAdapter.prototype.replaceChild = function (el, newChild /** TODO #9100 */, oldChild /** TODO #9100 */) {
	        el.replaceChild(newChild, oldChild);
	    };
	    BrowserDomAdapter.prototype.remove = function (node /** TODO #9100 */) {
	        if (node.parentNode) {
	            node.parentNode.removeChild(node);
	        }
	        return node;
	    };
	    BrowserDomAdapter.prototype.insertBefore = function (el /** TODO #9100 */, node /** TODO #9100 */) {
	        el.parentNode.insertBefore(node, el);
	    };
	    BrowserDomAdapter.prototype.insertAllBefore = function (el /** TODO #9100 */, nodes /** TODO #9100 */) {
	        nodes.forEach(function (n /** TODO #9100 */) { return el.parentNode.insertBefore(n, el); });
	    };
	    BrowserDomAdapter.prototype.insertAfter = function (el /** TODO #9100 */, node /** TODO #9100 */) {
	        el.parentNode.insertBefore(node, el.nextSibling);
	    };
	    BrowserDomAdapter.prototype.setInnerHTML = function (el /** TODO #9100 */, value /** TODO #9100 */) { el.innerHTML = value; };
	    BrowserDomAdapter.prototype.getText = function (el /** TODO #9100 */) { return el.textContent; };
	    // TODO(vicb): removed Element type because it does not support StyleElement
	    BrowserDomAdapter.prototype.setText = function (el /** TODO #9100 */, value) { el.textContent = value; };
	    BrowserDomAdapter.prototype.getValue = function (el /** TODO #9100 */) { return el.value; };
	    BrowserDomAdapter.prototype.setValue = function (el /** TODO #9100 */, value) { el.value = value; };
	    BrowserDomAdapter.prototype.getChecked = function (el /** TODO #9100 */) { return el.checked; };
	    BrowserDomAdapter.prototype.setChecked = function (el /** TODO #9100 */, value) { el.checked = value; };
	    BrowserDomAdapter.prototype.createComment = function (text) { return document.createComment(text); };
	    BrowserDomAdapter.prototype.createTemplate = function (html /** TODO #9100 */) {
	        var t = document.createElement('template');
	        t.innerHTML = html;
	        return t;
	    };
	    BrowserDomAdapter.prototype.createElement = function (tagName /* TODO #9100 */, doc) {
	        if (doc === void 0) { doc = document; }
	        return doc.createElement(tagName);
	    };
	    BrowserDomAdapter.prototype.createElementNS = function (ns /* TODO #9100 */, tagName /* TODO #9100 */, doc) {
	        if (doc === void 0) { doc = document; }
	        return doc.createElementNS(ns, tagName);
	    };
	    BrowserDomAdapter.prototype.createTextNode = function (text, doc) {
	        if (doc === void 0) { doc = document; }
	        return doc.createTextNode(text);
	    };
	    BrowserDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {
	        if (doc === void 0) { doc = document; }
	        var el = doc.createElement('SCRIPT');
	        el.setAttribute(attrName, attrValue);
	        return el;
	    };
	    BrowserDomAdapter.prototype.createStyleElement = function (css, doc) {
	        if (doc === void 0) { doc = document; }
	        var style = doc.createElement('style');
	        this.appendChild(style, this.createTextNode(css));
	        return style;
	    };
	    BrowserDomAdapter.prototype.createShadowRoot = function (el) { return el.createShadowRoot(); };
	    BrowserDomAdapter.prototype.getShadowRoot = function (el) { return el.shadowRoot; };
	    BrowserDomAdapter.prototype.getHost = function (el) { return el.host; };
	    BrowserDomAdapter.prototype.clone = function (node) { return node.cloneNode(true); };
	    BrowserDomAdapter.prototype.getElementsByClassName = function (element /** TODO #9100 */, name) {
	        return element.getElementsByClassName(name);
	    };
	    BrowserDomAdapter.prototype.getElementsByTagName = function (element /** TODO #9100 */, name) {
	        return element.getElementsByTagName(name);
	    };
	    BrowserDomAdapter.prototype.classList = function (element /** TODO #9100 */) {
	        return Array.prototype.slice.call(element.classList, 0);
	    };
	    BrowserDomAdapter.prototype.addClass = function (element /** TODO #9100 */, className) { element.classList.add(className); };
	    BrowserDomAdapter.prototype.removeClass = function (element /** TODO #9100 */, className) {
	        element.classList.remove(className);
	    };
	    BrowserDomAdapter.prototype.hasClass = function (element /** TODO #9100 */, className) {
	        return element.classList.contains(className);
	    };
	    BrowserDomAdapter.prototype.setStyle = function (element /** TODO #9100 */, styleName, styleValue) {
	        element.style[styleName] = styleValue;
	    };
	    BrowserDomAdapter.prototype.removeStyle = function (element /** TODO #9100 */, stylename) {
	        element.style[stylename] = null;
	    };
	    BrowserDomAdapter.prototype.getStyle = function (element /** TODO #9100 */, stylename) {
	        return element.style[stylename];
	    };
	    BrowserDomAdapter.prototype.hasStyle = function (element /** TODO #9100 */, styleName, styleValue) {
	        if (styleValue === void 0) { styleValue = null; }
	        var value = this.getStyle(element, styleName) || '';
	        return styleValue ? value == styleValue : value.length > 0;
	    };
	    BrowserDomAdapter.prototype.tagName = function (element /** TODO #9100 */) { return element.tagName; };
	    BrowserDomAdapter.prototype.attributeMap = function (element /** TODO #9100 */) {
	        var res = new Map();
	        var elAttrs = element.attributes;
	        for (var i = 0; i < elAttrs.length; i++) {
	            var attrib = elAttrs[i];
	            res.set(attrib.name, attrib.value);
	        }
	        return res;
	    };
	    BrowserDomAdapter.prototype.hasAttribute = function (element /** TODO #9100 */, attribute) {
	        return element.hasAttribute(attribute);
	    };
	    BrowserDomAdapter.prototype.hasAttributeNS = function (element /** TODO #9100 */, ns, attribute) {
	        return element.hasAttributeNS(ns, attribute);
	    };
	    BrowserDomAdapter.prototype.getAttribute = function (element /** TODO #9100 */, attribute) {
	        return element.getAttribute(attribute);
	    };
	    BrowserDomAdapter.prototype.getAttributeNS = function (element /** TODO #9100 */, ns, name) {
	        return element.getAttributeNS(ns, name);
	    };
	    BrowserDomAdapter.prototype.setAttribute = function (element /** TODO #9100 */, name, value) {
	        element.setAttribute(name, value);
	    };
	    BrowserDomAdapter.prototype.setAttributeNS = function (element /** TODO #9100 */, ns, name, value) {
	        element.setAttributeNS(ns, name, value);
	    };
	    BrowserDomAdapter.prototype.removeAttribute = function (element /** TODO #9100 */, attribute) {
	        element.removeAttribute(attribute);
	    };
	    BrowserDomAdapter.prototype.removeAttributeNS = function (element /** TODO #9100 */, ns, name) {
	        element.removeAttributeNS(ns, name);
	    };
	    BrowserDomAdapter.prototype.templateAwareRoot = function (el /** TODO #9100 */) {
	        return this.isTemplateElement(el) ? this.content(el) : el;
	    };
	    BrowserDomAdapter.prototype.createHtmlDocument = function () {
	        return document.implementation.createHTMLDocument('fakeTitle');
	    };
	    BrowserDomAdapter.prototype.defaultDoc = function () { return document; };
	    BrowserDomAdapter.prototype.getBoundingClientRect = function (el /** TODO #9100 */) {
	        try {
	            return el.getBoundingClientRect();
	        }
	        catch (e) {
	            return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
	        }
	    };
	    BrowserDomAdapter.prototype.getTitle = function () { return document.title; };
	    BrowserDomAdapter.prototype.setTitle = function (newTitle) { document.title = newTitle || ''; };
	    BrowserDomAdapter.prototype.elementMatches = function (n /** TODO #9100 */, selector) {
	        var matches = false;
	        if (n instanceof HTMLElement) {
	            if (n.matches) {
	                matches = n.matches(selector);
	            }
	            else if (n.msMatchesSelector) {
	                matches = n.msMatchesSelector(selector);
	            }
	            else if (n.webkitMatchesSelector) {
	                matches = n.webkitMatchesSelector(selector);
	            }
	        }
	        return matches;
	    };
	    BrowserDomAdapter.prototype.isTemplateElement = function (el) {
	        return el instanceof HTMLElement && el.nodeName == 'TEMPLATE';
	    };
	    BrowserDomAdapter.prototype.isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
	    BrowserDomAdapter.prototype.isCommentNode = function (node) { return node.nodeType === Node.COMMENT_NODE; };
	    BrowserDomAdapter.prototype.isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
	    BrowserDomAdapter.prototype.hasShadowRoot = function (node /** TODO #9100 */) {
	        return node instanceof HTMLElement && lang_1.isPresent(node.shadowRoot);
	    };
	    BrowserDomAdapter.prototype.isShadowRoot = function (node /** TODO #9100 */) { return node instanceof DocumentFragment; };
	    BrowserDomAdapter.prototype.importIntoDoc = function (node) {
	        var toImport = node;
	        if (this.isTemplateElement(node)) {
	            toImport = this.content(node);
	        }
	        return document.importNode(toImport, true);
	    };
	    BrowserDomAdapter.prototype.adoptNode = function (node) { return document.adoptNode(node); };
	    BrowserDomAdapter.prototype.getHref = function (el) { return el.href; };
	    BrowserDomAdapter.prototype.getEventKey = function (event /** TODO #9100 */) {
	        var key = event.key;
	        if (lang_1.isBlank(key)) {
	            key = event.keyIdentifier;
	            // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
	            // Safari
	            // cf
	            // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
	            if (lang_1.isBlank(key)) {
	                return 'Unidentified';
	            }
	            if (key.startsWith('U+')) {
	                key = String.fromCharCode(parseInt(key.substring(2), 16));
	                if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
	                    // There is a bug in Chrome for numeric keypad keys:
	                    // https://code.google.com/p/chromium/issues/detail?id=155654
	                    // 1, 2, 3 ... are reported as A, B, C ...
	                    key = _chromeNumKeyPadMap[key];
	                }
	            }
	        }
	        if (_keyMap.hasOwnProperty(key)) {
	            key = _keyMap[key];
	        }
	        return key;
	    };
	    BrowserDomAdapter.prototype.getGlobalEventTarget = function (target) {
	        if (target == 'window') {
	            return window;
	        }
	        else if (target == 'document') {
	            return document;
	        }
	        else if (target == 'body') {
	            return document.body;
	        }
	    };
	    BrowserDomAdapter.prototype.getHistory = function () { return window.history; };
	    BrowserDomAdapter.prototype.getLocation = function () { return window.location; };
	    BrowserDomAdapter.prototype.getBaseHref = function () {
	        var href = getBaseElementHref();
	        if (lang_1.isBlank(href)) {
	            return null;
	        }
	        return relativePath(href);
	    };
	    BrowserDomAdapter.prototype.resetBaseElement = function () { baseElement = null; };
	    BrowserDomAdapter.prototype.getUserAgent = function () { return window.navigator.userAgent; };
	    BrowserDomAdapter.prototype.setData = function (element /** TODO #9100 */, name, value) {
	        this.setAttribute(element, 'data-' + name, value);
	    };
	    BrowserDomAdapter.prototype.getData = function (element /** TODO #9100 */, name) {
	        return this.getAttribute(element, 'data-' + name);
	    };
	    BrowserDomAdapter.prototype.getComputedStyle = function (element /** TODO #9100 */) { return getComputedStyle(element); };
	    // TODO(tbosch): move this into a separate environment class once we have it
	    BrowserDomAdapter.prototype.setGlobalVar = function (path, value) { lang_1.setValueOnPath(lang_1.global, path, value); };
	    BrowserDomAdapter.prototype.requestAnimationFrame = function (callback /** TODO #9100 */) {
	        return window.requestAnimationFrame(callback);
	    };
	    BrowserDomAdapter.prototype.cancelAnimationFrame = function (id) { window.cancelAnimationFrame(id); };
	    BrowserDomAdapter.prototype.supportsWebAnimation = function () { return lang_1.isFunction(Element.prototype['animate']); };
	    BrowserDomAdapter.prototype.performanceNow = function () {
	        // performance.now() is not available in all browsers, see
	        // http://caniuse.com/#search=performance.now
	        if (lang_1.isPresent(window.performance) && lang_1.isPresent(window.performance.now)) {
	            return window.performance.now();
	        }
	        else {
	            return lang_1.DateWrapper.toMillis(lang_1.DateWrapper.now());
	        }
	    };
	    BrowserDomAdapter.prototype.supportsCookies = function () { return true; };
	    BrowserDomAdapter.prototype.getCookie = function (name) { return parseCookieValue(document.cookie, name); };
	    BrowserDomAdapter.prototype.setCookie = function (name, value) {
	        // document.cookie is magical, assigning into it assigns/overrides one cookie value, but does
	        // not clear other cookies.
	        document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);
	    };
	    return BrowserDomAdapter;
	}(generic_browser_adapter_1.GenericBrowserDomAdapter));
	exports.BrowserDomAdapter = BrowserDomAdapter;
	var baseElement = null;
	function getBaseElementHref() {
	    if (lang_1.isBlank(baseElement)) {
	        baseElement = document.querySelector('base');
	        if (lang_1.isBlank(baseElement)) {
	            return null;
	        }
	    }
	    return baseElement.getAttribute('href');
	}
	// based on urlUtils.js in AngularJS 1
	var urlParsingNode = null;
	function relativePath(url /** TODO #9100 */) {
	    if (lang_1.isBlank(urlParsingNode)) {
	        urlParsingNode = document.createElement('a');
	    }
	    urlParsingNode.setAttribute('href', url);
	    return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :
	        '/' + urlParsingNode.pathname;
	}
	function parseCookieValue(cookieStr, name) {
	    name = encodeURIComponent(name);
	    for (var _i = 0, _a = cookieStr.split(';'); _i < _a.length; _i++) {
	        var cookie = _a[_i];
	        var eqIndex = cookie.indexOf('=');
	        var _b = eqIndex == -1 ? [cookie, ''] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)], cookieName = _b[0], cookieValue = _b[1];
	        if (cookieName.trim() === name) {
	            return decodeURIComponent(cookieValue);
	        }
	    }
	    return null;
	}
	exports.parseCookieValue = parseCookieValue;
	//# sourceMappingURL=browser_adapter.js.map

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var dom_adapter_1 = __webpack_require__(7);
	var collection_1 = __webpack_require__(8);
	var lang_1 = __webpack_require__(5);
	var PublicTestability = (function () {
	    function PublicTestability(testability) {
	        this._testability = testability;
	    }
	    PublicTestability.prototype.isStable = function () { return this._testability.isStable(); };
	    PublicTestability.prototype.whenStable = function (callback) { this._testability.whenStable(callback); };
	    PublicTestability.prototype.findBindings = function (using, provider, exactMatch) {
	        return this.findProviders(using, provider, exactMatch);
	    };
	    PublicTestability.prototype.findProviders = function (using, provider, exactMatch) {
	        return this._testability.findBindings(using, provider, exactMatch);
	    };
	    return PublicTestability;
	}());
	var BrowserGetTestability = (function () {
	    function BrowserGetTestability() {
	    }
	    BrowserGetTestability.init = function () { core_1.setTestabilityGetter(new BrowserGetTestability()); };
	    BrowserGetTestability.prototype.addToWindow = function (registry) {
	        lang_1.global.getAngularTestability = function (elem, findInAncestors) {
	            if (findInAncestors === void 0) { findInAncestors = true; }
	            var testability = registry.findTestabilityInTree(elem, findInAncestors);
	            if (testability == null) {
	                throw new Error('Could not find testability for element.');
	            }
	            return new PublicTestability(testability);
	        };
	        lang_1.global.getAllAngularTestabilities = function () {
	            var testabilities = registry.getAllTestabilities();
	            return testabilities.map(function (testability) { return new PublicTestability(testability); });
	        };
	        lang_1.global.getAllAngularRootElements = function () { return registry.getAllRootElements(); };
	        var whenAllStable = function (callback /** TODO #9100 */) {
	            var testabilities = lang_1.global.getAllAngularTestabilities();
	            var count = testabilities.length;
	            var didWork = false;
	            var decrement = function (didWork_ /** TODO #9100 */) {
	                didWork = didWork || didWork_;
	                count--;
	                if (count == 0) {
	                    callback(didWork);
	                }
	            };
	            testabilities.forEach(function (testability /** TODO #9100 */) {
	                testability.whenStable(decrement);
	            });
	        };
	        if (!lang_1.global.frameworkStabilizers) {
	            lang_1.global.frameworkStabilizers = collection_1.ListWrapper.createGrowableSize(0);
	        }
	        lang_1.global.frameworkStabilizers.push(whenAllStable);
	    };
	    BrowserGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
	        if (elem == null) {
	            return null;
	        }
	        var t = registry.getTestability(elem);
	        if (lang_1.isPresent(t)) {
	            return t;
	        }
	        else if (!findInAncestors) {
	            return null;
	        }
	        if (dom_adapter_1.getDOM().isShadowRoot(elem)) {
	            return this.findTestabilityInTree(registry, dom_adapter_1.getDOM().getHost(elem), true);
	        }
	        return this.findTestabilityInTree(registry, dom_adapter_1.getDOM().parentElement(elem), true);
	    };
	    return BrowserGetTestability;
	}());
	exports.BrowserGetTestability = BrowserGetTestability;
	//# sourceMappingURL=testability.js.map

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var core_private_1 = __webpack_require__(34);
	var dom_adapter_1 = __webpack_require__(7);
	var dom_renderer_1 = __webpack_require__(66);
	var CORE_TOKENS = {
	    'ApplicationRef': core_1.ApplicationRef,
	    'NgZone': core_1.NgZone
	};
	var INSPECT_GLOBAL_NAME = 'ng.probe';
	var CORE_TOKENS_GLOBAL_NAME = 'ng.coreTokens';
	/**
	 * Returns a {@link DebugElement} for the given native DOM element, or
	 * null if the given native element does not have an Angular view associated
	 * with it.
	 */
	function inspectNativeElement(element /** TODO #9100 */) {
	    return core_1.getDebugNode(element);
	}
	exports.inspectNativeElement = inspectNativeElement;
	function _createConditionalRootRenderer(rootRenderer /** TODO #9100 */) {
	    if (core_1.isDevMode()) {
	        return _createRootRenderer(rootRenderer);
	    }
	    return rootRenderer;
	}
	exports._createConditionalRootRenderer = _createConditionalRootRenderer;
	function _createRootRenderer(rootRenderer /** TODO #9100 */) {
	    dom_adapter_1.getDOM().setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
	    dom_adapter_1.getDOM().setGlobalVar(CORE_TOKENS_GLOBAL_NAME, CORE_TOKENS);
	    return new core_private_1.DebugDomRootRenderer(rootRenderer);
	}
	/**
	 * Providers which support debugging Angular applications (e.g. via `ng.probe`).
	 */
	exports.ELEMENT_PROBE_PROVIDERS = [{ provide: core_1.RootRenderer, useFactory: _createConditionalRootRenderer, deps: [dom_renderer_1.DomRootRenderer] }];
	exports.ELEMENT_PROBE_PROVIDERS_PROD_MODE = [{ provide: core_1.RootRenderer, useFactory: _createRootRenderer, deps: [dom_renderer_1.DomRootRenderer] }];
	//# sourceMappingURL=ng_probe.js.map

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(8);
	var lang_1 = __webpack_require__(5);
	var dom_adapter_1 = __webpack_require__(7);
	var event_manager_1 = __webpack_require__(23);
	var modifierKeys = ['alt', 'control', 'meta', 'shift'];
	var modifierKeyGetters = {
	    'alt': function (event) { return event.altKey; },
	    'control': function (event) { return event.ctrlKey; },
	    'meta': function (event) { return event.metaKey; },
	    'shift': function (event) { return event.shiftKey; }
	};
	var KeyEventsPlugin = (function (_super) {
	    __extends(KeyEventsPlugin, _super);
	    function KeyEventsPlugin() {
	        _super.call(this);
	    }
	    KeyEventsPlugin.prototype.supports = function (eventName) {
	        return lang_1.isPresent(KeyEventsPlugin.parseEventName(eventName));
	    };
	    KeyEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
	        var parsedEvent = KeyEventsPlugin.parseEventName(eventName);
	        var outsideHandler = KeyEventsPlugin.eventCallback(element, collection_1.StringMapWrapper.get(parsedEvent, 'fullKey'), handler, this.manager.getZone());
	        return this.manager.getZone().runOutsideAngular(function () {
	            return dom_adapter_1.getDOM().onAndCancel(element, collection_1.StringMapWrapper.get(parsedEvent, 'domEventName'), outsideHandler);
	        });
	    };
	    KeyEventsPlugin.parseEventName = function (eventName) {
	        var parts = eventName.toLowerCase().split('.');
	        var domEventName = parts.shift();
	        if ((parts.length === 0) ||
	            !(lang_1.StringWrapper.equals(domEventName, 'keydown') ||
	                lang_1.StringWrapper.equals(domEventName, 'keyup'))) {
	            return null;
	        }
	        var key = KeyEventsPlugin._normalizeKey(parts.pop());
	        var fullKey = '';
	        modifierKeys.forEach(function (modifierName) {
	            if (collection_1.ListWrapper.contains(parts, modifierName)) {
	                collection_1.ListWrapper.remove(parts, modifierName);
	                fullKey += modifierName + '.';
	            }
	        });
	        fullKey += key;
	        if (parts.length != 0 || key.length === 0) {
	            // returning null instead of throwing to let another plugin process the event
	            return null;
	        }
	        var result = collection_1.StringMapWrapper.create();
	        collection_1.StringMapWrapper.set(result, 'domEventName', domEventName);
	        collection_1.StringMapWrapper.set(result, 'fullKey', fullKey);
	        return result;
	    };
	    KeyEventsPlugin.getEventFullKey = function (event) {
	        var fullKey = '';
	        var key = dom_adapter_1.getDOM().getEventKey(event);
	        key = key.toLowerCase();
	        if (lang_1.StringWrapper.equals(key, ' ')) {
	            key = 'space'; // for readability
	        }
	        else if (lang_1.StringWrapper.equals(key, '.')) {
	            key = 'dot'; // because '.' is used as a separator in event names
	        }
	        modifierKeys.forEach(function (modifierName) {
	            if (modifierName != key) {
	                var modifierGetter = collection_1.StringMapWrapper.get(modifierKeyGetters, modifierName);
	                if (modifierGetter(event)) {
	                    fullKey += modifierName + '.';
	                }
	            }
	        });
	        fullKey += key;
	        return fullKey;
	    };
	    KeyEventsPlugin.eventCallback = function (element, fullKey, handler, zone) {
	        return function (event /** TODO #9100 */) {
	            if (lang_1.StringWrapper.equals(KeyEventsPlugin.getEventFullKey(event), fullKey)) {
	                zone.runGuarded(function () { return handler(event); });
	            }
	        };
	    };
	    /** @internal */
	    KeyEventsPlugin._normalizeKey = function (keyName) {
	        // TODO: switch to a StringMap if the mapping grows too much
	        switch (keyName) {
	            case 'esc':
	                return 'escape';
	            default:
	                return keyName;
	        }
	    };
	    /** @nocollapse */
	    KeyEventsPlugin.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    KeyEventsPlugin.ctorParameters = [];
	    return KeyEventsPlugin;
	}(event_manager_1.EventManagerPlugin));
	exports.KeyEventsPlugin = KeyEventsPlugin;
	//# sourceMappingURL=key_events.js.map

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(5);
	var CAMEL_CASE_REGEXP = /([A-Z])/g;
	var DASH_CASE_REGEXP = /-([a-z])/g;
	function camelCaseToDashCase(input) {
	    return lang_1.StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function (m /** TODO #9100 */) { return '-' + m[1].toLowerCase(); });
	}
	exports.camelCaseToDashCase = camelCaseToDashCase;
	function dashCaseToCamelCase(input) {
	    return lang_1.StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, function (m /** TODO #9100 */) { return m[1].toUpperCase(); });
	}
	exports.dashCaseToCamelCase = dashCaseToCamelCase;
	//# sourceMappingURL=util.js.map

/***/ },
/* 181 */
123,
/* 182 */
[294, 181, 8, 5],
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	exports.SecurityContext = core_1.SecurityContext;
	var html_sanitizer_1 = __webpack_require__(245);
	var style_sanitizer_1 = __webpack_require__(246);
	var url_sanitizer_1 = __webpack_require__(108);
	/**
	 * DomSanitizationService helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing
	 * values to be safe to use in the different DOM contexts.
	 *
	 * For example, when binding a URL in an `<a [href]="someValue">` hyperlink, `someValue` will be
	 * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on
	 * the website.
	 *
	 * In specific situations, it might be necessary to disable sanitization, for example if the
	 * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.
	 * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`
	 * methods, and then binding to that value from the template.
	 *
	 * These situations should be very rare, and extraordinary care must be taken to avoid creating a
	 * Cross Site Scripting (XSS) security bug!
	 *
	 * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as
	 * close as possible to the source of the value, to make it easy to verify no security bug is
	 * created by its use.
	 *
	 * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that
	 * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous
	 * code. The sanitizer leaves safe values intact.
	 *
	 * @security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in
	 * sanitization for the value passed in. Carefully check and audit all values and code paths going
	 * into this call. Make sure any user data is appropriately escaped for this security context.
	 * For more detail, see the [Security Guide](http://g.co/ng/security).
	 *
	 * @stable
	 */
	var DomSanitizationService = (function () {
	    function DomSanitizationService() {
	    }
	    return DomSanitizationService;
	}());
	exports.DomSanitizationService = DomSanitizationService;
	var DomSanitizationServiceImpl = (function (_super) {
	    __extends(DomSanitizationServiceImpl, _super);
	    function DomSanitizationServiceImpl() {
	        _super.apply(this, arguments);
	    }
	    DomSanitizationServiceImpl.prototype.sanitize = function (ctx, value) {
	        if (value == null)
	            return null;
	        switch (ctx) {
	            case core_1.SecurityContext.NONE:
	                return value;
	            case core_1.SecurityContext.HTML:
	                if (value instanceof SafeHtmlImpl)
	                    return value.changingThisBreaksApplicationSecurity;
	                this.checkNotSafeValue(value, 'HTML');
	                return html_sanitizer_1.sanitizeHtml(String(value));
	            case core_1.SecurityContext.STYLE:
	                if (value instanceof SafeStyleImpl)
	                    return value.changingThisBreaksApplicationSecurity;
	                this.checkNotSafeValue(value, 'Style');
	                return style_sanitizer_1.sanitizeStyle(value);
	            case core_1.SecurityContext.SCRIPT:
	                if (value instanceof SafeScriptImpl)
	                    return value.changingThisBreaksApplicationSecurity;
	                this.checkNotSafeValue(value, 'Script');
	                throw new Error('unsafe value used in a script context');
	            case core_1.SecurityContext.URL:
	                if (value instanceof SafeResourceUrlImpl || value instanceof SafeUrlImpl) {
	                    // Allow resource URLs in URL contexts, they are strictly more trusted.
	                    return value.changingThisBreaksApplicationSecurity;
	                }
	                this.checkNotSafeValue(value, 'URL');
	                return url_sanitizer_1.sanitizeUrl(String(value));
	            case core_1.SecurityContext.RESOURCE_URL:
	                if (value instanceof SafeResourceUrlImpl) {
	                    return value.changingThisBreaksApplicationSecurity;
	                }
	                this.checkNotSafeValue(value, 'ResourceURL');
	                throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');
	            default:
	                throw new Error("Unexpected SecurityContext " + ctx + " (see http://g.co/ng/security#xss)");
	        }
	    };
	    DomSanitizationServiceImpl.prototype.checkNotSafeValue = function (value, expectedType) {
	        if (value instanceof SafeValueImpl) {
	            throw new Error(("Required a safe " + expectedType + ", got a " + value.getTypeName() + " ") +
	                "(see http://g.co/ng/security#xss)");
	        }
	    };
	    DomSanitizationServiceImpl.prototype.bypassSecurityTrustHtml = function (value) { return new SafeHtmlImpl(value); };
	    DomSanitizationServiceImpl.prototype.bypassSecurityTrustStyle = function (value) { return new SafeStyleImpl(value); };
	    DomSanitizationServiceImpl.prototype.bypassSecurityTrustScript = function (value) { return new SafeScriptImpl(value); };
	    DomSanitizationServiceImpl.prototype.bypassSecurityTrustUrl = function (value) { return new SafeUrlImpl(value); };
	    DomSanitizationServiceImpl.prototype.bypassSecurityTrustResourceUrl = function (value) {
	        return new SafeResourceUrlImpl(value);
	    };
	    /** @nocollapse */
	    DomSanitizationServiceImpl.decorators = [
	        { type: core_1.Injectable },
	    ];
	    return DomSanitizationServiceImpl;
	}(DomSanitizationService));
	exports.DomSanitizationServiceImpl = DomSanitizationServiceImpl;
	var SafeValueImpl = (function () {
	    function SafeValueImpl(changingThisBreaksApplicationSecurity) {
	        this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
	        // empty
	    }
	    SafeValueImpl.prototype.toString = function () {
	        return ("SafeValue must use [property]=binding: " + this.changingThisBreaksApplicationSecurity) +
	            " (see http://g.co/ng/security#xss)";
	    };
	    return SafeValueImpl;
	}());
	var SafeHtmlImpl = (function (_super) {
	    __extends(SafeHtmlImpl, _super);
	    function SafeHtmlImpl() {
	        _super.apply(this, arguments);
	    }
	    SafeHtmlImpl.prototype.getTypeName = function () { return 'HTML'; };
	    return SafeHtmlImpl;
	}(SafeValueImpl));
	var SafeStyleImpl = (function (_super) {
	    __extends(SafeStyleImpl, _super);
	    function SafeStyleImpl() {
	        _super.apply(this, arguments);
	    }
	    SafeStyleImpl.prototype.getTypeName = function () { return 'Style'; };
	    return SafeStyleImpl;
	}(SafeValueImpl));
	var SafeScriptImpl = (function (_super) {
	    __extends(SafeScriptImpl, _super);
	    function SafeScriptImpl() {
	        _super.apply(this, arguments);
	    }
	    SafeScriptImpl.prototype.getTypeName = function () { return 'Script'; };
	    return SafeScriptImpl;
	}(SafeValueImpl));
	var SafeUrlImpl = (function (_super) {
	    __extends(SafeUrlImpl, _super);
	    function SafeUrlImpl() {
	        _super.apply(this, arguments);
	    }
	    SafeUrlImpl.prototype.getTypeName = function () { return 'URL'; };
	    return SafeUrlImpl;
	}(SafeValueImpl));
	var SafeResourceUrlImpl = (function (_super) {
	    __extends(SafeResourceUrlImpl, _super);
	    function SafeResourceUrlImpl() {
	        _super.apply(this, arguments);
	    }
	    SafeResourceUrlImpl.prototype.getTypeName = function () { return 'ResourceURL'; };
	    return SafeResourceUrlImpl;
	}(SafeValueImpl));
	//# sourceMappingURL=dom_sanitization_service.js.map

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	exports.ON_WEB_WORKER = new core_1.OpaqueToken('WebWorker.onWebWorker');
	//# sourceMappingURL=api.js.map

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var async_1 = __webpack_require__(243);
	var collection_1 = __webpack_require__(8);
	var exceptions_1 = __webpack_require__(19);
	var PostMessageBusSink = (function () {
	    function PostMessageBusSink(_postMessageTarget) {
	        this._postMessageTarget = _postMessageTarget;
	        this._channels = collection_1.StringMapWrapper.create();
	        this._messageBuffer = [];
	    }
	    PostMessageBusSink.prototype.attachToZone = function (zone) {
	        var _this = this;
	        this._zone = zone;
	        this._zone.runOutsideAngular(function () { _this._zone.onStable.subscribe({ next: function () { _this._handleOnEventDone(); } }); });
	    };
	    PostMessageBusSink.prototype.initChannel = function (channel, runInZone) {
	        var _this = this;
	        if (runInZone === void 0) { runInZone = true; }
	        if (collection_1.StringMapWrapper.contains(this._channels, channel)) {
	            throw new exceptions_1.BaseException(channel + " has already been initialized");
	        }
	        var emitter = new async_1.EventEmitter(false);
	        var channelInfo = new _Channel(emitter, runInZone);
	        this._channels[channel] = channelInfo;
	        emitter.subscribe(function (data) {
	            var message = { channel: channel, message: data };
	            if (runInZone) {
	                _this._messageBuffer.push(message);
	            }
	            else {
	                _this._sendMessages([message]);
	            }
	        });
	    };
	    PostMessageBusSink.prototype.to = function (channel) {
	        if (collection_1.StringMapWrapper.contains(this._channels, channel)) {
	            return this._channels[channel].emitter;
	        }
	        else {
	            throw new exceptions_1.BaseException(channel + " is not set up. Did you forget to call initChannel?");
	        }
	    };
	    PostMessageBusSink.prototype._handleOnEventDone = function () {
	        if (this._messageBuffer.length > 0) {
	            this._sendMessages(this._messageBuffer);
	            this._messageBuffer = [];
	        }
	    };
	    PostMessageBusSink.prototype._sendMessages = function (messages) { this._postMessageTarget.postMessage(messages); };
	    return PostMessageBusSink;
	}());
	exports.PostMessageBusSink = PostMessageBusSink;
	var PostMessageBusSource = (function () {
	    function PostMessageBusSource(eventTarget) {
	        var _this = this;
	        this._channels = collection_1.StringMapWrapper.create();
	        if (eventTarget) {
	            eventTarget.addEventListener('message', function (ev) { return _this._handleMessages(ev); });
	        }
	        else {
	            // if no eventTarget is given we assume we're in a WebWorker and listen on the global scope
	            var workerScope = self;
	            workerScope.addEventListener('message', function (ev) { return _this._handleMessages(ev); });
	        }
	    }
	    PostMessageBusSource.prototype.attachToZone = function (zone) { this._zone = zone; };
	    PostMessageBusSource.prototype.initChannel = function (channel, runInZone) {
	        if (runInZone === void 0) { runInZone = true; }
	        if (collection_1.StringMapWrapper.contains(this._channels, channel)) {
	            throw new exceptions_1.BaseException(channel + " has already been initialized");
	        }
	        var emitter = new async_1.EventEmitter(false);
	        var channelInfo = new _Channel(emitter, runInZone);
	        this._channels[channel] = channelInfo;
	    };
	    PostMessageBusSource.prototype.from = function (channel) {
	        if (collection_1.StringMapWrapper.contains(this._channels, channel)) {
	            return this._channels[channel].emitter;
	        }
	        else {
	            throw new exceptions_1.BaseException(channel + " is not set up. Did you forget to call initChannel?");
	        }
	    };
	    PostMessageBusSource.prototype._handleMessages = function (ev) {
	        var messages = ev.data;
	        for (var i = 0; i < messages.length; i++) {
	            this._handleMessage(messages[i]);
	        }
	    };
	    PostMessageBusSource.prototype._handleMessage = function (data) {
	        var channel = data.channel;
	        if (collection_1.StringMapWrapper.contains(this._channels, channel)) {
	            var channelInfo = this._channels[channel];
	            if (channelInfo.runInZone) {
	                this._zone.run(function () { channelInfo.emitter.emit(data.message); });
	            }
	            else {
	                channelInfo.emitter.emit(data.message);
	            }
	        }
	    };
	    return PostMessageBusSource;
	}());
	exports.PostMessageBusSource = PostMessageBusSource;
	var PostMessageBus = (function () {
	    function PostMessageBus(sink, source) {
	        this.sink = sink;
	        this.source = source;
	    }
	    PostMessageBus.prototype.attachToZone = function (zone) {
	        this.source.attachToZone(zone);
	        this.sink.attachToZone(zone);
	    };
	    PostMessageBus.prototype.initChannel = function (channel, runInZone) {
	        if (runInZone === void 0) { runInZone = true; }
	        this.source.initChannel(channel, runInZone);
	        this.sink.initChannel(channel, runInZone);
	    };
	    PostMessageBus.prototype.from = function (channel) { return this.source.from(channel); };
	    PostMessageBus.prototype.to = function (channel) { return this.sink.to(channel); };
	    /** @nocollapse */
	    PostMessageBus.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    PostMessageBus.ctorParameters = [
	        { type: PostMessageBusSink, },
	        { type: PostMessageBusSource, },
	    ];
	    return PostMessageBus;
	}());
	exports.PostMessageBus = PostMessageBus;
	/**
	 * Helper class that wraps a channel's {@link EventEmitter} and
	 * keeps track of if it should run in the zone.
	 */
	var _Channel = (function () {
	    function _Channel(emitter, runInZone) {
	        this.emitter = emitter;
	        this.runInZone = runInZone;
	    }
	    return _Channel;
	}());
	//# sourceMappingURL=post_message_bus.js.map

/***/ },
/* 186 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	// no deserialization is necessary in TS.
	// This is only here to match dart interface
	function deserializeGenericEvent(serializedEvent) {
	    return serializedEvent;
	}
	exports.deserializeGenericEvent = deserializeGenericEvent;
	//# sourceMappingURL=event_deserializer.js.map

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.HalClient = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _core = __webpack_require__(1);

	var _field = __webpack_require__(110);

	var _object = __webpack_require__(39);

	var _resourceFactory = __webpack_require__(69);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = undefined && undefined.__metadata || function (k, v) {
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};

	/**
	 *
	 */
	var HalClient = exports.HalClient = function () {
	    function HalClient(resourceFactory) {
	        _classCallCheck(this, HalClient);

	        this.resourceFactory = resourceFactory;
	    }

	    _createClass(HalClient, [{
	        key: "resource",
	        value: function resource(url, metadata) {
	            return this.resourceFactory.createResource(new _object.HalLinkObject(url, false), new _field.HalFieldTypeDescription(metadata));
	        }
	    }]);

	    return HalClient;
	}();
	exports.HalClient = HalClient = __decorate([(0, _core.Injectable)(), __metadata('design:paramtypes', [_resourceFactory.HalResourceFactory])], HalClient);

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.HalError = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _coreDecorators = __webpack_require__(264);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = undefined && undefined.__metadata || function (k, v) {
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};

	/**
	 *
	 */
	var HalError = exports.HalError = function () {
	    function HalError(status, message) {
	        _classCallCheck(this, HalError);

	        this.status = status;
	        this.message = message;
	    }

	    _createClass(HalError, [{
	        key: "toString",
	        value: function toString() {
	            return this.status + ": " + this.message;
	        }
	    }]);

	    return HalError;
	}();

	__decorate([_coreDecorators.override, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', String)], HalError.prototype, "toString", null);

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.HalJsonObjectSerializer = exports.BaseHalJsonObjectSerializerOptions = exports.HalJsonObjectSerializerOptions = undefined;

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _core = __webpack_require__(1);

	var _object = __webpack_require__(39);

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = undefined && undefined.__metadata || function (k, v) {
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};

	var HalJsonObjectSerializerOptions = exports.HalJsonObjectSerializerOptions = function HalJsonObjectSerializerOptions() {
	    _classCallCheck(this, HalJsonObjectSerializerOptions);
	};

	var BaseHalJsonObjectSerializerOptions = exports.BaseHalJsonObjectSerializerOptions = function (_HalJsonObjectSeriali) {
	    _inherits(BaseHalJsonObjectSerializerOptions, _HalJsonObjectSeriali);

	    function BaseHalJsonObjectSerializerOptions() {
	        _classCallCheck(this, BaseHalJsonObjectSerializerOptions);

	        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BaseHalJsonObjectSerializerOptions).call(this));

	        _this.embeddedKey = '_embedded';
	        _this.linksKey = '_links';
	        return _this;
	    }

	    return BaseHalJsonObjectSerializerOptions;
	}(HalJsonObjectSerializerOptions);
	exports.BaseHalJsonObjectSerializerOptions = BaseHalJsonObjectSerializerOptions = __decorate([(0, _core.Injectable)(), __metadata('design:paramtypes', [])], BaseHalJsonObjectSerializerOptions);
	var HalJsonObjectSerializer = exports.HalJsonObjectSerializer = function (_HalObjectSerializer) {
	    _inherits(HalJsonObjectSerializer, _HalObjectSerializer);

	    function HalJsonObjectSerializer(options) {
	        _classCallCheck(this, HalJsonObjectSerializer);

	        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(HalJsonObjectSerializer).call(this));

	        _this2.options = options;
	        return _this2;
	    }

	    _createClass(HalJsonObjectSerializer, [{
	        key: "deserialize",
	        value: function deserialize(data) {
	            var json = JSON.parse(data);
	            return this.toObject(json);
	        }
	    }, {
	        key: "toObject",
	        value: function toObject(json) {
	            var _this3 = this;

	            /* Special case when the JSON is an array. */
	            if (json instanceof Array) {
	                return json.map(function (element) {
	                    return _this3.toObject(element);
	                });
	            }
	            var embedded = {};
	            var links = {};
	            var resource = {};
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;

	            try {
	                for (var _iterator = Object.entries(json)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var _step$value = _slicedToArray(_step.value, 2);

	                    var key = _step$value[0];
	                    var value = _step$value[1];

	                    switch (key) {
	                        case this.options.embeddedKey:
	                            /* Propagate HalObject into the embedded objects. */
	                            var _iteratorNormalCompletion2 = true;
	                            var _didIteratorError2 = false;
	                            var _iteratorError2 = undefined;

	                            try {
	                                for (var _iterator2 = Object.entries(value)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                                    var _step2$value = _slicedToArray(_step2.value, 2);

	                                    var embedKey = _step2$value[0];
	                                    var embedValue = _step2$value[1];

	                                    embedded[embedKey] = this.toObject(embedValue);
	                                }
	                            } catch (err) {
	                                _didIteratorError2 = true;
	                                _iteratorError2 = err;
	                            } finally {
	                                try {
	                                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                                        _iterator2.return();
	                                    }
	                                } finally {
	                                    if (_didIteratorError2) {
	                                        throw _iteratorError2;
	                                    }
	                                }
	                            }

	                            break;
	                        case this.options.linksKey:
	                            /* Propagate HalLinkObject into the links. */
	                            var _iteratorNormalCompletion3 = true;
	                            var _didIteratorError3 = false;
	                            var _iteratorError3 = undefined;

	                            try {
	                                for (var _iterator3 = Object.entries(value)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                                    var _step3$value = _slicedToArray(_step3.value, 2);

	                                    var linkKey = _step3$value[0];
	                                    var linkValue = _step3$value[1];

	                                    links[linkKey] = this.toLinkObject(linkValue);
	                                }
	                            } catch (err) {
	                                _didIteratorError3 = true;
	                                _iteratorError3 = err;
	                            } finally {
	                                try {
	                                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                                        _iterator3.return();
	                                    }
	                                } finally {
	                                    if (_didIteratorError3) {
	                                        throw _iteratorError3;
	                                    }
	                                }
	                            }

	                            break;
	                        default:
	                            resource[key] = value;
	                            break;
	                    }
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }

	            return new _object.HalObject(embedded, links, resource);
	        }
	    }, {
	        key: "toLinkObject",
	        value: function toLinkObject(json) {
	            var _this4 = this;

	            /* Special case when the JSON is an array. */
	            if (json instanceof Array) {
	                return json.map(function (element) {
	                    return _this4.toLinkObject(element);
	                });
	            }
	            return new _object.HalLinkObject(json.href, json.templated);
	        }
	    }, {
	        key: "serialize",
	        value: function serialize(object) {
	            return '';
	        }
	    }]);

	    return HalJsonObjectSerializer;
	}(_object.HalObjectSerializer);
	exports.HalJsonObjectSerializer = HalJsonObjectSerializer = __decorate([(0, _core.Injectable)(), __metadata('design:paramtypes', [HalJsonObjectSerializerOptions])], HalJsonObjectSerializer);

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.HAL_COLLECTION_TRANSLATORS = exports.HAL_OBJECT_TRANSLATORS = undefined;

	var _core = __webpack_require__(1);

	var HAL_OBJECT_TRANSLATORS = exports.HAL_OBJECT_TRANSLATORS = new _core.OpaqueToken('halObjectTranslators');
	var HAL_COLLECTION_TRANSLATORS = exports.HAL_COLLECTION_TRANSLATORS = new _core.OpaqueToken('halCollectionTranslators');

/***/ },
/* 191 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * A translator that simply returns the value as given.
	 */
	var HalArrayTranslator = exports.HalArrayTranslator = function () {
	    function HalArrayTranslator() {
	        _classCallCheck(this, HalArrayTranslator);
	    }

	    _createClass(HalArrayTranslator, [{
	        key: "appliesTo",

	        /**
	         * Only apply when we've reached the bottom of the prototype chain.
	         */
	        value: function appliesTo(type) {
	            return type === Array;
	        }
	    }, {
	        key: "toArray",
	        value: function toArray(value, type) {
	            if (Array.isArray(value)) {
	                return value;
	            }
	            throw new TypeError("Expected value of type Array, but got " + value.construtype.name);
	        }
	    }, {
	        key: "fromArray",
	        value: function fromArray(value, type) {
	            return value;
	        }
	    }]);

	    return HalArrayTranslator;
	}();

/***/ },
/* 192 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * A translator that simply returns the value as given.
	 */
	var HalDefaultObjectTranslator = exports.HalDefaultObjectTranslator = function () {
	    function HalDefaultObjectTranslator() {
	        _classCallCheck(this, HalDefaultObjectTranslator);
	    }

	    _createClass(HalDefaultObjectTranslator, [{
	        key: "appliesTo",

	        /**
	         * Only apply when we've reached the bottom of the prototype chain.
	         */
	        value: function appliesTo(type) {
	            return !type;
	        }
	    }, {
	        key: "toObject",
	        value: function toObject(value, type) {
	            var instance = {};
	            Object.assign(instance, value);
	            return instance;
	        }
	    }, {
	        key: "fromObject",
	        value: function fromObject(value, type) {
	            var instance = Reflect.construct(type, []);
	            Object.assign(instance, value);
	            return instance;
	        }
	    }]);

	    return HalDefaultObjectTranslator;
	}();

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = lazyInitialize;

	var _privateUtils = __webpack_require__(9);

	function handleDescriptor(target, key, descriptor) {
	  var configurable = descriptor.configurable;
	  var enumerable = descriptor.enumerable;
	  var initializer = descriptor.initializer;
	  var value = descriptor.value;

	  return {
	    configurable: configurable,
	    enumerable: enumerable,

	    get: function get() {
	      // This happens if someone accesses the
	      // property directly on the prototype
	      if (this === target) {
	        return;
	      }

	      var ret = initializer ? initializer.call(this) : value;

	      Object.defineProperty(this, key, {
	        configurable: configurable,
	        enumerable: enumerable,
	        writable: true,
	        value: ret
	      });

	      return ret;
	    },

	    set: (0, _privateUtils.createDefaultSetter)(key)
	  };
	}

	function lazyInitialize() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return (0, _privateUtils.decorate)(handleDescriptor, args);
	}

	module.exports = exports['default'];

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(196);
	var Subscription_1 = __webpack_require__(113);
	var rxSubscriber_1 = __webpack_require__(114);
	var Observer_1 = __webpack_require__(279);
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = (function (_super) {
	    __extends(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        this.destination = destinationOrNext;
	                        this.destination.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
	        return this;
	    };
	    return Subscriber;
	}(Subscription_1.Subscription));
	exports.Subscriber = Subscriber;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parent, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parent = _parent;
	        var next;
	        var context = this;
	        if (isFunction_1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            context = observerOrNext;
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (isFunction_1.isFunction(context.unsubscribe)) {
	                this.add(context.unsubscribe.bind(context));
	            }
	            context.unsubscribe = this.unsubscribe.bind(this);
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parent = this._parent;
	            if (!_parent.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parent, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._error) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parent.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parent.syncErrorValue = err;
	                _parent.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._complete) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._complete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._complete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    SafeSubscriber.prototype._unsubscribe = function () {
	        var _parent = this._parent;
	        this._context = null;
	        this._parent = null;
	        _parent.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));
	//# sourceMappingURL=Subscriber.js.map

/***/ },
/* 195 */
/***/ function(module, exports) {

	"use strict";
	// typeof any so that it we don't have to cast when comparing a result to the error object
	exports.errorObject = { e: {} };
	//# sourceMappingURL=errorObject.js.map

/***/ },
/* 196 */
/***/ function(module, exports) {

	"use strict";
	function isFunction(x) {
	    return typeof x === 'function';
	}
	exports.isFunction = isFunction;
	//# sourceMappingURL=isFunction.js.map

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var ng_class_1 = __webpack_require__(117);
	var ng_for_1 = __webpack_require__(118);
	var ng_if_1 = __webpack_require__(119);
	var ng_plural_1 = __webpack_require__(120);
	var ng_style_1 = __webpack_require__(121);
	var ng_switch_1 = __webpack_require__(70);
	var ng_template_outlet_1 = __webpack_require__(122);
	/**
	 * A collection of Angular core directives that are likely to be used in each and every Angular
	 * application.
	 *
	 * This collection can be used to quickly enumerate all the built-in directives in the `directives`
	 * property of the `@Component` annotation.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/yakGwpCdUkg0qfzX5m8g?p=preview))
	 *
	 * Instead of writing:
	 *
	 * ```typescript
	 * import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault} from '@angular/common';
	 * import {OtherDirective} from './myDirectives';
	 *
	 * @Component({
	 *   selector: 'my-component',
	 *   templateUrl: 'myComponent.html',
	 *   directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, OtherDirective]
	 * })
	 * export class MyComponent {
	 *   ...
	 * }
	 * ```
	 * one could import all the core directives at once:
	 *
	 * ```typescript
	 * import {CORE_DIRECTIVES} from '@angular/common';
	 * import {OtherDirective} from './myDirectives';
	 *
	 * @Component({
	 *   selector: 'my-component',
	 *   templateUrl: 'myComponent.html',
	 *   directives: [CORE_DIRECTIVES, OtherDirective]
	 * })
	 * export class MyComponent {
	 *   ...
	 * }
	 * ```
	 *
	 * @stable
	 */
	exports.CORE_DIRECTIVES = [
	    ng_class_1.NgClass,
	    ng_for_1.NgFor,
	    ng_if_1.NgIf,
	    ng_template_outlet_1.NgTemplateOutlet,
	    ng_style_1.NgStyle,
	    ng_switch_1.NgSwitch,
	    ng_switch_1.NgSwitchCase,
	    ng_switch_1.NgSwitchDefault,
	    ng_plural_1.NgPlural,
	    ng_plural_1.NgPluralCase,
	];
	//# sourceMappingURL=core_directives.js.map

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * @module
	 * @description
	 * This module is used for handling user input, by defining and building a {@link ControlGroup} that
	 * consists of
	 * {@link Control} objects, and mapping them onto the DOM. {@link Control} objects can then be used
	 * to read information
	 * from the form DOM elements.
	 *
	 * Forms providers are not included in default providers; you must import these providers
	 * explicitly.
	 */
	var core_1 = __webpack_require__(1);
	var directives_1 = __webpack_require__(126);
	var radio_control_value_accessor_1 = __webpack_require__(43);
	var form_builder_1 = __webpack_require__(127);
	var directives_2 = __webpack_require__(126);
	exports.FORM_DIRECTIVES = directives_2.FORM_DIRECTIVES;
	exports.RadioButtonState = directives_2.RadioButtonState;
	var abstract_control_directive_1 = __webpack_require__(71);
	exports.AbstractControlDirective = abstract_control_directive_1.AbstractControlDirective;
	var checkbox_value_accessor_1 = __webpack_require__(41);
	exports.CheckboxControlValueAccessor = checkbox_value_accessor_1.CheckboxControlValueAccessor;
	var control_container_1 = __webpack_require__(29);
	exports.ControlContainer = control_container_1.ControlContainer;
	var control_value_accessor_1 = __webpack_require__(13);
	exports.NG_VALUE_ACCESSOR = control_value_accessor_1.NG_VALUE_ACCESSOR;
	var default_value_accessor_1 = __webpack_require__(42);
	exports.DefaultValueAccessor = default_value_accessor_1.DefaultValueAccessor;
	var ng_control_1 = __webpack_require__(21);
	exports.NgControl = ng_control_1.NgControl;
	var ng_control_group_1 = __webpack_require__(72);
	exports.NgControlGroup = ng_control_group_1.NgControlGroup;
	var ng_control_name_1 = __webpack_require__(73);
	exports.NgControlName = ng_control_name_1.NgControlName;
	var ng_control_status_1 = __webpack_require__(74);
	exports.NgControlStatus = ng_control_status_1.NgControlStatus;
	var ng_form_1 = __webpack_require__(75);
	exports.NgForm = ng_form_1.NgForm;
	var ng_form_control_1 = __webpack_require__(76);
	exports.NgFormControl = ng_form_control_1.NgFormControl;
	var ng_form_model_1 = __webpack_require__(77);
	exports.NgFormModel = ng_form_model_1.NgFormModel;
	var ng_model_1 = __webpack_require__(78);
	exports.NgModel = ng_model_1.NgModel;
	var select_control_value_accessor_1 = __webpack_require__(44);
	exports.NgSelectOption = select_control_value_accessor_1.NgSelectOption;
	exports.SelectControlValueAccessor = select_control_value_accessor_1.SelectControlValueAccessor;
	var validators_1 = __webpack_require__(81);
	exports.MaxLengthValidator = validators_1.MaxLengthValidator;
	exports.MinLengthValidator = validators_1.MinLengthValidator;
	exports.PatternValidator = validators_1.PatternValidator;
	exports.RequiredValidator = validators_1.RequiredValidator;
	var form_builder_2 = __webpack_require__(127);
	exports.FormBuilder = form_builder_2.FormBuilder;
	var model_1 = __webpack_require__(45);
	exports.AbstractControl = model_1.AbstractControl;
	exports.Control = model_1.Control;
	exports.ControlArray = model_1.ControlArray;
	exports.ControlGroup = model_1.ControlGroup;
	var validators_2 = __webpack_require__(15);
	exports.NG_ASYNC_VALIDATORS = validators_2.NG_ASYNC_VALIDATORS;
	exports.NG_VALIDATORS = validators_2.NG_VALIDATORS;
	exports.Validators = validators_2.Validators;
	/**
	 * Shorthand set of providers used for building Angular forms.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * bootstrap(MyApp, [FORM_PROVIDERS]);
	 * ```
	 *
	 * @experimental
	 */
	exports.FORM_PROVIDERS = [form_builder_1.FormBuilder, radio_control_value_accessor_1.RadioControlRegistry];
	var DeprecatedFormsModule = (function () {
	    function DeprecatedFormsModule() {
	    }
	    /** @nocollapse */
	    DeprecatedFormsModule.decorators = [
	        { type: core_1.NgModule, args: [{
	                    providers: [
	                        exports.FORM_PROVIDERS,
	                    ],
	                    declarations: directives_1.FORM_DIRECTIVES,
	                    exports: directives_1.FORM_DIRECTIVES
	                },] },
	    ];
	    return DeprecatedFormsModule;
	}());
	exports.DeprecatedFormsModule = DeprecatedFormsModule;
	//# sourceMappingURL=forms-deprecated.js.map

/***/ },
/* 199 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	function normalizeValidator(validator) {
	    if (validator.validate !== undefined) {
	        return function (c) { return validator.validate(c); };
	    }
	    else {
	        return validator;
	    }
	}
	exports.normalizeValidator = normalizeValidator;
	function normalizeAsyncValidator(validator) {
	    if (validator.validate !== undefined) {
	        return function (c) { return validator.validate(c); };
	    }
	    else {
	        return validator;
	    }
	}
	exports.normalizeAsyncValidator = normalizeAsyncValidator;
	//# sourceMappingURL=normalize_validator.js.map

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(84));
	__export(__webpack_require__(46));
	__export(__webpack_require__(201));
	__export(__webpack_require__(202));
	__export(__webpack_require__(83));
	//# sourceMappingURL=location.js.map

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(3);
	var location_1 = __webpack_require__(83);
	var location_strategy_1 = __webpack_require__(46);
	var platform_location_1 = __webpack_require__(84);
	var HashLocationStrategy = (function (_super) {
	    __extends(HashLocationStrategy, _super);
	    function HashLocationStrategy(_platformLocation, _baseHref) {
	        _super.call(this);
	        this._platformLocation = _platformLocation;
	        this._baseHref = '';
	        if (lang_1.isPresent(_baseHref)) {
	            this._baseHref = _baseHref;
	        }
	    }
	    HashLocationStrategy.prototype.onPopState = function (fn) {
	        this._platformLocation.onPopState(fn);
	        this._platformLocation.onHashChange(fn);
	    };
	    HashLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
	    HashLocationStrategy.prototype.path = function (includeHash) {
	        if (includeHash === void 0) { includeHash = false; }
	        // the hash value is always prefixed with a `#`
	        // and if it is empty then it will stay empty
	        var path = this._platformLocation.hash;
	        if (!lang_1.isPresent(path))
	            path = '#';
	        return path.length > 0 ? path.substring(1) : path;
	    };
	    HashLocationStrategy.prototype.prepareExternalUrl = function (internal) {
	        var url = location_1.Location.joinWithSlash(this._baseHref, internal);
	        return url.length > 0 ? ('#' + url) : url;
	    };
	    HashLocationStrategy.prototype.pushState = function (state, title, path, queryParams) {
	        var url = this.prepareExternalUrl(path + location_1.Location.normalizeQueryParams(queryParams));
	        if (url.length == 0) {
	            url = this._platformLocation.pathname;
	        }
	        this._platformLocation.pushState(state, title, url);
	    };
	    HashLocationStrategy.prototype.replaceState = function (state, title, path, queryParams) {
	        var url = this.prepareExternalUrl(path + location_1.Location.normalizeQueryParams(queryParams));
	        if (url.length == 0) {
	            url = this._platformLocation.pathname;
	        }
	        this._platformLocation.replaceState(state, title, url);
	    };
	    HashLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
	    HashLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
	    /** @nocollapse */
	    HashLocationStrategy.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    HashLocationStrategy.ctorParameters = [
	        { type: platform_location_1.PlatformLocation, },
	        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Inject, args: [location_strategy_1.APP_BASE_HREF,] },] },
	    ];
	    return HashLocationStrategy;
	}(location_strategy_1.LocationStrategy));
	exports.HashLocationStrategy = HashLocationStrategy;
	//# sourceMappingURL=hash_location_strategy.js.map

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(1);
	var exceptions_1 = __webpack_require__(20);
	var lang_1 = __webpack_require__(3);
	var location_1 = __webpack_require__(83);
	var location_strategy_1 = __webpack_require__(46);
	var platform_location_1 = __webpack_require__(84);
	var PathLocationStrategy = (function (_super) {
	    __extends(PathLocationStrategy, _super);
	    function PathLocationStrategy(_platformLocation, href) {
	        _super.call(this);
	        this._platformLocation = _platformLocation;
	        if (lang_1.isBlank(href)) {
	            href = this._platformLocation.getBaseHrefFromDOM();
	        }
	        if (lang_1.isBlank(href)) {
	            throw new exceptions_1.BaseException("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
	        }
	        this._baseHref = href;
	    }
	    PathLocationStrategy.prototype.onPopState = function (fn) {
	        this._platformLocation.onPopState(fn);
	        this._platformLocation.onHashChange(fn);
	    };
	    PathLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
	    PathLocationStrategy.prototype.prepareExternalUrl = function (internal) {
	        return location_1.Location.joinWithSlash(this._baseHref, internal);
	    };
	    PathLocationStrategy.prototype.path = function (includeHash) {
	        if (includeHash === void 0) { includeHash = false; }
	        var pathname = this._platformLocation.pathname +
	            location_1.Location.normalizeQueryParams(this._platformLocation.search);
	        var hash = this._platformLocation.hash;
	        return hash && includeHash ? "" + pathname + hash : pathname;
	    };
	    PathLocationStrategy.prototype.pushState = function (state, title, url, queryParams) {
	        var externalUrl = this.prepareExternalUrl(url + location_1.Location.normalizeQueryParams(queryParams));
	        this._platformLocation.pushState(state, title, externalUrl);
	    };
	    PathLocationStrategy.prototype.replaceState = function (state, title, url, queryParams) {
	        var externalUrl = this.prepareExternalUrl(url + location_1.Location.normalizeQueryParams(queryParams));
	        this._platformLocation.replaceState(state, title, externalUrl);
	    };
	    PathLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
	    PathLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
	    /** @nocollapse */
	    PathLocationStrategy.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    PathLocationStrategy.ctorParameters = [
	        { type: platform_location_1.PlatformLocation, },
	        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Inject, args: [location_strategy_1.APP_BASE_HREF,] },] },
	    ];
	    return PathLocationStrategy;
	}(location_strategy_1.LocationStrategy));
	exports.PathLocationStrategy = PathLocationStrategy;
	//# sourceMappingURL=path_location_strategy.js.map

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * @module
	 * @description
	 * This module provides a set of common Pipes.
	 */
	var async_pipe_1 = __webpack_require__(129);
	var date_pipe_1 = __webpack_require__(130);
	var i18n_plural_pipe_1 = __webpack_require__(131);
	var i18n_select_pipe_1 = __webpack_require__(132);
	var json_pipe_1 = __webpack_require__(133);
	var lowercase_pipe_1 = __webpack_require__(134);
	var number_pipe_1 = __webpack_require__(135);
	var replace_pipe_1 = __webpack_require__(136);
	var slice_pipe_1 = __webpack_require__(137);
	var uppercase_pipe_1 = __webpack_require__(138);
	/**
	 * A collection of Angular core pipes that are likely to be used in each and every
	 * application.
	 *
	 * This collection can be used to quickly enumerate all the built-in pipes in the `pipes`
	 * property of the `@Component` decorator.
	 *
	 * @experimental Contains i18n pipes which are experimental
	 */
	exports.COMMON_PIPES = [
	    async_pipe_1.AsyncPipe,
	    uppercase_pipe_1.UpperCasePipe,
	    lowercase_pipe_1.LowerCasePipe,
	    json_pipe_1.JsonPipe,
	    slice_pipe_1.SlicePipe,
	    number_pipe_1.DecimalPipe,
	    number_pipe_1.PercentPipe,
	    number_pipe_1.CurrencyPipe,
	    date_pipe_1.DatePipe,
	    replace_pipe_1.ReplacePipe,
	    i18n_plural_pipe_1.I18nPluralPipe,
	    i18n_select_pipe_1.I18nSelectPipe,
	];
	//# sourceMappingURL=common_pipes.js.map

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var animation_constants_1 = __webpack_require__(139);
	var animation_group_player_1 = __webpack_require__(140);
	var animation_keyframe_1 = __webpack_require__(205);
	var animation_player_1 = __webpack_require__(85);
	var animation_sequence_player_1 = __webpack_require__(206);
	var animationUtils = __webpack_require__(207);
	var animation_styles_1 = __webpack_require__(208);
	var change_detection_util = __webpack_require__(49);
	var constants = __webpack_require__(50);
	var console = __webpack_require__(51);
	var debug = __webpack_require__(213);
	var provider_util = __webpack_require__(147);
	var reflective_provider = __webpack_require__(92);
	var component_factory_resolver = __webpack_require__(54);
	var debug_context = __webpack_require__(151);
	var element = __webpack_require__(95);
	var ng_module_factory = __webpack_require__(154);
	var template_ref = __webpack_require__(155);
	var view = __webpack_require__(222);
	var view_type = __webpack_require__(55);
	var view_utils = __webpack_require__(56);
	var lifecycle_hooks = __webpack_require__(161);
	var metadata_view = __webpack_require__(163);
	var wtf_init = __webpack_require__(226);
	var reflection = __webpack_require__(97);
	var reflection_capabilities = __webpack_require__(164);
	var reflector_reader = __webpack_require__(98);
	var api = __webpack_require__(99);
	var decorators = __webpack_require__(58);
	exports.__core_private__ = {
	    isDefaultChangeDetectionStrategy: constants.isDefaultChangeDetectionStrategy,
	    ChangeDetectorStatus: constants.ChangeDetectorStatus,
	    CHANGE_DETECTION_STRATEGY_VALUES: constants.CHANGE_DETECTION_STRATEGY_VALUES,
	    constructDependencies: reflective_provider.constructDependencies,
	    LifecycleHooks: lifecycle_hooks.LifecycleHooks,
	    LIFECYCLE_HOOKS_VALUES: lifecycle_hooks.LIFECYCLE_HOOKS_VALUES,
	    ReflectorReader: reflector_reader.ReflectorReader,
	    CodegenComponentFactoryResolver: component_factory_resolver.CodegenComponentFactoryResolver,
	    AppElement: element.AppElement,
	    AppView: view.AppView,
	    DebugAppView: view.DebugAppView,
	    NgModuleInjector: ng_module_factory.NgModuleInjector,
	    ViewType: view_type.ViewType,
	    MAX_INTERPOLATION_VALUES: view_utils.MAX_INTERPOLATION_VALUES,
	    checkBinding: view_utils.checkBinding,
	    flattenNestedViewRenderNodes: view_utils.flattenNestedViewRenderNodes,
	    interpolate: view_utils.interpolate,
	    ViewUtils: view_utils.ViewUtils,
	    VIEW_ENCAPSULATION_VALUES: metadata_view.VIEW_ENCAPSULATION_VALUES,
	    DebugContext: debug_context.DebugContext,
	    StaticNodeDebugInfo: debug_context.StaticNodeDebugInfo,
	    devModeEqual: change_detection_util.devModeEqual,
	    UNINITIALIZED: change_detection_util.UNINITIALIZED,
	    ValueUnwrapper: change_detection_util.ValueUnwrapper,
	    RenderDebugInfo: api.RenderDebugInfo,
	    TemplateRef_: template_ref.TemplateRef_,
	    wtfInit: wtf_init.wtfInit,
	    ReflectionCapabilities: reflection_capabilities.ReflectionCapabilities,
	    makeDecorator: decorators.makeDecorator,
	    DebugDomRootRenderer: debug.DebugDomRootRenderer,
	    createProvider: provider_util.createProvider,
	    isProviderLiteral: provider_util.isProviderLiteral,
	    EMPTY_ARRAY: view_utils.EMPTY_ARRAY,
	    EMPTY_MAP: view_utils.EMPTY_MAP,
	    pureProxy1: view_utils.pureProxy1,
	    pureProxy2: view_utils.pureProxy2,
	    pureProxy3: view_utils.pureProxy3,
	    pureProxy4: view_utils.pureProxy4,
	    pureProxy5: view_utils.pureProxy5,
	    pureProxy6: view_utils.pureProxy6,
	    pureProxy7: view_utils.pureProxy7,
	    pureProxy8: view_utils.pureProxy8,
	    pureProxy9: view_utils.pureProxy9,
	    pureProxy10: view_utils.pureProxy10,
	    castByValue: view_utils.castByValue,
	    Console: console.Console,
	    reflector: reflection.reflector,
	    Reflector: reflection.Reflector,
	    NoOpAnimationPlayer: animation_player_1.NoOpAnimationPlayer,
	    AnimationPlayer: animation_player_1.AnimationPlayer,
	    AnimationSequencePlayer: animation_sequence_player_1.AnimationSequencePlayer,
	    AnimationGroupPlayer: animation_group_player_1.AnimationGroupPlayer,
	    AnimationKeyframe: animation_keyframe_1.AnimationKeyframe,
	    prepareFinalAnimationStyles: animationUtils.prepareFinalAnimationStyles,
	    balanceAnimationKeyframes: animationUtils.balanceAnimationKeyframes,
	    flattenStyles: animationUtils.flattenStyles,
	    clearStyles: animationUtils.clearStyles,
	    renderStyles: animationUtils.renderStyles,
	    collectAndResolveStyles: animationUtils.collectAndResolveStyles,
	    AnimationStyles: animation_styles_1.AnimationStyles,
	    ANY_STATE: animation_constants_1.ANY_STATE,
	    DEFAULT_STATE: animation_constants_1.DEFAULT_STATE,
	    EMPTY_STATE: animation_constants_1.EMPTY_STATE,
	    FILL_STYLE_FLAG: animation_constants_1.FILL_STYLE_FLAG
	};
	//# sourceMappingURL=private_export.js.map

/***/ },
/* 205 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var AnimationKeyframe = (function () {
	    function AnimationKeyframe(offset, styles) {
	        this.offset = offset;
	        this.styles = styles;
	    }
	    return AnimationKeyframe;
	}());
	exports.AnimationKeyframe = AnimationKeyframe;
	//# sourceMappingURL=animation_keyframe.js.map

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var animation_player_1 = __webpack_require__(85);
	var AnimationSequencePlayer = (function () {
	    function AnimationSequencePlayer(_players) {
	        var _this = this;
	        this._players = _players;
	        this._currentIndex = 0;
	        this._subscriptions = [];
	        this._finished = false;
	        this._started = false;
	        this.parentPlayer = null;
	        this._players.forEach(function (player) { player.parentPlayer = _this; });
	        this._onNext(false);
	    }
	    AnimationSequencePlayer.prototype._onNext = function (start) {
	        var _this = this;
	        if (this._finished)
	            return;
	        if (this._players.length == 0) {
	            this._activePlayer = new animation_player_1.NoOpAnimationPlayer();
	            lang_1.scheduleMicroTask(function () { return _this._onFinish(); });
	        }
	        else if (this._currentIndex >= this._players.length) {
	            this._activePlayer = new animation_player_1.NoOpAnimationPlayer();
	            this._onFinish();
	        }
	        else {
	            var player = this._players[this._currentIndex++];
	            player.onDone(function () { return _this._onNext(true); });
	            this._activePlayer = player;
	            if (start) {
	                player.play();
	            }
	        }
	    };
	    AnimationSequencePlayer.prototype._onFinish = function () {
	        if (!this._finished) {
	            this._finished = true;
	            if (!lang_1.isPresent(this.parentPlayer)) {
	                this.destroy();
	            }
	            this._subscriptions.forEach(function (subscription) { return subscription(); });
	            this._subscriptions = [];
	        }
	    };
	    AnimationSequencePlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };
	    AnimationSequencePlayer.prototype.onDone = function (fn) { this._subscriptions.push(fn); };
	    AnimationSequencePlayer.prototype.hasStarted = function () { return this._started; };
	    AnimationSequencePlayer.prototype.play = function () {
	        if (!lang_1.isPresent(this.parentPlayer)) {
	            this.init();
	        }
	        this._started = true;
	        this._activePlayer.play();
	    };
	    AnimationSequencePlayer.prototype.pause = function () { this._activePlayer.pause(); };
	    AnimationSequencePlayer.prototype.restart = function () {
	        if (this._players.length > 0) {
	            this.reset();
	            this._players[0].restart();
	        }
	    };
	    AnimationSequencePlayer.prototype.reset = function () { this._players.forEach(function (player) { return player.reset(); }); };
	    AnimationSequencePlayer.prototype.finish = function () {
	        this._onFinish();
	        this._players.forEach(function (player) { return player.finish(); });
	    };
	    AnimationSequencePlayer.prototype.destroy = function () {
	        this._onFinish();
	        this._players.forEach(function (player) { return player.destroy(); });
	    };
	    AnimationSequencePlayer.prototype.setPosition = function (p /** TODO #9100 */) { this._players[0].setPosition(p); };
	    AnimationSequencePlayer.prototype.getPosition = function () { return this._players[0].getPosition(); };
	    return AnimationSequencePlayer;
	}());
	exports.AnimationSequencePlayer = AnimationSequencePlayer;
	//# sourceMappingURL=animation_sequence_player.js.map

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var lang_1 = __webpack_require__(2);
	var animation_constants_1 = __webpack_require__(139);
	var metadata_1 = __webpack_require__(141);
	function prepareFinalAnimationStyles(previousStyles, newStyles, nullValue) {
	    if (nullValue === void 0) { nullValue = null; }
	    var finalStyles = {};
	    collection_1.StringMapWrapper.forEach(newStyles, function (value, prop) {
	        finalStyles[prop] = value == metadata_1.AUTO_STYLE ? nullValue : value.toString();
	    });
	    collection_1.StringMapWrapper.forEach(previousStyles, function (value, prop) {
	        if (!lang_1.isPresent(finalStyles[prop])) {
	            finalStyles[prop] = nullValue;
	        }
	    });
	    return finalStyles;
	}
	exports.prepareFinalAnimationStyles = prepareFinalAnimationStyles;
	function balanceAnimationKeyframes(collectedStyles, finalStateStyles, keyframes) {
	    var limit = keyframes.length - 1;
	    var firstKeyframe = keyframes[0];
	    // phase 1: copy all the styles from the first keyframe into the lookup map
	    var flatenedFirstKeyframeStyles = flattenStyles(firstKeyframe.styles.styles);
	    var extraFirstKeyframeStyles = {};
	    var hasExtraFirstStyles = false;
	    collection_1.StringMapWrapper.forEach(collectedStyles, function (value, prop) {
	        // if the style is already defined in the first keyframe then
	        // we do not replace it.
	        if (!flatenedFirstKeyframeStyles[prop]) {
	            flatenedFirstKeyframeStyles[prop] = value;
	            extraFirstKeyframeStyles[prop] = value;
	            hasExtraFirstStyles = true;
	        }
	    });
	    var keyframeCollectedStyles = collection_1.StringMapWrapper.merge({}, flatenedFirstKeyframeStyles);
	    // phase 2: normalize the final keyframe
	    var finalKeyframe = keyframes[limit];
	    collection_1.ListWrapper.insert(finalKeyframe.styles.styles, 0, finalStateStyles);
	    var flatenedFinalKeyframeStyles = flattenStyles(finalKeyframe.styles.styles);
	    var extraFinalKeyframeStyles = {};
	    var hasExtraFinalStyles = false;
	    collection_1.StringMapWrapper.forEach(keyframeCollectedStyles, function (value, prop) {
	        if (!lang_1.isPresent(flatenedFinalKeyframeStyles[prop])) {
	            extraFinalKeyframeStyles[prop] = metadata_1.AUTO_STYLE;
	            hasExtraFinalStyles = true;
	        }
	    });
	    if (hasExtraFinalStyles) {
	        finalKeyframe.styles.styles.push(extraFinalKeyframeStyles);
	    }
	    collection_1.StringMapWrapper.forEach(flatenedFinalKeyframeStyles, function (value, prop) {
	        if (!lang_1.isPresent(flatenedFirstKeyframeStyles[prop])) {
	            extraFirstKeyframeStyles[prop] = metadata_1.AUTO_STYLE;
	            hasExtraFirstStyles = true;
	        }
	    });
	    if (hasExtraFirstStyles) {
	        firstKeyframe.styles.styles.push(extraFirstKeyframeStyles);
	    }
	    return keyframes;
	}
	exports.balanceAnimationKeyframes = balanceAnimationKeyframes;
	function clearStyles(styles) {
	    var finalStyles = {};
	    collection_1.StringMapWrapper.keys(styles).forEach(function (key) { finalStyles[key] = null; });
	    return finalStyles;
	}
	exports.clearStyles = clearStyles;
	function collectAndResolveStyles(collection, styles) {
	    return styles.map(function (entry) {
	        var stylesObj = {};
	        collection_1.StringMapWrapper.forEach(entry, function (value, prop) {
	            if (value == animation_constants_1.FILL_STYLE_FLAG) {
	                value = collection[prop];
	                if (!lang_1.isPresent(value)) {
	                    value = metadata_1.AUTO_STYLE;
	                }
	            }
	            collection[prop] = value;
	            stylesObj[prop] = value;
	        });
	        return stylesObj;
	    });
	}
	exports.collectAndResolveStyles = collectAndResolveStyles;
	function renderStyles(element, renderer, styles) {
	    collection_1.StringMapWrapper.forEach(styles, function (value, prop) { renderer.setElementStyle(element, prop, value); });
	}
	exports.renderStyles = renderStyles;
	function flattenStyles(styles) {
	    var finalStyles = {};
	    styles.forEach(function (entry) {
	        collection_1.StringMapWrapper.forEach(entry, function (value, prop) { finalStyles[prop] = value; });
	    });
	    return finalStyles;
	}
	exports.flattenStyles = flattenStyles;
	//# sourceMappingURL=animation_style_util.js.map

/***/ },
/* 208 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var AnimationStyles = (function () {
	    function AnimationStyles(styles) {
	        this.styles = styles;
	    }
	    return AnimationStyles;
	}());
	exports.AnimationStyles = AnimationStyles;
	//# sourceMappingURL=animation_styles.js.map

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var lang_1 = __webpack_require__(2);
	var ViewAnimationMap = (function () {
	    function ViewAnimationMap() {
	        this._map = new collection_1.Map();
	        this._allPlayers = [];
	    }
	    Object.defineProperty(ViewAnimationMap.prototype, "length", {
	        get: function () { return this.getAllPlayers().length; },
	        enumerable: true,
	        configurable: true
	    });
	    ViewAnimationMap.prototype.find = function (element, animationName) {
	        var playersByAnimation = this._map.get(element);
	        if (lang_1.isPresent(playersByAnimation)) {
	            return playersByAnimation[animationName];
	        }
	    };
	    ViewAnimationMap.prototype.findAllPlayersByElement = function (element) {
	        var el = this._map.get(element);
	        return el ? collection_1.StringMapWrapper.values(el) : [];
	    };
	    ViewAnimationMap.prototype.set = function (element, animationName, player) {
	        var playersByAnimation = this._map.get(element);
	        if (!lang_1.isPresent(playersByAnimation)) {
	            playersByAnimation = {};
	        }
	        var existingEntry = playersByAnimation[animationName];
	        if (lang_1.isPresent(existingEntry)) {
	            this.remove(element, animationName);
	        }
	        playersByAnimation[animationName] = player;
	        this._allPlayers.push(player);
	        this._map.set(element, playersByAnimation);
	    };
	    ViewAnimationMap.prototype.getAllPlayers = function () { return this._allPlayers; };
	    ViewAnimationMap.prototype.remove = function (element, animationName) {
	        var playersByAnimation = this._map.get(element);
	        if (lang_1.isPresent(playersByAnimation)) {
	            var player = playersByAnimation[animationName];
	            delete playersByAnimation[animationName];
	            var index = this._allPlayers.indexOf(player);
	            collection_1.ListWrapper.removeAt(this._allPlayers, index);
	            if (collection_1.StringMapWrapper.isEmpty(playersByAnimation)) {
	                this._map.delete(element);
	            }
	        }
	    };
	    return ViewAnimationMap;
	}());
	exports.ViewAnimationMap = ViewAnimationMap;
	//# sourceMappingURL=view_animation_map.js.map

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var application_init_1 = __webpack_require__(86);
	var application_ref_1 = __webpack_require__(87);
	var application_tokens_1 = __webpack_require__(47);
	var change_detection_1 = __webpack_require__(48);
	var compiler_1 = __webpack_require__(31);
	var component_resolver_1 = __webpack_require__(94);
	var dynamic_component_loader_1 = __webpack_require__(152);
	var view_utils_1 = __webpack_require__(56);
	var metadata_1 = __webpack_require__(158);
	function _iterableDiffersFactory() {
	    return change_detection_1.defaultIterableDiffers;
	}
	exports._iterableDiffersFactory = _iterableDiffersFactory;
	function _keyValueDiffersFactory() {
	    return change_detection_1.defaultKeyValueDiffers;
	}
	exports._keyValueDiffersFactory = _keyValueDiffersFactory;
	/**
	 * A default set of providers which should be included in any Angular
	 * application, regardless of the platform it runs onto.
	 *
	 * @deprecated Include `ApplicationModule` instead.
	 */
	exports.APPLICATION_COMMON_PROVIDERS = [];
	var ApplicationModule = (function () {
	    function ApplicationModule() {
	    }
	    /** @nocollapse */
	    ApplicationModule.decorators = [
	        { type: metadata_1.NgModule, args: [{
	                    providers: [
	                        application_ref_1.ApplicationRef_,
	                        { provide: application_ref_1.ApplicationRef, useExisting: application_ref_1.ApplicationRef_ },
	                        application_init_1.ApplicationInitStatus,
	                        compiler_1.Compiler,
	                        { provide: component_resolver_1.ComponentResolver, useExisting: compiler_1.Compiler },
	                        application_tokens_1.APP_ID_RANDOM_PROVIDER,
	                        view_utils_1.ViewUtils,
	                        { provide: change_detection_1.IterableDiffers, useFactory: _iterableDiffersFactory },
	                        { provide: change_detection_1.KeyValueDiffers, useFactory: _keyValueDiffersFactory },
	                        { provide: dynamic_component_loader_1.DynamicComponentLoader, useClass: dynamic_component_loader_1.DynamicComponentLoader_ },
	                    ]
	                },] },
	    ];
	    return ApplicationModule;
	}());
	exports.ApplicationModule = ApplicationModule;
	//# sourceMappingURL=application_module.js.map

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * @module
	 * @description
	 * Change detection enables data binding in Angular.
	 */
	var change_detection_1 = __webpack_require__(48);
	exports.ChangeDetectionStrategy = change_detection_1.ChangeDetectionStrategy;
	exports.ChangeDetectorRef = change_detection_1.ChangeDetectorRef;
	exports.CollectionChangeRecord = change_detection_1.CollectionChangeRecord;
	exports.DefaultIterableDiffer = change_detection_1.DefaultIterableDiffer;
	exports.IterableDiffers = change_detection_1.IterableDiffers;
	exports.KeyValueChangeRecord = change_detection_1.KeyValueChangeRecord;
	exports.KeyValueDiffers = change_detection_1.KeyValueDiffers;
	exports.SimpleChange = change_detection_1.SimpleChange;
	exports.WrappedValue = change_detection_1.WrappedValue;
	//# sourceMappingURL=change_detection.js.map

/***/ },
/* 212 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * @stable
	 */
	var ChangeDetectorRef = (function () {
	    function ChangeDetectorRef() {
	    }
	    return ChangeDetectorRef;
	}());
	exports.ChangeDetectorRef = ChangeDetectorRef;
	//# sourceMappingURL=change_detector_ref.js.map

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var debug_node_1 = __webpack_require__(145);
	var DebugDomRootRenderer = (function () {
	    function DebugDomRootRenderer(_delegate) {
	        this._delegate = _delegate;
	    }
	    DebugDomRootRenderer.prototype.renderComponent = function (componentProto) {
	        return new DebugDomRenderer(this._delegate.renderComponent(componentProto));
	    };
	    return DebugDomRootRenderer;
	}());
	exports.DebugDomRootRenderer = DebugDomRootRenderer;
	var DebugDomRenderer = (function () {
	    function DebugDomRenderer(_delegate) {
	        this._delegate = _delegate;
	    }
	    DebugDomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
	        var nativeEl = this._delegate.selectRootElement(selectorOrNode, debugInfo);
	        var debugEl = new debug_node_1.DebugElement(nativeEl, null, debugInfo);
	        debug_node_1.indexDebugNode(debugEl);
	        return nativeEl;
	    };
	    DebugDomRenderer.prototype.createElement = function (parentElement, name, debugInfo) {
	        var nativeEl = this._delegate.createElement(parentElement, name, debugInfo);
	        var debugEl = new debug_node_1.DebugElement(nativeEl, debug_node_1.getDebugNode(parentElement), debugInfo);
	        debugEl.name = name;
	        debug_node_1.indexDebugNode(debugEl);
	        return nativeEl;
	    };
	    DebugDomRenderer.prototype.createViewRoot = function (hostElement) { return this._delegate.createViewRoot(hostElement); };
	    DebugDomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
	        var comment = this._delegate.createTemplateAnchor(parentElement, debugInfo);
	        var debugEl = new debug_node_1.DebugNode(comment, debug_node_1.getDebugNode(parentElement), debugInfo);
	        debug_node_1.indexDebugNode(debugEl);
	        return comment;
	    };
	    DebugDomRenderer.prototype.createText = function (parentElement, value, debugInfo) {
	        var text = this._delegate.createText(parentElement, value, debugInfo);
	        var debugEl = new debug_node_1.DebugNode(text, debug_node_1.getDebugNode(parentElement), debugInfo);
	        debug_node_1.indexDebugNode(debugEl);
	        return text;
	    };
	    DebugDomRenderer.prototype.projectNodes = function (parentElement, nodes) {
	        var debugParent = debug_node_1.getDebugNode(parentElement);
	        if (lang_1.isPresent(debugParent) && debugParent instanceof debug_node_1.DebugElement) {
	            var debugElement_1 = debugParent;
	            nodes.forEach(function (node) { debugElement_1.addChild(debug_node_1.getDebugNode(node)); });
	        }
	        this._delegate.projectNodes(parentElement, nodes);
	    };
	    DebugDomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) {
	        var debugNode = debug_node_1.getDebugNode(node);
	        if (lang_1.isPresent(debugNode)) {
	            var debugParent = debugNode.parent;
	            if (viewRootNodes.length > 0 && lang_1.isPresent(debugParent)) {
	                var debugViewRootNodes = [];
	                viewRootNodes.forEach(function (rootNode) { return debugViewRootNodes.push(debug_node_1.getDebugNode(rootNode)); });
	                debugParent.insertChildrenAfter(debugNode, debugViewRootNodes);
	            }
	        }
	        this._delegate.attachViewAfter(node, viewRootNodes);
	    };
	    DebugDomRenderer.prototype.detachView = function (viewRootNodes) {
	        viewRootNodes.forEach(function (node) {
	            var debugNode = debug_node_1.getDebugNode(node);
	            if (lang_1.isPresent(debugNode) && lang_1.isPresent(debugNode.parent)) {
	                debugNode.parent.removeChild(debugNode);
	            }
	        });
	        this._delegate.detachView(viewRootNodes);
	    };
	    DebugDomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
	        viewAllNodes.forEach(function (node) { debug_node_1.removeDebugNodeFromIndex(debug_node_1.getDebugNode(node)); });
	        this._delegate.destroyView(hostElement, viewAllNodes);
	    };
	    DebugDomRenderer.prototype.listen = function (renderElement, name, callback) {
	        var debugEl = debug_node_1.getDebugNode(renderElement);
	        if (lang_1.isPresent(debugEl)) {
	            debugEl.listeners.push(new debug_node_1.EventListener(name, callback));
	        }
	        return this._delegate.listen(renderElement, name, callback);
	    };
	    DebugDomRenderer.prototype.listenGlobal = function (target, name, callback) {
	        return this._delegate.listenGlobal(target, name, callback);
	    };
	    DebugDomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
	        var debugEl = debug_node_1.getDebugNode(renderElement);
	        if (lang_1.isPresent(debugEl) && debugEl instanceof debug_node_1.DebugElement) {
	            debugEl.properties[propertyName] = propertyValue;
	        }
	        this._delegate.setElementProperty(renderElement, propertyName, propertyValue);
	    };
	    DebugDomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
	        var debugEl = debug_node_1.getDebugNode(renderElement);
	        if (lang_1.isPresent(debugEl) && debugEl instanceof debug_node_1.DebugElement) {
	            debugEl.attributes[attributeName] = attributeValue;
	        }
	        this._delegate.setElementAttribute(renderElement, attributeName, attributeValue);
	    };
	    DebugDomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
	        this._delegate.setBindingDebugInfo(renderElement, propertyName, propertyValue);
	    };
	    DebugDomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
	        var debugEl = debug_node_1.getDebugNode(renderElement);
	        if (lang_1.isPresent(debugEl) && debugEl instanceof debug_node_1.DebugElement) {
	            debugEl.classes[className] = isAdd;
	        }
	        this._delegate.setElementClass(renderElement, className, isAdd);
	    };
	    DebugDomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
	        var debugEl = debug_node_1.getDebugNode(renderElement);
	        if (lang_1.isPresent(debugEl) && debugEl instanceof debug_node_1.DebugElement) {
	            debugEl.styles[styleName] = styleValue;
	        }
	        this._delegate.setElementStyle(renderElement, styleName, styleValue);
	    };
	    DebugDomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
	        this._delegate.invokeElementMethod(renderElement, methodName, args);
	    };
	    DebugDomRenderer.prototype.setText = function (renderNode, text) { this._delegate.setText(renderNode, text); };
	    DebugDomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
	        return this._delegate.animate(element, startingStyles, keyframes, duration, delay, easing);
	    };
	    return DebugDomRenderer;
	}());
	exports.DebugDomRenderer = DebugDomRenderer;
	//# sourceMappingURL=debug_renderer.js.map

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(6);
	var exceptions_1 = __webpack_require__(4);
	var injector_1 = __webpack_require__(53);
	var metadata_1 = __webpack_require__(22);
	var reflective_exceptions_1 = __webpack_require__(90);
	var reflective_key_1 = __webpack_require__(91);
	var reflective_provider_1 = __webpack_require__(92);
	var __unused; // avoid unused import when Type union types are erased
	// Threshold for the dynamic version
	var _MAX_CONSTRUCTION_COUNTER = 10;
	var UNDEFINED = new Object();
	var ReflectiveProtoInjectorInlineStrategy = (function () {
	    function ReflectiveProtoInjectorInlineStrategy(protoEI, providers) {
	        this.provider0 = null;
	        this.provider1 = null;
	        this.provider2 = null;
	        this.provider3 = null;
	        this.provider4 = null;
	        this.provider5 = null;
	        this.provider6 = null;
	        this.provider7 = null;
	        this.provider8 = null;
	        this.provider9 = null;
	        this.keyId0 = null;
	        this.keyId1 = null;
	        this.keyId2 = null;
	        this.keyId3 = null;
	        this.keyId4 = null;
	        this.keyId5 = null;
	        this.keyId6 = null;
	        this.keyId7 = null;
	        this.keyId8 = null;
	        this.keyId9 = null;
	        var length = providers.length;
	        if (length > 0) {
	            this.provider0 = providers[0];
	            this.keyId0 = providers[0].key.id;
	        }
	        if (length > 1) {
	            this.provider1 = providers[1];
	            this.keyId1 = providers[1].key.id;
	        }
	        if (length > 2) {
	            this.provider2 = providers[2];
	            this.keyId2 = providers[2].key.id;
	        }
	        if (length > 3) {
	            this.provider3 = providers[3];
	            this.keyId3 = providers[3].key.id;
	        }
	        if (length > 4) {
	            this.provider4 = providers[4];
	            this.keyId4 = providers[4].key.id;
	        }
	        if (length > 5) {
	            this.provider5 = providers[5];
	            this.keyId5 = providers[5].key.id;
	        }
	        if (length > 6) {
	            this.provider6 = providers[6];
	            this.keyId6 = providers[6].key.id;
	        }
	        if (length > 7) {
	            this.provider7 = providers[7];
	            this.keyId7 = providers[7].key.id;
	        }
	        if (length > 8) {
	            this.provider8 = providers[8];
	            this.keyId8 = providers[8].key.id;
	        }
	        if (length > 9) {
	            this.provider9 = providers[9];
	            this.keyId9 = providers[9].key.id;
	        }
	    }
	    ReflectiveProtoInjectorInlineStrategy.prototype.getProviderAtIndex = function (index) {
	        if (index == 0)
	            return this.provider0;
	        if (index == 1)
	            return this.provider1;
	        if (index == 2)
	            return this.provider2;
	        if (index == 3)
	            return this.provider3;
	        if (index == 4)
	            return this.provider4;
	        if (index == 5)
	            return this.provider5;
	        if (index == 6)
	            return this.provider6;
	        if (index == 7)
	            return this.provider7;
	        if (index == 8)
	            return this.provider8;
	        if (index == 9)
	            return this.provider9;
	        throw new reflective_exceptions_1.OutOfBoundsError(index);
	    };
	    ReflectiveProtoInjectorInlineStrategy.prototype.createInjectorStrategy = function (injector) {
	        return new ReflectiveInjectorInlineStrategy(injector, this);
	    };
	    return ReflectiveProtoInjectorInlineStrategy;
	}());
	exports.ReflectiveProtoInjectorInlineStrategy = ReflectiveProtoInjectorInlineStrategy;
	var ReflectiveProtoInjectorDynamicStrategy = (function () {
	    function ReflectiveProtoInjectorDynamicStrategy(protoInj, providers) {
	        this.providers = providers;
	        var len = providers.length;
	        this.keyIds = collection_1.ListWrapper.createFixedSize(len);
	        for (var i = 0; i < len; i++) {
	            this.keyIds[i] = providers[i].key.id;
	        }
	    }
	    ReflectiveProtoInjectorDynamicStrategy.prototype.getProviderAtIndex = function (index) {
	        if (index < 0 || index >= this.providers.length) {
	            throw new reflective_exceptions_1.OutOfBoundsError(index);
	        }
	        return this.providers[index];
	    };
	    ReflectiveProtoInjectorDynamicStrategy.prototype.createInjectorStrategy = function (ei) {
	        return new ReflectiveInjectorDynamicStrategy(this, ei);
	    };
	    return ReflectiveProtoInjectorDynamicStrategy;
	}());
	exports.ReflectiveProtoInjectorDynamicStrategy = ReflectiveProtoInjectorDynamicStrategy;
	var ReflectiveProtoInjector = (function () {
	    function ReflectiveProtoInjector(providers) {
	        this.numberOfProviders = providers.length;
	        this._strategy = providers.length > _MAX_CONSTRUCTION_COUNTER ?
	            new ReflectiveProtoInjectorDynamicStrategy(this, providers) :
	            new ReflectiveProtoInjectorInlineStrategy(this, providers);
	    }
	    ReflectiveProtoInjector.fromResolvedProviders = function (providers) {
	        return new ReflectiveProtoInjector(providers);
	    };
	    ReflectiveProtoInjector.prototype.getProviderAtIndex = function (index) {
	        return this._strategy.getProviderAtIndex(index);
	    };
	    return ReflectiveProtoInjector;
	}());
	exports.ReflectiveProtoInjector = ReflectiveProtoInjector;
	var ReflectiveInjectorInlineStrategy = (function () {
	    function ReflectiveInjectorInlineStrategy(injector, protoStrategy) {
	        this.injector = injector;
	        this.protoStrategy = protoStrategy;
	        this.obj0 = UNDEFINED;
	        this.obj1 = UNDEFINED;
	        this.obj2 = UNDEFINED;
	        this.obj3 = UNDEFINED;
	        this.obj4 = UNDEFINED;
	        this.obj5 = UNDEFINED;
	        this.obj6 = UNDEFINED;
	        this.obj7 = UNDEFINED;
	        this.obj8 = UNDEFINED;
	        this.obj9 = UNDEFINED;
	    }
	    ReflectiveInjectorInlineStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
	    ReflectiveInjectorInlineStrategy.prototype.instantiateProvider = function (provider) {
	        return this.injector._new(provider);
	    };
	    ReflectiveInjectorInlineStrategy.prototype.getObjByKeyId = function (keyId) {
	        var p = this.protoStrategy;
	        var inj = this.injector;
	        if (p.keyId0 === keyId) {
	            if (this.obj0 === UNDEFINED) {
	                this.obj0 = inj._new(p.provider0);
	            }
	            return this.obj0;
	        }
	        if (p.keyId1 === keyId) {
	            if (this.obj1 === UNDEFINED) {
	                this.obj1 = inj._new(p.provider1);
	            }
	            return this.obj1;
	        }
	        if (p.keyId2 === keyId) {
	            if (this.obj2 === UNDEFINED) {
	                this.obj2 = inj._new(p.provider2);
	            }
	            return this.obj2;
	        }
	        if (p.keyId3 === keyId) {
	            if (this.obj3 === UNDEFINED) {
	                this.obj3 = inj._new(p.provider3);
	            }
	            return this.obj3;
	        }
	        if (p.keyId4 === keyId) {
	            if (this.obj4 === UNDEFINED) {
	                this.obj4 = inj._new(p.provider4);
	            }
	            return this.obj4;
	        }
	        if (p.keyId5 === keyId) {
	            if (this.obj5 === UNDEFINED) {
	                this.obj5 = inj._new(p.provider5);
	            }
	            return this.obj5;
	        }
	        if (p.keyId6 === keyId) {
	            if (this.obj6 === UNDEFINED) {
	                this.obj6 = inj._new(p.provider6);
	            }
	            return this.obj6;
	        }
	        if (p.keyId7 === keyId) {
	            if (this.obj7 === UNDEFINED) {
	                this.obj7 = inj._new(p.provider7);
	            }
	            return this.obj7;
	        }
	        if (p.keyId8 === keyId) {
	            if (this.obj8 === UNDEFINED) {
	                this.obj8 = inj._new(p.provider8);
	            }
	            return this.obj8;
	        }
	        if (p.keyId9 === keyId) {
	            if (this.obj9 === UNDEFINED) {
	                this.obj9 = inj._new(p.provider9);
	            }
	            return this.obj9;
	        }
	        return UNDEFINED;
	    };
	    ReflectiveInjectorInlineStrategy.prototype.getObjAtIndex = function (index) {
	        if (index == 0)
	            return this.obj0;
	        if (index == 1)
	            return this.obj1;
	        if (index == 2)
	            return this.obj2;
	        if (index == 3)
	            return this.obj3;
	        if (index == 4)
	            return this.obj4;
	        if (index == 5)
	            return this.obj5;
	        if (index == 6)
	            return this.obj6;
	        if (index == 7)
	            return this.obj7;
	        if (index == 8)
	            return this.obj8;
	        if (index == 9)
	            return this.obj9;
	        throw new reflective_exceptions_1.OutOfBoundsError(index);
	    };
	    ReflectiveInjectorInlineStrategy.prototype.getMaxNumberOfObjects = function () { return _MAX_CONSTRUCTION_COUNTER; };
	    return ReflectiveInjectorInlineStrategy;
	}());
	exports.ReflectiveInjectorInlineStrategy = ReflectiveInjectorInlineStrategy;
	var ReflectiveInjectorDynamicStrategy = (function () {
	    function ReflectiveInjectorDynamicStrategy(protoStrategy, injector) {
	        this.protoStrategy = protoStrategy;
	        this.injector = injector;
	        this.objs = collection_1.ListWrapper.createFixedSize(protoStrategy.providers.length);
	        collection_1.ListWrapper.fill(this.objs, UNDEFINED);
	    }
	    ReflectiveInjectorDynamicStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
	    ReflectiveInjectorDynamicStrategy.prototype.instantiateProvider = function (provider) {
	        return this.injector._new(provider);
	    };
	    ReflectiveInjectorDynamicStrategy.prototype.getObjByKeyId = function (keyId) {
	        var p = this.protoStrategy;
	        for (var i = 0; i < p.keyIds.length; i++) {
	            if (p.keyIds[i] === keyId) {
	                if (this.objs[i] === UNDEFINED) {
	                    this.objs[i] = this.injector._new(p.providers[i]);
	                }
	                return this.objs[i];
	            }
	        }
	        return UNDEFINED;
	    };
	    ReflectiveInjectorDynamicStrategy.prototype.getObjAtIndex = function (index) {
	        if (index < 0 || index >= this.objs.length) {
	            throw new reflective_exceptions_1.OutOfBoundsError(index);
	        }
	        return this.objs[index];
	    };
	    ReflectiveInjectorDynamicStrategy.prototype.getMaxNumberOfObjects = function () { return this.objs.length; };
	    return ReflectiveInjectorDynamicStrategy;
	}());
	exports.ReflectiveInjectorDynamicStrategy = ReflectiveInjectorDynamicStrategy;
	/**
	 * A ReflectiveDependency injection container used for instantiating objects and resolving
	 * dependencies.
	 *
	 * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
	 * constructor dependencies.
	 *
	 * In typical use, application code asks for the dependencies in the constructor and they are
	 * resolved by the `Injector`.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))
	 *
	 * The following example creates an `Injector` configured to create `Engine` and `Car`.
	 *
	 * ```typescript
	 * @Injectable()
	 * class Engine {
	 * }
	 *
	 * @Injectable()
	 * class Car {
	 *   constructor(public engine:Engine) {}
	 * }
	 *
	 * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	 * var car = injector.get(Car);
	 * expect(car instanceof Car).toBe(true);
	 * expect(car.engine instanceof Engine).toBe(true);
	 * ```
	 *
	 * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
	 * resolve all of the object's dependencies automatically.
	 *
	 * @stable
	 */
	var ReflectiveInjector = (function () {
	    function ReflectiveInjector() {
	    }
	    /**
	     * Turns an array of provider definitions into an array of resolved providers.
	     *
	     * A resolution is a process of flattening multiple nested arrays and converting individual
	     * providers into an array of {@link ResolvedReflectiveProvider}s.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))
	     *
	     * ```typescript
	     * @Injectable()
	     * class Engine {
	     * }
	     *
	     * @Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
	     *
	     * expect(providers.length).toEqual(2);
	     *
	     * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
	     * expect(providers[0].key.displayName).toBe("Car");
	     * expect(providers[0].dependencies.length).toEqual(1);
	     * expect(providers[0].factory).toBeDefined();
	     *
	     * expect(providers[1].key.displayName).toBe("Engine");
	     * });
	     * ```
	     *
	     * See {@link ReflectiveInjector#fromResolvedProviders} for more info.
	     */
	    ReflectiveInjector.resolve = function (providers) {
	        return reflective_provider_1.resolveReflectiveProviders(providers);
	    };
	    /**
	     * Resolves an array of providers and creates an injector from those providers.
	     *
	     * The passed-in providers can be an array of `Type`, {@link Provider},
	     * or a recursive array of more providers.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))
	     *
	     * ```typescript
	     * @Injectable()
	     * class Engine {
	     * }
	     *
	     * @Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	     * expect(injector.get(Car) instanceof Car).toBe(true);
	     * ```
	     *
	     * This function is slower than the corresponding `fromResolvedProviders`
	     * because it needs to resolve the passed-in providers first.
	     * See {@link Injector#resolve} and {@link Injector#fromResolvedProviders}.
	     */
	    ReflectiveInjector.resolveAndCreate = function (providers, parent) {
	        if (parent === void 0) { parent = null; }
	        var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
	        return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
	    };
	    /**
	     * Creates an injector from previously resolved providers.
	     *
	     * This API is the recommended way to construct injectors in performance-sensitive parts.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))
	     *
	     * ```typescript
	     * @Injectable()
	     * class Engine {
	     * }
	     *
	     * @Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var providers = ReflectiveInjector.resolve([Car, Engine]);
	     * var injector = ReflectiveInjector.fromResolvedProviders(providers);
	     * expect(injector.get(Car) instanceof Car).toBe(true);
	     * ```
	     * @experimental
	     */
	    ReflectiveInjector.fromResolvedProviders = function (providers, parent) {
	        if (parent === void 0) { parent = null; }
	        return new ReflectiveInjector_(ReflectiveProtoInjector.fromResolvedProviders(providers), parent);
	    };
	    /**
	     * @deprecated
	     */
	    ReflectiveInjector.fromResolvedBindings = function (providers) {
	        return ReflectiveInjector.fromResolvedProviders(providers);
	    };
	    Object.defineProperty(ReflectiveInjector.prototype, "parent", {
	        /**
	         * Parent of this injector.
	         *
	         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	         * -->
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))
	         *
	         * ```typescript
	         * var parent = ReflectiveInjector.resolveAndCreate([]);
	         * var child = parent.resolveAndCreateChild([]);
	         * expect(child.parent).toBe(parent);
	         * ```
	         */
	        get: function () { return exceptions_1.unimplemented(); },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @internal
	     */
	    ReflectiveInjector.prototype.debugContext = function () { return null; };
	    /**
	     * Resolves an array of providers and creates a child injector from those providers.
	     *
	     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	     * -->
	     *
	     * The passed-in providers can be an array of `Type`, {@link Provider},
	     * or a recursive array of more providers.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))
	     *
	     * ```typescript
	     * class ParentProvider {}
	     * class ChildProvider {}
	     *
	     * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);
	     * var child = parent.resolveAndCreateChild([ChildProvider]);
	     *
	     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
	     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
	     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
	     * ```
	     *
	     * This function is slower than the corresponding `createChildFromResolved`
	     * because it needs to resolve the passed-in providers first.
	     * See {@link Injector#resolve} and {@link Injector#createChildFromResolved}.
	     */
	    ReflectiveInjector.prototype.resolveAndCreateChild = function (providers) {
	        return exceptions_1.unimplemented();
	    };
	    /**
	     * Creates a child injector from previously resolved providers.
	     *
	     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	     * -->
	     *
	     * This API is the recommended way to construct injectors in performance-sensitive parts.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))
	     *
	     * ```typescript
	     * class ParentProvider {}
	     * class ChildProvider {}
	     *
	     * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);
	     * var childProviders = ReflectiveInjector.resolve([ChildProvider]);
	     *
	     * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);
	     * var child = parent.createChildFromResolved(childProviders);
	     *
	     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
	     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
	     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
	     * ```
	     */
	    ReflectiveInjector.prototype.createChildFromResolved = function (providers) {
	        return exceptions_1.unimplemented();
	    };
	    /**
	     * Resolves a provider and instantiates an object in the context of the injector.
	     *
	     * The created object does not get cached by the injector.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))
	     *
	     * ```typescript
	     * @Injectable()
	     * class Engine {
	     * }
	     *
	     * @Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
	     *
	     * var car = injector.resolveAndInstantiate(Car);
	     * expect(car.engine).toBe(injector.get(Engine));
	     * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
	     * ```
	     */
	    ReflectiveInjector.prototype.resolveAndInstantiate = function (provider) { return exceptions_1.unimplemented(); };
	    /**
	     * Instantiates an object using a resolved provider in the context of the injector.
	     *
	     * The created object does not get cached by the injector.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))
	     *
	     * ```typescript
	     * @Injectable()
	     * class Engine {
	     * }
	     *
	     * @Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
	     * var carProvider = ReflectiveInjector.resolve([Car])[0];
	     * var car = injector.instantiateResolved(carProvider);
	     * expect(car.engine).toBe(injector.get(Engine));
	     * expect(car).not.toBe(injector.instantiateResolved(carProvider));
	     * ```
	     */
	    ReflectiveInjector.prototype.instantiateResolved = function (provider) { return exceptions_1.unimplemented(); };
	    return ReflectiveInjector;
	}());
	exports.ReflectiveInjector = ReflectiveInjector;
	var ReflectiveInjector_ = (function () {
	    /**
	     * Private
	     */
	    function ReflectiveInjector_(_proto /* ProtoInjector */, _parent, _debugContext) {
	        if (_parent === void 0) { _parent = null; }
	        if (_debugContext === void 0) { _debugContext = null; }
	        this._debugContext = _debugContext;
	        /** @internal */
	        this._constructionCounter = 0;
	        this._proto = _proto;
	        this._parent = _parent;
	        this._strategy = _proto._strategy.createInjectorStrategy(this);
	    }
	    /**
	     * @internal
	     */
	    ReflectiveInjector_.prototype.debugContext = function () { return this._debugContext(); };
	    ReflectiveInjector_.prototype.get = function (token, notFoundValue) {
	        if (notFoundValue === void 0) { notFoundValue = injector_1.THROW_IF_NOT_FOUND; }
	        return this._getByKey(reflective_key_1.ReflectiveKey.get(token), null, null, notFoundValue);
	    };
	    ReflectiveInjector_.prototype.getAt = function (index) { return this._strategy.getObjAtIndex(index); };
	    Object.defineProperty(ReflectiveInjector_.prototype, "parent", {
	        get: function () { return this._parent; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ReflectiveInjector_.prototype, "internalStrategy", {
	        /**
	         * @internal
	         * Internal. Do not use.
	         * We return `any` not to export the InjectorStrategy type.
	         */
	        get: function () { return this._strategy; },
	        enumerable: true,
	        configurable: true
	    });
	    ReflectiveInjector_.prototype.resolveAndCreateChild = function (providers) {
	        var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
	        return this.createChildFromResolved(ResolvedReflectiveProviders);
	    };
	    ReflectiveInjector_.prototype.createChildFromResolved = function (providers) {
	        var proto = new ReflectiveProtoInjector(providers);
	        var inj = new ReflectiveInjector_(proto);
	        inj._parent = this;
	        return inj;
	    };
	    ReflectiveInjector_.prototype.resolveAndInstantiate = function (provider) {
	        return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
	    };
	    ReflectiveInjector_.prototype.instantiateResolved = function (provider) {
	        return this._instantiateProvider(provider);
	    };
	    /** @internal */
	    ReflectiveInjector_.prototype._new = function (provider) {
	        if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {
	            throw new reflective_exceptions_1.CyclicDependencyError(this, provider.key);
	        }
	        return this._instantiateProvider(provider);
	    };
	    ReflectiveInjector_.prototype._instantiateProvider = function (provider) {
	        if (provider.multiProvider) {
	            var res = collection_1.ListWrapper.createFixedSize(provider.resolvedFactories.length);
	            for (var i = 0; i < provider.resolvedFactories.length; ++i) {
	                res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
	            }
	            return res;
	        }
	        else {
	            return this._instantiate(provider, provider.resolvedFactories[0]);
	        }
	    };
	    ReflectiveInjector_.prototype._instantiate = function (provider, ResolvedReflectiveFactory) {
	        var factory = ResolvedReflectiveFactory.factory;
	        var deps = ResolvedReflectiveFactory.dependencies;
	        var length = deps.length;
	        var d0;
	        var d1;
	        var d2;
	        var d3;
	        var d4;
	        var d5;
	        var d6;
	        var d7;
	        var d8;
	        var d9;
	        var d10;
	        var d11;
	        var d12;
	        var d13;
	        var d14;
	        var d15;
	        var d16;
	        var d17;
	        var d18;
	        var d19;
	        try {
	            d0 = length > 0 ? this._getByReflectiveDependency(provider, deps[0]) : null;
	            d1 = length > 1 ? this._getByReflectiveDependency(provider, deps[1]) : null;
	            d2 = length > 2 ? this._getByReflectiveDependency(provider, deps[2]) : null;
	            d3 = length > 3 ? this._getByReflectiveDependency(provider, deps[3]) : null;
	            d4 = length > 4 ? this._getByReflectiveDependency(provider, deps[4]) : null;
	            d5 = length > 5 ? this._getByReflectiveDependency(provider, deps[5]) : null;
	            d6 = length > 6 ? this._getByReflectiveDependency(provider, deps[6]) : null;
	            d7 = length > 7 ? this._getByReflectiveDependency(provider, deps[7]) : null;
	            d8 = length > 8 ? this._getByReflectiveDependency(provider, deps[8]) : null;
	            d9 = length > 9 ? this._getByReflectiveDependency(provider, deps[9]) : null;
	            d10 = length > 10 ? this._getByReflectiveDependency(provider, deps[10]) : null;
	            d11 = length > 11 ? this._getByReflectiveDependency(provider, deps[11]) : null;
	            d12 = length > 12 ? this._getByReflectiveDependency(provider, deps[12]) : null;
	            d13 = length > 13 ? this._getByReflectiveDependency(provider, deps[13]) : null;
	            d14 = length > 14 ? this._getByReflectiveDependency(provider, deps[14]) : null;
	            d15 = length > 15 ? this._getByReflectiveDependency(provider, deps[15]) : null;
	            d16 = length > 16 ? this._getByReflectiveDependency(provider, deps[16]) : null;
	            d17 = length > 17 ? this._getByReflectiveDependency(provider, deps[17]) : null;
	            d18 = length > 18 ? this._getByReflectiveDependency(provider, deps[18]) : null;
	            d19 = length > 19 ? this._getByReflectiveDependency(provider, deps[19]) : null;
	        }
	        catch (e) {
	            if (e instanceof reflective_exceptions_1.AbstractProviderError || e instanceof reflective_exceptions_1.InstantiationError) {
	                e.addKey(this, provider.key);
	            }
	            throw e;
	        }
	        var obj;
	        try {
	            switch (length) {
	                case 0:
	                    obj = factory();
	                    break;
	                case 1:
	                    obj = factory(d0);
	                    break;
	                case 2:
	                    obj = factory(d0, d1);
	                    break;
	                case 3:
	                    obj = factory(d0, d1, d2);
	                    break;
	                case 4:
	                    obj = factory(d0, d1, d2, d3);
	                    break;
	                case 5:
	                    obj = factory(d0, d1, d2, d3, d4);
	                    break;
	                case 6:
	                    obj = factory(d0, d1, d2, d3, d4, d5);
	                    break;
	                case 7:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6);
	                    break;
	                case 8:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
	                    break;
	                case 9:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
	                    break;
	                case 10:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
	                    break;
	                case 11:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);
	                    break;
	                case 12:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);
	                    break;
	                case 13:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
	                    break;
	                case 14:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
	                    break;
	                case 15:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);
	                    break;
	                case 16:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);
	                    break;
	                case 17:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);
	                    break;
	                case 18:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);
	                    break;
	                case 19:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);
	                    break;
	                case 20:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);
	                    break;
	                default:
	                    throw new exceptions_1.BaseException("Cannot instantiate '" + provider.key.displayName + "' because it has more than 20 dependencies");
	            }
	        }
	        catch (e) {
	            throw new reflective_exceptions_1.InstantiationError(this, e, e.stack, provider.key);
	        }
	        return obj;
	    };
	    ReflectiveInjector_.prototype._getByReflectiveDependency = function (provider, dep) {
	        return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional ? null : injector_1.THROW_IF_NOT_FOUND);
	    };
	    ReflectiveInjector_.prototype._getByKey = function (key, lowerBoundVisibility, upperBoundVisibility, notFoundValue) {
	        if (key === INJECTOR_KEY) {
	            return this;
	        }
	        if (upperBoundVisibility instanceof metadata_1.SelfMetadata) {
	            return this._getByKeySelf(key, notFoundValue);
	        }
	        else {
	            return this._getByKeyDefault(key, notFoundValue, lowerBoundVisibility);
	        }
	    };
	    /** @internal */
	    ReflectiveInjector_.prototype._throwOrNull = function (key, notFoundValue) {
	        if (notFoundValue !== injector_1.THROW_IF_NOT_FOUND) {
	            return notFoundValue;
	        }
	        else {
	            throw new reflective_exceptions_1.NoProviderError(this, key);
	        }
	    };
	    /** @internal */
	    ReflectiveInjector_.prototype._getByKeySelf = function (key, notFoundValue) {
	        var obj = this._strategy.getObjByKeyId(key.id);
	        return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);
	    };
	    /** @internal */
	    ReflectiveInjector_.prototype._getByKeyDefault = function (key, notFoundValue, lowerBoundVisibility) {
	        var inj;
	        if (lowerBoundVisibility instanceof metadata_1.SkipSelfMetadata) {
	            inj = this._parent;
	        }
	        else {
	            inj = this;
	        }
	        while (inj instanceof ReflectiveInjector_) {
	            var inj_ = inj;
	            var obj = inj_._strategy.getObjByKeyId(key.id);
	            if (obj !== UNDEFINED)
	                return obj;
	            inj = inj_._parent;
	        }
	        if (inj !== null) {
	            return inj.get(key.token, notFoundValue);
	        }
	        else {
	            return this._throwOrNull(key, notFoundValue);
	        }
	    };
	    Object.defineProperty(ReflectiveInjector_.prototype, "displayName", {
	        get: function () {
	            var providers = _mapProviders(this, function (b) { return ' "' + b.key.displayName + '" '; })
	                .join(', ');
	            return "ReflectiveInjector(providers: [" + providers + "])";
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ReflectiveInjector_.prototype.toString = function () { return this.displayName; };
	    return ReflectiveInjector_;
	}());
	exports.ReflectiveInjector_ = ReflectiveInjector_;
	var INJECTOR_KEY = reflective_key_1.ReflectiveKey.get(injector_1.Injector);
	function _mapProviders(injector, fn) {
	    var res = new Array(injector._proto.numberOfProviders);
	    for (var i = 0; i < injector._proto.numberOfProviders; ++i) {
	        res[i] = fn(injector._proto.getProviderAtIndex(i));
	    }
	    return res;
	}
	//# sourceMappingURL=reflective_injector.js.map

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	exports.Math = lang_1.global.Math;
	exports.NaN = typeof exports.NaN;
	//# sourceMappingURL=math.js.map

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	// Public API for compiler
	var compiler_1 = __webpack_require__(31);
	exports.COMPILER_OPTIONS = compiler_1.COMPILER_OPTIONS;
	exports.Compiler = compiler_1.Compiler;
	exports.CompilerFactory = compiler_1.CompilerFactory;
	exports.ComponentStillLoadingError = compiler_1.ComponentStillLoadingError;
	exports.ModuleWithComponentFactories = compiler_1.ModuleWithComponentFactories;
	var component_factory_1 = __webpack_require__(150);
	exports.ComponentFactory = component_factory_1.ComponentFactory;
	exports.ComponentRef = component_factory_1.ComponentRef;
	var component_factory_resolver_1 = __webpack_require__(54);
	exports.ComponentFactoryResolver = component_factory_resolver_1.ComponentFactoryResolver;
	exports.NoComponentFactoryError = component_factory_resolver_1.NoComponentFactoryError;
	var component_resolver_1 = __webpack_require__(94);
	exports.ComponentResolver = component_resolver_1.ComponentResolver;
	var dynamic_component_loader_1 = __webpack_require__(152);
	exports.DynamicComponentLoader = dynamic_component_loader_1.DynamicComponentLoader;
	var element_ref_1 = __webpack_require__(153);
	exports.ElementRef = element_ref_1.ElementRef;
	var exceptions_1 = __webpack_require__(96);
	exports.ExpressionChangedAfterItHasBeenCheckedException = exceptions_1.ExpressionChangedAfterItHasBeenCheckedException;
	var ng_module_factory_1 = __webpack_require__(154);
	exports.NgModuleFactory = ng_module_factory_1.NgModuleFactory;
	exports.NgModuleRef = ng_module_factory_1.NgModuleRef;
	var ng_module_factory_loader_1 = __webpack_require__(218);
	exports.NgModuleFactoryLoader = ng_module_factory_loader_1.NgModuleFactoryLoader;
	var query_list_1 = __webpack_require__(219);
	exports.QueryList = query_list_1.QueryList;
	var system_js_ng_module_factory_loader_1 = __webpack_require__(220);
	exports.SystemJsNgModuleLoader = system_js_ng_module_factory_loader_1.SystemJsNgModuleLoader;
	var systemjs_component_resolver_1 = __webpack_require__(221);
	exports.SystemJsCmpFactoryResolver = systemjs_component_resolver_1.SystemJsCmpFactoryResolver;
	exports.SystemJsComponentResolver = systemjs_component_resolver_1.SystemJsComponentResolver;
	var template_ref_1 = __webpack_require__(155);
	exports.TemplateRef = template_ref_1.TemplateRef;
	var view_container_ref_1 = __webpack_require__(156);
	exports.ViewContainerRef = view_container_ref_1.ViewContainerRef;
	var view_ref_1 = __webpack_require__(157);
	exports.EmbeddedViewRef = view_ref_1.EmbeddedViewRef;
	exports.ViewRef = view_ref_1.ViewRef;
	//# sourceMappingURL=linker.js.map

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var injector_1 = __webpack_require__(53);
	var _UNDEFINED = new Object();
	var ElementInjector = (function (_super) {
	    __extends(ElementInjector, _super);
	    function ElementInjector(_view, _nodeIndex) {
	        _super.call(this);
	        this._view = _view;
	        this._nodeIndex = _nodeIndex;
	    }
	    ElementInjector.prototype.get = function (token, notFoundValue) {
	        if (notFoundValue === void 0) { notFoundValue = injector_1.THROW_IF_NOT_FOUND; }
	        var result = _UNDEFINED;
	        if (result === _UNDEFINED) {
	            result = this._view.injectorGet(token, this._nodeIndex, _UNDEFINED);
	        }
	        if (result === _UNDEFINED) {
	            result = this._view.parentInjector.get(token, notFoundValue);
	        }
	        return result;
	    };
	    return ElementInjector;
	}(injector_1.Injector));
	exports.ElementInjector = ElementInjector;
	//# sourceMappingURL=element_injector.js.map

/***/ },
/* 218 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * Used to load ng moduled factories.
	 * @experimental
	 */
	var NgModuleFactoryLoader = (function () {
	    function NgModuleFactoryLoader() {
	    }
	    return NgModuleFactoryLoader;
	}());
	exports.NgModuleFactoryLoader = NgModuleFactoryLoader;
	//# sourceMappingURL=ng_module_factory_loader.js.map

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var async_1 = __webpack_require__(93);
	var collection_1 = __webpack_require__(6);
	var lang_1 = __webpack_require__(2);
	/**
	 * An unmodifiable list of items that Angular keeps up to date when the state
	 * of the application changes.
	 *
	 * The type of object that {@link QueryMetadata} and {@link ViewQueryMetadata} provide.
	 *
	 * Implements an iterable interface, therefore it can be used in both ES6
	 * javascript `for (var i of items)` loops as well as in Angular templates with
	 * `*ngFor="let i of myList"`.
	 *
	 * Changes can be observed by subscribing to the changes `Observable`.
	 *
	 * NOTE: In the future this class will implement an `Observable` interface.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
	 * ```typescript
	 * @Component({...})
	 * class Container {
	 *   @ViewChildren(Item) items:QueryList<Item>;
	 * }
	 * ```
	 * @stable
	 */
	var QueryList = (function () {
	    function QueryList() {
	        this._dirty = true;
	        this._results = [];
	        this._emitter = new async_1.EventEmitter();
	    }
	    Object.defineProperty(QueryList.prototype, "changes", {
	        get: function () { return this._emitter; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryList.prototype, "length", {
	        get: function () { return this._results.length; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryList.prototype, "first", {
	        get: function () { return this._results[0]; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryList.prototype, "last", {
	        get: function () { return this._results[this.length - 1]; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * See
	     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
	     */
	    QueryList.prototype.map = function (fn) { return this._results.map(fn); };
	    /**
	     * See
	     * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
	     */
	    QueryList.prototype.filter = function (fn) {
	        return this._results.filter(fn);
	    };
	    /**
	     * See
	     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
	     */
	    QueryList.prototype.reduce = function (fn, init) {
	        return this._results.reduce(fn, init);
	    };
	    /**
	     * See
	     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
	     */
	    QueryList.prototype.forEach = function (fn) { this._results.forEach(fn); };
	    /**
	     * See
	     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
	     */
	    QueryList.prototype.some = function (fn) {
	        return this._results.some(fn);
	    };
	    QueryList.prototype.toArray = function () { return this._results.slice(); };
	    QueryList.prototype[lang_1.getSymbolIterator()] = function () { return this._results[lang_1.getSymbolIterator()](); };
	    QueryList.prototype.toString = function () { return this._results.toString(); };
	    QueryList.prototype.reset = function (res) {
	        this._results = collection_1.ListWrapper.flatten(res);
	        this._dirty = false;
	    };
	    QueryList.prototype.notifyOnChanges = function () { this._emitter.emit(this); };
	    /** internal */
	    QueryList.prototype.setDirty = function () { this._dirty = true; };
	    Object.defineProperty(QueryList.prototype, "dirty", {
	        /** internal */
	        get: function () { return this._dirty; },
	        enumerable: true,
	        configurable: true
	    });
	    return QueryList;
	}());
	exports.QueryList = QueryList;
	//# sourceMappingURL=query_list.js.map

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var di_1 = __webpack_require__(12);
	var lang_1 = __webpack_require__(2);
	var compiler_1 = __webpack_require__(31);
	var _SEPARATOR = '#';
	var FACTORY_MODULE_SUFFIX = '.ngfactory';
	var FACTORY_CLASS_SUFFIX = 'NgFactory';
	var SystemJsNgModuleLoader = (function () {
	    function SystemJsNgModuleLoader(_compiler) {
	        this._compiler = _compiler;
	    }
	    SystemJsNgModuleLoader.prototype.load = function (path) {
	        var offlineMode = this._compiler instanceof compiler_1.Compiler;
	        return offlineMode ? this.loadFactory(path) : this.loadAndCompile(path);
	    };
	    SystemJsNgModuleLoader.prototype.loadAndCompile = function (path) {
	        var _this = this;
	        var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
	        if (exportName === undefined)
	            exportName = 'default';
	        return lang_1.global
	            .System.import(module)
	            .then(function (module) { return module[exportName]; })
	            .then(function (type) { return checkNotEmpty(type, module, exportName); })
	            .then(function (type) { return _this._compiler.compileModuleAsync(type); });
	    };
	    SystemJsNgModuleLoader.prototype.loadFactory = function (path) {
	        var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
	        if (exportName === undefined)
	            exportName = 'default';
	        return lang_1.global
	            .System.import(module + FACTORY_MODULE_SUFFIX)
	            .then(function (module) { return module[exportName + FACTORY_CLASS_SUFFIX]; })
	            .then(function (factory) { return checkNotEmpty(factory, module, exportName); });
	    };
	    /** @nocollapse */
	    SystemJsNgModuleLoader.decorators = [
	        { type: di_1.Injectable },
	    ];
	    /** @nocollapse */
	    SystemJsNgModuleLoader.ctorParameters = [
	        { type: compiler_1.Compiler, },
	    ];
	    return SystemJsNgModuleLoader;
	}());
	exports.SystemJsNgModuleLoader = SystemJsNgModuleLoader;
	function checkNotEmpty(value, modulePath, exportName) {
	    if (!value) {
	        throw new Error("Cannot find '" + exportName + "' in '" + modulePath + "'");
	    }
	    return value;
	}
	//# sourceMappingURL=system_js_ng_module_factory_loader.js.map

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var console_1 = __webpack_require__(51);
	var di_1 = __webpack_require__(12);
	var lang_1 = __webpack_require__(2);
	var component_resolver_1 = __webpack_require__(94);
	var _SEPARATOR = '#';
	var SystemJsComponentResolver = (function () {
	    function SystemJsComponentResolver(_resolver, _console) {
	        this._resolver = _resolver;
	        this._console = _console;
	    }
	    SystemJsComponentResolver.prototype.resolveComponent = function (componentType) {
	        var _this = this;
	        if (lang_1.isString(componentType)) {
	            this._console.warn(component_resolver_1.ComponentResolver.LazyLoadingDeprecationMsg);
	            var _a = componentType.split(_SEPARATOR), module = _a[0], component_1 = _a[1];
	            if (component_1 === void (0)) {
	                // Use the default export when no component is specified
	                component_1 = 'default';
	            }
	            return lang_1.global
	                .System.import(module)
	                .then(function (module) { return _this._resolver.resolveComponent(module[component_1]); });
	        }
	        return this._resolver.resolveComponent(componentType);
	    };
	    SystemJsComponentResolver.prototype.clearCache = function () { };
	    /** @nocollapse */
	    SystemJsComponentResolver.decorators = [
	        { type: di_1.Injectable },
	    ];
	    /** @nocollapse */
	    SystemJsComponentResolver.ctorParameters = [
	        { type: component_resolver_1.ComponentResolver, },
	        { type: console_1.Console, },
	    ];
	    return SystemJsComponentResolver;
	}());
	exports.SystemJsComponentResolver = SystemJsComponentResolver;
	var FACTORY_MODULE_SUFFIX = '.ngfactory';
	var FACTORY_CLASS_SUFFIX = 'NgFactory';
	var SystemJsCmpFactoryResolver = (function () {
	    function SystemJsCmpFactoryResolver(_console) {
	        this._console = _console;
	    }
	    SystemJsCmpFactoryResolver.prototype.resolveComponent = function (componentType) {
	        if (lang_1.isString(componentType)) {
	            this._console.warn(component_resolver_1.ComponentResolver.LazyLoadingDeprecationMsg);
	            var _a = componentType.split(_SEPARATOR), module = _a[0], factory_1 = _a[1];
	            return lang_1.global
	                .System.import(module + FACTORY_MODULE_SUFFIX)
	                .then(function (module) { return module[factory_1 + FACTORY_CLASS_SUFFIX]; });
	        }
	        return Promise.resolve(null);
	    };
	    SystemJsCmpFactoryResolver.prototype.clearCache = function () { };
	    /** @nocollapse */
	    SystemJsCmpFactoryResolver.decorators = [
	        { type: di_1.Injectable },
	    ];
	    /** @nocollapse */
	    SystemJsCmpFactoryResolver.ctorParameters = [
	        { type: console_1.Console, },
	    ];
	    return SystemJsCmpFactoryResolver;
	}());
	exports.SystemJsCmpFactoryResolver = SystemJsCmpFactoryResolver;
	//# sourceMappingURL=systemjs_component_resolver.js.map

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var animation_group_player_1 = __webpack_require__(140);
	var view_animation_map_1 = __webpack_require__(209);
	var change_detection_1 = __webpack_require__(48);
	var collection_1 = __webpack_require__(6);
	var lang_1 = __webpack_require__(2);
	var profile_1 = __webpack_require__(57);
	var debug_context_1 = __webpack_require__(151);
	var element_1 = __webpack_require__(95);
	var element_injector_1 = __webpack_require__(217);
	var exceptions_1 = __webpack_require__(96);
	var view_ref_1 = __webpack_require__(157);
	var view_type_1 = __webpack_require__(55);
	var view_utils_1 = __webpack_require__(56);
	var _scope_check = profile_1.wtfCreateScope("AppView#check(ascii id)");
	/**
	 * Cost of making objects: http://jsperf.com/instantiate-size-of-object
	 *
	 */
	var AppView = (function () {
	    function AppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode) {
	        this.clazz = clazz;
	        this.componentType = componentType;
	        this.type = type;
	        this.viewUtils = viewUtils;
	        this.parentInjector = parentInjector;
	        this.declarationAppElement = declarationAppElement;
	        this.cdMode = cdMode;
	        this.contentChildren = [];
	        this.viewChildren = [];
	        this.viewContainerElement = null;
	        this.numberOfChecks = 0;
	        this.animationPlayers = new view_animation_map_1.ViewAnimationMap();
	        this.ref = new view_ref_1.ViewRef_(this);
	        if (type === view_type_1.ViewType.COMPONENT || type === view_type_1.ViewType.HOST) {
	            this.renderer = viewUtils.renderComponent(componentType);
	        }
	        else {
	            this.renderer = declarationAppElement.parentView.renderer;
	        }
	    }
	    Object.defineProperty(AppView.prototype, "destroyed", {
	        get: function () { return this.cdMode === change_detection_1.ChangeDetectorStatus.Destroyed; },
	        enumerable: true,
	        configurable: true
	    });
	    AppView.prototype.cancelActiveAnimation = function (element, animationName, removeAllAnimations) {
	        if (removeAllAnimations === void 0) { removeAllAnimations = false; }
	        if (removeAllAnimations) {
	            this.animationPlayers.findAllPlayersByElement(element).forEach(function (player) { return player.destroy(); });
	        }
	        else {
	            var player = this.animationPlayers.find(element, animationName);
	            if (lang_1.isPresent(player)) {
	                player.destroy();
	            }
	        }
	    };
	    AppView.prototype.queueAnimation = function (element, animationName, player) {
	        var _this = this;
	        this.animationPlayers.set(element, animationName, player);
	        player.onDone(function () { _this.animationPlayers.remove(element, animationName); });
	    };
	    AppView.prototype.triggerQueuedAnimations = function () {
	        this.animationPlayers.getAllPlayers().forEach(function (player) {
	            if (!player.hasStarted()) {
	                player.play();
	            }
	        });
	    };
	    AppView.prototype.create = function (context, givenProjectableNodes, rootSelectorOrNode) {
	        this.context = context;
	        var projectableNodes;
	        switch (this.type) {
	            case view_type_1.ViewType.COMPONENT:
	                projectableNodes = view_utils_1.ensureSlotCount(givenProjectableNodes, this.componentType.slotCount);
	                break;
	            case view_type_1.ViewType.EMBEDDED:
	                projectableNodes = this.declarationAppElement.parentView.projectableNodes;
	                break;
	            case view_type_1.ViewType.HOST:
	                // Note: Don't ensure the slot count for the projectableNodes as we store
	                // them only for the contained component view (which will later check the slot count...)
	                projectableNodes = givenProjectableNodes;
	                break;
	        }
	        this._hasExternalHostElement = lang_1.isPresent(rootSelectorOrNode);
	        this.projectableNodes = projectableNodes;
	        return this.createInternal(rootSelectorOrNode);
	    };
	    /**
	     * Overwritten by implementations.
	     * Returns the AppElement for the host element for ViewType.HOST.
	     */
	    AppView.prototype.createInternal = function (rootSelectorOrNode) { return null; };
	    AppView.prototype.init = function (rootNodesOrAppElements, allNodes, disposables, subscriptions) {
	        this.rootNodesOrAppElements = rootNodesOrAppElements;
	        this.allNodes = allNodes;
	        this.disposables = disposables;
	        this.subscriptions = subscriptions;
	        if (this.type === view_type_1.ViewType.COMPONENT) {
	            // Note: the render nodes have been attached to their host element
	            // in the ViewFactory already.
	            this.declarationAppElement.parentView.viewChildren.push(this);
	            this.dirtyParentQueriesInternal();
	        }
	    };
	    AppView.prototype.selectOrCreateHostElement = function (elementName, rootSelectorOrNode, debugInfo) {
	        var hostElement;
	        if (lang_1.isPresent(rootSelectorOrNode)) {
	            hostElement = this.renderer.selectRootElement(rootSelectorOrNode, debugInfo);
	        }
	        else {
	            hostElement = this.renderer.createElement(null, elementName, debugInfo);
	        }
	        return hostElement;
	    };
	    AppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {
	        return this.injectorGetInternal(token, nodeIndex, notFoundResult);
	    };
	    /**
	     * Overwritten by implementations
	     */
	    AppView.prototype.injectorGetInternal = function (token, nodeIndex, notFoundResult) {
	        return notFoundResult;
	    };
	    AppView.prototype.injector = function (nodeIndex) {
	        if (lang_1.isPresent(nodeIndex)) {
	            return new element_injector_1.ElementInjector(this, nodeIndex);
	        }
	        else {
	            return this.parentInjector;
	        }
	    };
	    AppView.prototype.destroy = function () {
	        if (this._hasExternalHostElement) {
	            this.renderer.detachView(this.flatRootNodes);
	        }
	        else if (lang_1.isPresent(this.viewContainerElement)) {
	            this.viewContainerElement.detachView(this.viewContainerElement.nestedViews.indexOf(this));
	        }
	        this._destroyRecurse();
	    };
	    AppView.prototype._destroyRecurse = function () {
	        if (this.cdMode === change_detection_1.ChangeDetectorStatus.Destroyed) {
	            return;
	        }
	        var children = this.contentChildren;
	        for (var i = 0; i < children.length; i++) {
	            children[i]._destroyRecurse();
	        }
	        children = this.viewChildren;
	        for (var i = 0; i < children.length; i++) {
	            children[i]._destroyRecurse();
	        }
	        this.destroyLocal();
	        this.cdMode = change_detection_1.ChangeDetectorStatus.Destroyed;
	    };
	    AppView.prototype.destroyLocal = function () {
	        var _this = this;
	        var hostElement = this.type === view_type_1.ViewType.COMPONENT ? this.declarationAppElement.nativeElement : null;
	        for (var i = 0; i < this.disposables.length; i++) {
	            this.disposables[i]();
	        }
	        for (var i = 0; i < this.subscriptions.length; i++) {
	            this.subscriptions[i].unsubscribe();
	        }
	        this.destroyInternal();
	        this.dirtyParentQueriesInternal();
	        if (this.animationPlayers.length == 0) {
	            this.renderer.destroyView(hostElement, this.allNodes);
	        }
	        else {
	            var player = new animation_group_player_1.AnimationGroupPlayer(this.animationPlayers.getAllPlayers());
	            player.onDone(function () { _this.renderer.destroyView(hostElement, _this.allNodes); });
	        }
	    };
	    /**
	     * Overwritten by implementations
	     */
	    AppView.prototype.destroyInternal = function () { };
	    /**
	     * Overwritten by implementations
	     */
	    AppView.prototype.detachInternal = function () { };
	    AppView.prototype.detach = function () {
	        var _this = this;
	        this.detachInternal();
	        if (this.animationPlayers.length == 0) {
	            this.renderer.detachView(this.flatRootNodes);
	        }
	        else {
	            var player = new animation_group_player_1.AnimationGroupPlayer(this.animationPlayers.getAllPlayers());
	            player.onDone(function () { _this.renderer.detachView(_this.flatRootNodes); });
	        }
	    };
	    Object.defineProperty(AppView.prototype, "changeDetectorRef", {
	        get: function () { return this.ref; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AppView.prototype, "parent", {
	        get: function () {
	            return lang_1.isPresent(this.declarationAppElement) ? this.declarationAppElement.parentView : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AppView.prototype, "flatRootNodes", {
	        get: function () { return view_utils_1.flattenNestedViewRenderNodes(this.rootNodesOrAppElements); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AppView.prototype, "lastRootNode", {
	        get: function () {
	            var lastNode = this.rootNodesOrAppElements.length > 0 ?
	                this.rootNodesOrAppElements[this.rootNodesOrAppElements.length - 1] :
	                null;
	            return _findLastRenderNode(lastNode);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Overwritten by implementations
	     */
	    AppView.prototype.dirtyParentQueriesInternal = function () { };
	    AppView.prototype.detectChanges = function (throwOnChange) {
	        var s = _scope_check(this.clazz);
	        if (this.cdMode === change_detection_1.ChangeDetectorStatus.Checked ||
	            this.cdMode === change_detection_1.ChangeDetectorStatus.Errored)
	            return;
	        if (this.cdMode === change_detection_1.ChangeDetectorStatus.Destroyed) {
	            this.throwDestroyedError('detectChanges');
	        }
	        this.detectChangesInternal(throwOnChange);
	        if (this.cdMode === change_detection_1.ChangeDetectorStatus.CheckOnce)
	            this.cdMode = change_detection_1.ChangeDetectorStatus.Checked;
	        this.numberOfChecks++;
	        profile_1.wtfLeave(s);
	    };
	    /**
	     * Overwritten by implementations
	     */
	    AppView.prototype.detectChangesInternal = function (throwOnChange) {
	        this.detectContentChildrenChanges(throwOnChange);
	        this.detectViewChildrenChanges(throwOnChange);
	    };
	    AppView.prototype.detectContentChildrenChanges = function (throwOnChange) {
	        for (var i = 0; i < this.contentChildren.length; ++i) {
	            var child = this.contentChildren[i];
	            if (child.cdMode === change_detection_1.ChangeDetectorStatus.Detached)
	                continue;
	            child.detectChanges(throwOnChange);
	        }
	    };
	    AppView.prototype.detectViewChildrenChanges = function (throwOnChange) {
	        for (var i = 0; i < this.viewChildren.length; ++i) {
	            var child = this.viewChildren[i];
	            if (child.cdMode === change_detection_1.ChangeDetectorStatus.Detached)
	                continue;
	            child.detectChanges(throwOnChange);
	        }
	    };
	    AppView.prototype.markContentChildAsMoved = function (renderAppElement) { this.dirtyParentQueriesInternal(); };
	    AppView.prototype.addToContentChildren = function (renderAppElement) {
	        renderAppElement.parentView.contentChildren.push(this);
	        this.viewContainerElement = renderAppElement;
	        this.dirtyParentQueriesInternal();
	    };
	    AppView.prototype.removeFromContentChildren = function (renderAppElement) {
	        collection_1.ListWrapper.remove(renderAppElement.parentView.contentChildren, this);
	        this.dirtyParentQueriesInternal();
	        this.viewContainerElement = null;
	    };
	    AppView.prototype.markAsCheckOnce = function () { this.cdMode = change_detection_1.ChangeDetectorStatus.CheckOnce; };
	    AppView.prototype.markPathToRootAsCheckOnce = function () {
	        var c = this;
	        while (lang_1.isPresent(c) && c.cdMode !== change_detection_1.ChangeDetectorStatus.Detached) {
	            if (c.cdMode === change_detection_1.ChangeDetectorStatus.Checked) {
	                c.cdMode = change_detection_1.ChangeDetectorStatus.CheckOnce;
	            }
	            var parentEl = c.type === view_type_1.ViewType.COMPONENT ? c.declarationAppElement : c.viewContainerElement;
	            c = lang_1.isPresent(parentEl) ? parentEl.parentView : null;
	        }
	    };
	    AppView.prototype.eventHandler = function (cb) { return cb; };
	    AppView.prototype.throwDestroyedError = function (details) { throw new exceptions_1.ViewDestroyedException(details); };
	    return AppView;
	}());
	exports.AppView = AppView;
	var DebugAppView = (function (_super) {
	    __extends(DebugAppView, _super);
	    function DebugAppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode, staticNodeDebugInfos) {
	        _super.call(this, clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode);
	        this.staticNodeDebugInfos = staticNodeDebugInfos;
	        this._currentDebugContext = null;
	    }
	    DebugAppView.prototype.create = function (context, givenProjectableNodes, rootSelectorOrNode) {
	        this._resetDebug();
	        try {
	            return _super.prototype.create.call(this, context, givenProjectableNodes, rootSelectorOrNode);
	        }
	        catch (e) {
	            this._rethrowWithContext(e, e.stack);
	            throw e;
	        }
	    };
	    DebugAppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {
	        this._resetDebug();
	        try {
	            return _super.prototype.injectorGet.call(this, token, nodeIndex, notFoundResult);
	        }
	        catch (e) {
	            this._rethrowWithContext(e, e.stack);
	            throw e;
	        }
	    };
	    DebugAppView.prototype.detach = function () {
	        this._resetDebug();
	        try {
	            _super.prototype.detach.call(this);
	        }
	        catch (e) {
	            this._rethrowWithContext(e, e.stack);
	            throw e;
	        }
	    };
	    DebugAppView.prototype.destroyLocal = function () {
	        this._resetDebug();
	        try {
	            _super.prototype.destroyLocal.call(this);
	        }
	        catch (e) {
	            this._rethrowWithContext(e, e.stack);
	            throw e;
	        }
	    };
	    DebugAppView.prototype.detectChanges = function (throwOnChange) {
	        this._resetDebug();
	        try {
	            _super.prototype.detectChanges.call(this, throwOnChange);
	        }
	        catch (e) {
	            this._rethrowWithContext(e, e.stack);
	            throw e;
	        }
	    };
	    DebugAppView.prototype._resetDebug = function () { this._currentDebugContext = null; };
	    DebugAppView.prototype.debug = function (nodeIndex, rowNum, colNum) {
	        return this._currentDebugContext = new debug_context_1.DebugContext(this, nodeIndex, rowNum, colNum);
	    };
	    DebugAppView.prototype._rethrowWithContext = function (e, stack) {
	        if (!(e instanceof exceptions_1.ViewWrappedException)) {
	            if (!(e instanceof exceptions_1.ExpressionChangedAfterItHasBeenCheckedException)) {
	                this.cdMode = change_detection_1.ChangeDetectorStatus.Errored;
	            }
	            if (lang_1.isPresent(this._currentDebugContext)) {
	                throw new exceptions_1.ViewWrappedException(e, stack, this._currentDebugContext);
	            }
	        }
	    };
	    DebugAppView.prototype.eventHandler = function (cb) {
	        var _this = this;
	        var superHandler = _super.prototype.eventHandler.call(this, cb);
	        return function (event) {
	            _this._resetDebug();
	            try {
	                return superHandler(event);
	            }
	            catch (e) {
	                _this._rethrowWithContext(e, e.stack);
	                throw e;
	            }
	        };
	    };
	    return DebugAppView;
	}(AppView));
	exports.DebugAppView = DebugAppView;
	function _findLastRenderNode(node) {
	    var lastNode;
	    if (node instanceof element_1.AppElement) {
	        var appEl = node;
	        lastNode = appEl.nativeElement;
	        if (lang_1.isPresent(appEl.nestedViews)) {
	            // Note: Views might have no root nodes at all!
	            for (var i = appEl.nestedViews.length - 1; i >= 0; i--) {
	                var nestedView = appEl.nestedViews[i];
	                if (nestedView.rootNodesOrAppElements.length > 0) {
	                    lastNode = _findLastRenderNode(nestedView.rootNodesOrAppElements[nestedView.rootNodesOrAppElements.length - 1]);
	                }
	            }
	        }
	    }
	    else {
	        lastNode = node;
	    }
	    return lastNode;
	}
	//# sourceMappingURL=view.js.map

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var application_ref_1 = __webpack_require__(87);
	var console_1 = __webpack_require__(51);
	var reflection_1 = __webpack_require__(97);
	var reflector_reader_1 = __webpack_require__(98);
	var testability_1 = __webpack_require__(100);
	function _reflector() {
	    return reflection_1.reflector;
	}
	var _CORE_PLATFORM_PROVIDERS = [
	    application_ref_1.PlatformRef_, { provide: application_ref_1.PlatformRef, useExisting: application_ref_1.PlatformRef_ },
	    { provide: reflection_1.Reflector, useFactory: _reflector, deps: [] },
	    { provide: reflector_reader_1.ReflectorReader, useExisting: reflection_1.Reflector }, testability_1.TestabilityRegistry, console_1.Console
	];
	/**
	 * This platform has to be included in any other platform
	 *
	 * @experimental
	 */
	exports.platformCore = application_ref_1.createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);
	/**
	 * A default set of providers which should be included in any Angular platform.
	 *
	 * @deprecated Create platforms via `createPlatformFactory(corePlatform, ...) instead!
	 */
	exports.PLATFORM_COMMON_PROVIDERS = _CORE_PLATFORM_PROVIDERS;
	//# sourceMappingURL=platform_core_providers.js.map

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var di_1 = __webpack_require__(12);
	/**
	  * A token that can be provided when bootstrapping an application to make an array of directives
	  * available in every component of the application.
	  *
	  * ### Example
	  *
	  * ```typescript
	  * import {PLATFORM_DIRECTIVES} from '@angular/core';
	  * import {OtherDirective} from './myDirectives';
	  *
	  * @Component({
	  *   selector: 'my-component',
	  *   template: `
	  *     <!-- can use other directive even though the component does not list it in `directives` -->
	  *     <other-directive></other-directive>
	  *   `
	  * })
	  * export class MyComponent {
	  *   ...
	  * }
	  *
	  * bootstrap(MyComponent, [{provide: PLATFORM_DIRECTIVES, useValue: [OtherDirective],
	  multi:true}]);
	  * ```
	  *
	  * @deprecated Providing platform directives via a provider is deprecated. Provide platform
	  * directives via an {@link NgModule} instead.
	  */
	exports.PLATFORM_DIRECTIVES = new di_1.OpaqueToken('Platform Directives');
	/**
	  * A token that can be provided when bootstraping an application to make an array of pipes
	  * available in every component of the application.
	  *
	  * ### Example
	  *
	  * ```typescript
	  * import {PLATFORM_PIPES} from '@angular/core';
	  * import {OtherPipe} from './myPipe';
	  *
	  * @Component({
	  *   selector: 'my-component',
	  *   template: `
	  *     {{123 | other-pipe}}
	  *   `
	  * })
	  * export class MyComponent {
	  *   ...
	  * }
	  *
	  * bootstrap(MyComponent, [{provide: PLATFORM_PIPES, useValue: [OtherPipe], multi:true}]);
	  * ```
	  *
	  * @deprecated Providing platform pipes via a provider is deprecated. Provide platform pipes via an
	  * {@link NgModule} instead.
	  */
	exports.PLATFORM_PIPES = new di_1.OpaqueToken('Platform Pipes');
	//# sourceMappingURL=platform_directives_and_pipes.js.map

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(2);
	var trace;
	var events;
	function detectWTF() {
	    var wtf = lang_1.global['wtf'];
	    if (wtf) {
	        trace = wtf['trace'];
	        if (trace) {
	            events = trace['events'];
	            return true;
	        }
	    }
	    return false;
	}
	exports.detectWTF = detectWTF;
	function createScope(signature, flags) {
	    if (flags === void 0) { flags = null; }
	    return events.createScope(signature, flags);
	}
	exports.createScope = createScope;
	function leave(scope, returnValue) {
	    trace.leaveScope(scope, returnValue);
	    return returnValue;
	}
	exports.leave = leave;
	function startTimeRange(rangeType, action) {
	    return trace.beginTimeRange(rangeType, action);
	}
	exports.startTimeRange = startTimeRange;
	function endTimeRange(range) {
	    trace.endTimeRange(range);
	}
	exports.endTimeRange = endTimeRange;
	//# sourceMappingURL=wtf_impl.js.map

/***/ },
/* 226 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * This is here because DART requires it. It is noop in JS.
	 */
	function wtfInit() { }
	exports.wtfInit = wtfInit;
	//# sourceMappingURL=wtf_init.js.map

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	// Public API for render
	var api_1 = __webpack_require__(99);
	exports.RenderComponentType = api_1.RenderComponentType;
	exports.Renderer = api_1.Renderer;
	exports.RootRenderer = api_1.RootRenderer;
	//# sourceMappingURL=render.js.map

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	// Public API for util
	var decorators_1 = __webpack_require__(58);
	exports.Class = decorators_1.Class;
	//# sourceMappingURL=util.js.map

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	// Public API for Zone
	var ng_zone_1 = __webpack_require__(101);
	exports.NgZone = ng_zone_1.NgZone;
	exports.NgZoneError = ng_zone_1.NgZoneError;
	//# sourceMappingURL=zone.js.map

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * @module
	 * @description
	 * The http module provides services to perform http requests. To get started, see the {@link Http}
	 * class.
	 */
	var core_1 = __webpack_require__(1);
	var browser_jsonp_1 = __webpack_require__(168);
	var browser_xhr_1 = __webpack_require__(102);
	var jsonp_backend_1 = __webpack_require__(169);
	var xhr_backend_1 = __webpack_require__(170);
	var base_request_options_1 = __webpack_require__(103);
	var base_response_options_1 = __webpack_require__(59);
	var http_1 = __webpack_require__(174);
	var interfaces_1 = __webpack_require__(33);
	var browser_xhr_2 = __webpack_require__(102);
	exports.BrowserXhr = browser_xhr_2.BrowserXhr;
	var jsonp_backend_2 = __webpack_require__(169);
	exports.JSONPBackend = jsonp_backend_2.JSONPBackend;
	exports.JSONPConnection = jsonp_backend_2.JSONPConnection;
	var xhr_backend_2 = __webpack_require__(170);
	exports.CookieXSRFStrategy = xhr_backend_2.CookieXSRFStrategy;
	exports.XHRBackend = xhr_backend_2.XHRBackend;
	exports.XHRConnection = xhr_backend_2.XHRConnection;
	var base_request_options_2 = __webpack_require__(103);
	exports.BaseRequestOptions = base_request_options_2.BaseRequestOptions;
	exports.RequestOptions = base_request_options_2.RequestOptions;
	var base_response_options_2 = __webpack_require__(59);
	exports.BaseResponseOptions = base_response_options_2.BaseResponseOptions;
	exports.ResponseOptions = base_response_options_2.ResponseOptions;
	var enums_1 = __webpack_require__(18);
	exports.ReadyState = enums_1.ReadyState;
	exports.RequestMethod = enums_1.RequestMethod;
	exports.ResponseContentType = enums_1.ResponseContentType;
	exports.ResponseType = enums_1.ResponseType;
	var headers_1 = __webpack_require__(32);
	exports.Headers = headers_1.Headers;
	var http_2 = __webpack_require__(174);
	exports.Http = http_2.Http;
	exports.Jsonp = http_2.Jsonp;
	var interfaces_2 = __webpack_require__(33);
	exports.Connection = interfaces_2.Connection;
	exports.ConnectionBackend = interfaces_2.ConnectionBackend;
	exports.XSRFStrategy = interfaces_2.XSRFStrategy;
	var static_request_1 = __webpack_require__(175);
	exports.Request = static_request_1.Request;
	var static_response_1 = __webpack_require__(105);
	exports.Response = static_response_1.Response;
	var url_search_params_1 = __webpack_require__(62);
	exports.QueryEncoder = url_search_params_1.QueryEncoder;
	exports.URLSearchParams = url_search_params_1.URLSearchParams;
	/**
	 * Provides a basic set of injectables to use the {@link Http} service in any application.
	 *
	 * The `HTTP_PROVIDERS` should be included either in a component's injector,
	 * or in the root injector when bootstrapping an application.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/snj7Nv?p=preview))
	 *
	 * ```
	 * import {Component} from '@angular/core';
	 * import {bootstrap} from '@angular/platform-browser/browser';
	 * import {NgFor} from '@angular/common';
	 * import {HTTP_PROVIDERS, Http} from '@angular/http';
	 *
	 * @Component({
	 *   selector: 'app',
	 *   providers: [HTTP_PROVIDERS],
	 *   template: `
	 *     <div>
	 *       <h1>People</h1>
	 *       <ul>
	 *         <li *ngFor="let person of people">
	 *           {{person.name}}
	 *         </li>
	 *       </ul>
	 *     </div>
	 *   `,
	 *   directives: [NgFor]
	 * })
	 * export class App {
	 *   people: Object[];
	 *   constructor(http:Http) {
	 *     http.get('people.json').subscribe(res => {
	 *       this.people = res.json();
	 *     });
	 *   }
	 *   active:boolean = false;
	 *   toggleActiveState() {
	 *     this.active = !this.active;
	 *   }
	 * }
	 *
	 * bootstrap(App)
	 *   .catch(err => console.error(err));
	 * ```
	 *
	 * The primary public API included in `HTTP_PROVIDERS` is the {@link Http} class.
	 * However, other providers required by `Http` are included,
	 * which may be beneficial to override in certain cases.
	 *
	 * The providers included in `HTTP_PROVIDERS` include:
	 *  * {@link Http}
	 *  * {@link XHRBackend}
	 *  * {@link XSRFStrategy} - Bound to {@link CookieXSRFStrategy} class (see below)
	 *  * `BrowserXHR` - Private factory to create `XMLHttpRequest` instances
	 *  * {@link RequestOptions} - Bound to {@link BaseRequestOptions} class
	 *  * {@link ResponseOptions} - Bound to {@link BaseResponseOptions} class
	 *
	 * There may be cases where it makes sense to extend the base request options,
	 * such as to add a search string to be appended to all URLs.
	 * To accomplish this, a new provider for {@link RequestOptions} should
	 * be added in the same injector as `HTTP_PROVIDERS`.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/aCMEXi?p=preview))
	 *
	 * ```
	 * import {provide} from '@angular/core';
	 * import {bootstrap} from '@angular/platform-browser/browser';
	 * import {HTTP_PROVIDERS, BaseRequestOptions, RequestOptions} from '@angular/http';
	 *
	 * class MyOptions extends BaseRequestOptions {
	 *   search: string = 'coreTeam=true';
	 * }
	 *
	 * bootstrap(App, [HTTP_PROVIDERS, {provide: RequestOptions, useClass: MyOptions}])
	 *   .catch(err => console.error(err));
	 * ```
	 *
	 * Likewise, to use a mock backend for unit tests, the {@link XHRBackend}
	 * provider should be bound to {@link MockBackend}.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/7LWALD?p=preview))
	 *
	 * ```
	 * import {provide} from '@angular/core';
	 * import {bootstrap} from '@angular/platform-browser/browser';
	 * import {HTTP_PROVIDERS, Http, Response, XHRBackend} from '@angular/http';
	 * import {MockBackend} from '@angular/http/testing';
	 *
	 * var people = [{name: 'Jeff'}, {name: 'Tobias'}];
	 *
	 * var injector = Injector.resolveAndCreate([
	 *   HTTP_PROVIDERS,
	 *   MockBackend,
	 *   {provide: XHRBackend, useExisting: MockBackend}
	 * ]);
	 * var http = injector.get(Http);
	 * var backend = injector.get(MockBackend);
	 *
	 * // Listen for any new requests
	 * backend.connections.observer({
	 *   next: connection => {
	 *     var response = new Response({body: people});
	 *     setTimeout(() => {
	 *       // Send a response to the request
	 *       connection.mockRespond(response);
	 *     });
	 *   }
	 * });
	 *
	 * http.get('people.json').observer({
	 *   next: res => {
	 *     // Response came from mock backend
	 *     console.log('first person', res.json()[0].name);
	 *   }
	 * });
	 * ```
	 *
	 * `XSRFStrategy` allows customizing how the application protects itself against Cross Site Request
	 * Forgery (XSRF) attacks. By default, Angular will look for a cookie called `'XSRF-TOKEN'`, and set
	 * an HTTP request header called `'X-XSRF-TOKEN'` with the value of the cookie on each request,
	 * allowing the server side to validate that the request comes from its own front end.
	 *
	 * Applications can override the names used by configuring a different `XSRFStrategy` instance. Most
	 * commonly, applications will configure a `CookieXSRFStrategy` with different cookie or header
	 * names, but if needed, they can supply a completely custom implementation.
	 *
	 * See the security documentation for more information.
	 *
	 * ### Example
	 *
	 * ```
	 * import {provide} from '@angular/core';
	 * import {bootstrap} from '@angular/platform-browser/browser';
	 * import {HTTP_PROVIDERS, XSRFStrategy, CookieXSRFStrategy} from '@angular/http';
	 *
	 * bootstrap(
	 *     App,
	 *     [HTTP_PROVIDERS, {provide: XSRFStrategy,
	 *         useValue: new CookieXSRFStrategy('MY-XSRF-COOKIE-NAME', 'X-MY-XSRF-HEADER-NAME')}])
	 *   .catch(err => console.error(err));
	 * ```
	 *
	 * @deprecated
	 */
	exports.HTTP_PROVIDERS = [
	    // TODO(pascal): use factory type annotations once supported in DI
	    // issue: https://github.com/angular/angular/issues/3183
	    { provide: http_1.Http, useFactory: httpFactory, deps: [xhr_backend_1.XHRBackend, base_request_options_1.RequestOptions] },
	    browser_xhr_1.BrowserXhr,
	    { provide: base_request_options_1.RequestOptions, useClass: base_request_options_1.BaseRequestOptions },
	    { provide: base_response_options_1.ResponseOptions, useClass: base_response_options_1.BaseResponseOptions },
	    xhr_backend_1.XHRBackend,
	    { provide: interfaces_1.XSRFStrategy, useFactory: _createDefaultCookieXSRFStrategy },
	];
	/**
	 * @experimental
	 */
	function _createDefaultCookieXSRFStrategy() {
	    return new xhr_backend_1.CookieXSRFStrategy();
	}
	exports._createDefaultCookieXSRFStrategy = _createDefaultCookieXSRFStrategy;
	/**
	 * @experimental
	 */
	function httpFactory(xhrBackend, requestOptions) {
	    return new http_1.Http(xhrBackend, requestOptions);
	}
	exports.httpFactory = httpFactory;
	/**
	 * See {@link HTTP_PROVIDERS} instead.
	 *
	 * @deprecated
	 */
	exports.HTTP_BINDINGS = exports.HTTP_PROVIDERS;
	/**
	 * Provides a basic set of providers to use the {@link Jsonp} service in any application.
	 *
	 * The `JSONP_PROVIDERS` should be included either in a component's injector,
	 * or in the root injector when bootstrapping an application.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/vmeN4F?p=preview))
	 *
	 * ```
	 * import {Component} from '@angular/core';
	 * import {NgFor} from '@angular/common';
	 * import {JSONP_PROVIDERS, Jsonp} from '@angular/http';
	 *
	 * @Component({
	 *   selector: 'app',
	 *   providers: [JSONP_PROVIDERS],
	 *   template: `
	 *     <div>
	 *       <h1>People</h1>
	 *       <ul>
	 *         <li *ngFor="let person of people">
	 *           {{person.name}}
	 *         </li>
	 *       </ul>
	 *     </div>
	 *   `,
	 *   directives: [NgFor]
	 * })
	 * export class App {
	 *   people: Array<Object>;
	 *   constructor(jsonp:Jsonp) {
	 *     jsonp.request('people.json').subscribe(res => {
	 *       this.people = res.json();
	 *     })
	 *   }
	 * }
	 * ```
	 *
	 * The primary public API included in `JSONP_PROVIDERS` is the {@link Jsonp} class.
	 * However, other providers required by `Jsonp` are included,
	 * which may be beneficial to override in certain cases.
	 *
	 * The providers included in `JSONP_PROVIDERS` include:
	 *  * {@link Jsonp}
	 *  * {@link JSONPBackend}
	 *  * `BrowserJsonp` - Private factory
	 *  * {@link RequestOptions} - Bound to {@link BaseRequestOptions} class
	 *  * {@link ResponseOptions} - Bound to {@link BaseResponseOptions} class
	 *
	 * There may be cases where it makes sense to extend the base request options,
	 * such as to add a search string to be appended to all URLs.
	 * To accomplish this, a new provider for {@link RequestOptions} should
	 * be added in the same injector as `JSONP_PROVIDERS`.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/TFug7x?p=preview))
	 *
	 * ```
	 * import {provide} from '@angular/core';
	 * import {bootstrap} from '@angular/platform-browser/browser';
	 * import {JSONP_PROVIDERS, BaseRequestOptions, RequestOptions} from '@angular/http';
	 *
	 * class MyOptions extends BaseRequestOptions {
	 *   search: string = 'coreTeam=true';
	 * }
	 *
	 * bootstrap(App, [JSONP_PROVIDERS, {provide: RequestOptions, useClass: MyOptions}])
	 *   .catch(err => console.error(err));
	 * ```
	 *
	 * Likewise, to use a mock backend for unit tests, the {@link JSONPBackend}
	 * provider should be bound to {@link MockBackend}.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/HDqZWL?p=preview))
	 *
	 * ```
	 * import {provide, Injector} from '@angular/core';
	 * import {JSONP_PROVIDERS, Jsonp, Response, JSONPBackend} from '@angular/http';
	 * import {MockBackend} from '@angular/http/testing';
	 *
	 * var people = [{name: 'Jeff'}, {name: 'Tobias'}];
	 * var injector = Injector.resolveAndCreate([
	 *   JSONP_PROVIDERS,
	 *   MockBackend,
	 *   {provide: JSONPBackend, useExisting: MockBackend}
	 * ]);
	 * var jsonp = injector.get(Jsonp);
	 * var backend = injector.get(MockBackend);
	 *
	 * // Listen for any new requests
	 * backend.connections.observer({
	 *   next: connection => {
	 *     var response = new Response({body: people});
	 *     setTimeout(() => {
	 *       // Send a response to the request
	 *       connection.mockRespond(response);
	 *     });
	 *   }
	 * });

	 * jsonp.get('people.json').observer({
	 *   next: res => {
	 *     // Response came from mock backend
	 *     console.log('first person', res.json()[0].name);
	 *   }
	 * });
	 * ```
	 *
	 * @experimental
	 */
	exports.JSONP_PROVIDERS = [
	    // TODO(pascal): use factory type annotations once supported in DI
	    // issue: https://github.com/angular/angular/issues/3183
	    { provide: http_1.Jsonp, useFactory: jsonpFactory, deps: [jsonp_backend_1.JSONPBackend, base_request_options_1.RequestOptions] },
	    browser_jsonp_1.BrowserJsonp,
	    { provide: base_request_options_1.RequestOptions, useClass: base_request_options_1.BaseRequestOptions },
	    { provide: base_response_options_1.ResponseOptions, useClass: base_response_options_1.BaseResponseOptions },
	    { provide: jsonp_backend_1.JSONPBackend, useClass: jsonp_backend_1.JSONPBackend_ },
	];
	function jsonpFactory(jsonpBackend, requestOptions) {
	    return new http_1.Jsonp(jsonpBackend, requestOptions);
	}
	/**
	 * See {@link JSONP_PROVIDERS} instead.
	 *
	 * @deprecated
	 */
	exports.JSON_BINDINGS = exports.JSONP_PROVIDERS;
	var HttpModule = (function () {
	    function HttpModule() {
	    }
	    /** @nocollapse */
	    HttpModule.decorators = [
	        { type: core_1.NgModule, args: [{ providers: exports.HTTP_PROVIDERS },] },
	    ];
	    return HttpModule;
	}());
	exports.HttpModule = HttpModule;
	var JsonpModule = (function () {
	    function JsonpModule() {
	    }
	    /** @nocollapse */
	    JsonpModule.decorators = [
	        { type: core_1.NgModule, args: [{ providers: exports.JSONP_PROVIDERS },] },
	    ];
	    return JsonpModule;
	}());
	exports.JsonpModule = JsonpModule;
	//# sourceMappingURL=http.js.map

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(230));
	//# sourceMappingURL=index.js.map

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var browser_1 = __webpack_require__(63);
	exports.BROWSER_APP_PROVIDERS = browser_1.BROWSER_APP_PROVIDERS;
	exports.BROWSER_PLATFORM_PROVIDERS = browser_1.BROWSER_PLATFORM_PROVIDERS;
	exports.BROWSER_SANITIZATION_PROVIDERS = browser_1.BROWSER_SANITIZATION_PROVIDERS;
	exports.BrowserModule = browser_1.BrowserModule;
	exports.browserPlatform = browser_1.browserPlatform;
	exports.platformBrowser = browser_1.platformBrowser;
	var browser_platform_location_1 = __webpack_require__(64);
	exports.BrowserPlatformLocation = browser_platform_location_1.BrowserPlatformLocation;
	var title_1 = __webpack_require__(236);
	exports.Title = title_1.Title;
	var tools_1 = __webpack_require__(238);
	exports.disableDebugTools = tools_1.disableDebugTools;
	exports.enableDebugTools = tools_1.enableDebugTools;
	var animation_driver_1 = __webpack_require__(65);
	exports.AnimationDriver = animation_driver_1.AnimationDriver;
	var by_1 = __webpack_require__(239);
	exports.By = by_1.By;
	var dom_tokens_1 = __webpack_require__(35);
	exports.DOCUMENT = dom_tokens_1.DOCUMENT;
	var event_manager_1 = __webpack_require__(23);
	exports.EVENT_MANAGER_PLUGINS = event_manager_1.EVENT_MANAGER_PLUGINS;
	exports.EventManager = event_manager_1.EventManager;
	var hammer_gestures_1 = __webpack_require__(107);
	exports.HAMMER_GESTURE_CONFIG = hammer_gestures_1.HAMMER_GESTURE_CONFIG;
	exports.HammerGestureConfig = hammer_gestures_1.HammerGestureConfig;
	var dom_sanitization_service_1 = __webpack_require__(183);
	exports.DomSanitizationService = dom_sanitization_service_1.DomSanitizationService;
	// Web Workers
	var client_message_broker_1 = __webpack_require__(36);
	exports.ClientMessageBroker = client_message_broker_1.ClientMessageBroker;
	exports.ClientMessageBrokerFactory = client_message_broker_1.ClientMessageBrokerFactory;
	exports.FnArg = client_message_broker_1.FnArg;
	exports.UiArguments = client_message_broker_1.UiArguments;
	var serializer_1 = __webpack_require__(14);
	exports.PRIMITIVE = serializer_1.PRIMITIVE;
	var service_message_broker_1 = __webpack_require__(38);
	exports.ReceivedMessage = service_message_broker_1.ReceivedMessage;
	exports.ServiceMessageBroker = service_message_broker_1.ServiceMessageBroker;
	exports.ServiceMessageBrokerFactory = service_message_broker_1.ServiceMessageBrokerFactory;
	__export(__webpack_require__(17));
	var location_providers_1 = __webpack_require__(252);
	exports.WORKER_APP_LOCATION_PROVIDERS = location_providers_1.WORKER_APP_LOCATION_PROVIDERS;
	var location_providers_2 = __webpack_require__(249);
	exports.WORKER_UI_LOCATION_PROVIDERS = location_providers_2.WORKER_UI_LOCATION_PROVIDERS;
	__export(__webpack_require__(257));
	__export(__webpack_require__(256));
	__export(__webpack_require__(233));
	//# sourceMappingURL=index.js.map

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var browser = __webpack_require__(63);
	var ng_proble = __webpack_require__(178);
	var dom_adapter = __webpack_require__(7);
	var dom_renderer = __webpack_require__(66);
	var dom_events = __webpack_require__(106);
	var shared_styles_host = __webpack_require__(67);
	exports.__platform_browser_private__ = {
	    DomAdapter: dom_adapter.DomAdapter,
	    getDOM: dom_adapter.getDOM,
	    setRootDomAdapter: dom_adapter.setRootDomAdapter,
	    DomRootRenderer: dom_renderer.DomRootRenderer,
	    DomRootRenderer_: dom_renderer.DomRootRenderer_,
	    DomSharedStylesHost: shared_styles_host.DomSharedStylesHost,
	    SharedStylesHost: shared_styles_host.SharedStylesHost,
	    ELEMENT_PROBE_PROVIDERS: ng_proble.ELEMENT_PROBE_PROVIDERS,
	    DomEventsPlugin: dom_events.DomEventsPlugin,
	    initDomAdapter: browser.initDomAdapter,
	    INTERNAL_BROWSER_PLATFORM_PROVIDERS: browser.INTERNAL_BROWSER_PLATFORM_PROVIDERS
	};
	//# sourceMappingURL=private_export.js.map

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var dom_adapter_1 = __webpack_require__(7);
	var collection_1 = __webpack_require__(8);
	var lang_1 = __webpack_require__(5);
	/**
	 * Provides DOM operations in any browser environment.
	 */
	var GenericBrowserDomAdapter = (function (_super) {
	    __extends(GenericBrowserDomAdapter, _super);
	    function GenericBrowserDomAdapter() {
	        var _this = this;
	        _super.call(this);
	        this._animationPrefix = null;
	        this._transitionEnd = null;
	        try {
	            var element = this.createElement('div', this.defaultDoc());
	            if (lang_1.isPresent(this.getStyle(element, 'animationName'))) {
	                this._animationPrefix = '';
	            }
	            else {
	                var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
	                for (var i = 0; i < domPrefixes.length; i++) {
	                    if (lang_1.isPresent(this.getStyle(element, domPrefixes[i] + 'AnimationName'))) {
	                        this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';
	                        break;
	                    }
	                }
	            }
	            var transEndEventNames = {
	                WebkitTransition: 'webkitTransitionEnd',
	                MozTransition: 'transitionend',
	                OTransition: 'oTransitionEnd otransitionend',
	                transition: 'transitionend'
	            };
	            collection_1.StringMapWrapper.forEach(transEndEventNames, function (value, key) {
	                if (lang_1.isPresent(_this.getStyle(element, key))) {
	                    _this._transitionEnd = value;
	                }
	            });
	        }
	        catch (e) {
	            this._animationPrefix = null;
	            this._transitionEnd = null;
	        }
	    }
	    GenericBrowserDomAdapter.prototype.getDistributedNodes = function (el) { return el.getDistributedNodes(); };
	    GenericBrowserDomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {
	        el.href = href == null ? baseUrl : baseUrl + '/../' + href;
	    };
	    GenericBrowserDomAdapter.prototype.supportsDOMEvents = function () { return true; };
	    GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function () {
	        return lang_1.isFunction(this.defaultDoc().body.createShadowRoot);
	    };
	    GenericBrowserDomAdapter.prototype.getAnimationPrefix = function () {
	        return lang_1.isPresent(this._animationPrefix) ? this._animationPrefix : '';
	    };
	    GenericBrowserDomAdapter.prototype.getTransitionEnd = function () { return lang_1.isPresent(this._transitionEnd) ? this._transitionEnd : ''; };
	    GenericBrowserDomAdapter.prototype.supportsAnimation = function () {
	        return lang_1.isPresent(this._animationPrefix) && lang_1.isPresent(this._transitionEnd);
	    };
	    return GenericBrowserDomAdapter;
	}(dom_adapter_1.DomAdapter));
	exports.GenericBrowserDomAdapter = GenericBrowserDomAdapter;
	//# sourceMappingURL=generic_browser_adapter.js.map

/***/ },
/* 235 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	function supportsState() {
	    return !!window.history.pushState;
	}
	exports.supportsState = supportsState;
	//# sourceMappingURL=history.js.map

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var dom_adapter_1 = __webpack_require__(7);
	/**
	 * A service that can be used to get and set the title of a current HTML document.
	 *
	 * Since an Angular 2 application can't be bootstrapped on the entire HTML document (`<html>` tag)
	 * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
	 * (representing the `<title>` tag). Instead, this service can be used to set and get the current
	 * title value.
	 *
	 * @experimental
	 */
	var Title = (function () {
	    function Title() {
	    }
	    /**
	     * Get the title of the current HTML document.
	     * @returns {string}
	     */
	    Title.prototype.getTitle = function () { return dom_adapter_1.getDOM().getTitle(); };
	    /**
	     * Set the title of the current HTML document.
	     * @param newTitle
	     */
	    Title.prototype.setTitle = function (newTitle) { dom_adapter_1.getDOM().setTitle(newTitle); };
	    return Title;
	}());
	exports.Title = Title;
	//# sourceMappingURL=title.js.map

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var dom_adapter_1 = __webpack_require__(7);
	var browser_1 = __webpack_require__(244);
	var lang_1 = __webpack_require__(5);
	var ChangeDetectionPerfRecord = (function () {
	    function ChangeDetectionPerfRecord(msPerTick, numTicks) {
	        this.msPerTick = msPerTick;
	        this.numTicks = numTicks;
	    }
	    return ChangeDetectionPerfRecord;
	}());
	exports.ChangeDetectionPerfRecord = ChangeDetectionPerfRecord;
	/**
	 * Entry point for all Angular debug tools. This object corresponds to the `ng`
	 * global variable accessible in the dev console.
	 */
	var AngularTools = (function () {
	    function AngularTools(ref) {
	        this.profiler = new AngularProfiler(ref);
	    }
	    return AngularTools;
	}());
	exports.AngularTools = AngularTools;
	/**
	 * Entry point for all Angular profiling-related debug tools. This object
	 * corresponds to the `ng.profiler` in the dev console.
	 */
	var AngularProfiler = (function () {
	    function AngularProfiler(ref) {
	        this.appRef = ref.injector.get(core_1.ApplicationRef);
	    }
	    /**
	     * Exercises change detection in a loop and then prints the average amount of
	     * time in milliseconds how long a single round of change detection takes for
	     * the current state of the UI. It runs a minimum of 5 rounds for a minimum
	     * of 500 milliseconds.
	     *
	     * Optionally, a user may pass a `config` parameter containing a map of
	     * options. Supported options are:
	     *
	     * `record` (boolean) - causes the profiler to record a CPU profile while
	     * it exercises the change detector. Example:
	     *
	     * ```
	     * ng.profiler.timeChangeDetection({record: true})
	     * ```
	     */
	    AngularProfiler.prototype.timeChangeDetection = function (config) {
	        var record = lang_1.isPresent(config) && config['record'];
	        var profileName = 'Change Detection';
	        // Profiler is not available in Android browsers, nor in IE 9 without dev tools opened
	        var isProfilerAvailable = lang_1.isPresent(browser_1.window.console.profile);
	        if (record && isProfilerAvailable) {
	            browser_1.window.console.profile(profileName);
	        }
	        var start = dom_adapter_1.getDOM().performanceNow();
	        var numTicks = 0;
	        while (numTicks < 5 || (dom_adapter_1.getDOM().performanceNow() - start) < 500) {
	            this.appRef.tick();
	            numTicks++;
	        }
	        var end = dom_adapter_1.getDOM().performanceNow();
	        if (record && isProfilerAvailable) {
	            // need to cast to <any> because type checker thinks there's no argument
	            // while in fact there is:
	            //
	            // https://developer.mozilla.org/en-US/docs/Web/API/Console/profileEnd
	            browser_1.window.console.profileEnd(profileName);
	        }
	        var msPerTick = (end - start) / numTicks;
	        browser_1.window.console.log("ran " + numTicks + " change detection cycles");
	        browser_1.window.console.log(lang_1.NumberWrapper.toFixed(msPerTick, 2) + " ms per check");
	        return new ChangeDetectionPerfRecord(msPerTick, numTicks);
	    };
	    return AngularProfiler;
	}());
	exports.AngularProfiler = AngularProfiler;
	//# sourceMappingURL=common_tools.js.map

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(5);
	var common_tools_1 = __webpack_require__(237);
	var context = lang_1.global;
	/**
	 * Enabled Angular 2 debug tools that are accessible via your browser's
	 * developer console.
	 *
	 * Usage:
	 *
	 * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)
	 * 1. Type `ng.` (usually the console will show auto-complete suggestion)
	 * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`
	 *    then hit Enter.
	 *
	 * @experimental All debugging apis are currently experimental.
	 */
	function enableDebugTools(ref) {
	    context.ng = new common_tools_1.AngularTools(ref);
	    return ref;
	}
	exports.enableDebugTools = enableDebugTools;
	/**
	 * Disables Angular 2 tools.
	 *
	 * @experimental All debugging apis are currently experimental.
	 */
	function disableDebugTools() {
	    delete context.ng;
	}
	exports.disableDebugTools = disableDebugTools;
	//# sourceMappingURL=tools.js.map

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var dom_adapter_1 = __webpack_require__(7);
	var lang_1 = __webpack_require__(5);
	/**
	 * Predicates for use with {@link DebugElement}'s query functions.
	 *
	 * @experimental All debugging apis are currently experimental.
	 */
	var By = (function () {
	    function By() {
	    }
	    /**
	     * Match all elements.
	     *
	     * ## Example
	     *
	     * {@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}
	     */
	    By.all = function () { return function (debugElement) { return true; }; };
	    /**
	     * Match elements by the given CSS selector.
	     *
	     * ## Example
	     *
	     * {@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}
	     */
	    By.css = function (selector) {
	        return function (debugElement) {
	            return lang_1.isPresent(debugElement.nativeElement) ?
	                dom_adapter_1.getDOM().elementMatches(debugElement.nativeElement, selector) :
	                false;
	        };
	    };
	    /**
	     * Match elements that have the given directive present.
	     *
	     * ## Example
	     *
	     * {@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}
	     */
	    By.directive = function (type) {
	        return function (debugElement) { return debugElement.providerTokens.indexOf(type) !== -1; };
	    };
	    return By;
	}());
	exports.By = By;
	//# sourceMappingURL=by.js.map

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var collection_1 = __webpack_require__(8);
	var event_manager_1 = __webpack_require__(23);
	var _eventNames = {
	    // pan
	    'pan': true,
	    'panstart': true,
	    'panmove': true,
	    'panend': true,
	    'pancancel': true,
	    'panleft': true,
	    'panright': true,
	    'panup': true,
	    'pandown': true,
	    // pinch
	    'pinch': true,
	    'pinchstart': true,
	    'pinchmove': true,
	    'pinchend': true,
	    'pinchcancel': true,
	    'pinchin': true,
	    'pinchout': true,
	    // press
	    'press': true,
	    'pressup': true,
	    // rotate
	    'rotate': true,
	    'rotatestart': true,
	    'rotatemove': true,
	    'rotateend': true,
	    'rotatecancel': true,
	    // swipe
	    'swipe': true,
	    'swipeleft': true,
	    'swiperight': true,
	    'swipeup': true,
	    'swipedown': true,
	    // tap
	    'tap': true,
	};
	var HammerGesturesPluginCommon = (function (_super) {
	    __extends(HammerGesturesPluginCommon, _super);
	    function HammerGesturesPluginCommon() {
	        _super.call(this);
	    }
	    HammerGesturesPluginCommon.prototype.supports = function (eventName) {
	        eventName = eventName.toLowerCase();
	        return collection_1.StringMapWrapper.contains(_eventNames, eventName);
	    };
	    return HammerGesturesPluginCommon;
	}(event_manager_1.EventManagerPlugin));
	exports.HammerGesturesPluginCommon = HammerGesturesPluginCommon;
	//# sourceMappingURL=hammer_common.js.map

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(8);
	var lang_1 = __webpack_require__(5);
	var util_1 = __webpack_require__(180);
	var web_animations_player_1 = __webpack_require__(242);
	var WebAnimationsDriver = (function () {
	    function WebAnimationsDriver() {
	    }
	    WebAnimationsDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
	        var formattedSteps = [];
	        var startingStyleLookup = {};
	        if (lang_1.isPresent(startingStyles) && startingStyles.styles.length > 0) {
	            startingStyleLookup = _populateStyles(element, startingStyles, {});
	            startingStyleLookup['offset'] = 0;
	            formattedSteps.push(startingStyleLookup);
	        }
	        keyframes.forEach(function (keyframe) {
	            var data = _populateStyles(element, keyframe.styles, startingStyleLookup);
	            data['offset'] = keyframe.offset;
	            formattedSteps.push(data);
	        });
	        // this is a special case when only styles are applied as an
	        // animation. When this occurs we want to animate from start to
	        // end with the same values. Removing the offset and having only
	        // start/end values is suitable enough for the web-animations API
	        if (formattedSteps.length == 1) {
	            var start = formattedSteps[0];
	            start['offset'] = null;
	            formattedSteps = [start, start];
	        }
	        var playerOptions = {
	            'duration': duration,
	            'delay': delay,
	            'fill': 'both' // we use `both` because it allows for styling at 0% to work with `delay`
	        };
	        // we check for this to avoid having a null|undefined value be present
	        // for the easing (which results in an error for certain browsers #9752)
	        if (easing) {
	            playerOptions['easing'] = easing;
	        }
	        return new web_animations_player_1.WebAnimationsPlayer(element, formattedSteps, playerOptions);
	    };
	    return WebAnimationsDriver;
	}());
	exports.WebAnimationsDriver = WebAnimationsDriver;
	function _populateStyles(element, styles, defaultStyles) {
	    var data = {};
	    styles.styles.forEach(function (entry) {
	        collection_1.StringMapWrapper.forEach(entry, function (val, prop) {
	            var formattedProp = util_1.dashCaseToCamelCase(prop);
	            data[formattedProp] =
	                val == core_1.AUTO_STYLE ? val : val.toString() + _resolveStyleUnit(val, prop, formattedProp);
	        });
	    });
	    collection_1.StringMapWrapper.forEach(defaultStyles, function (value, prop) {
	        if (!lang_1.isPresent(data[prop])) {
	            data[prop] = value;
	        }
	    });
	    return data;
	}
	function _resolveStyleUnit(val, userProvidedProp, formattedProp) {
	    var unit = '';
	    if (_isPixelDimensionStyle(formattedProp) && val != 0 && val != '0') {
	        if (lang_1.isNumber(val)) {
	            unit = 'px';
	        }
	        else if (_findDimensionalSuffix(val.toString()).length == 0) {
	            throw new core_1.BaseException('Please provide a CSS unit value for ' + userProvidedProp + ':' + val);
	        }
	    }
	    return unit;
	}
	var _$0 = 48;
	var _$9 = 57;
	var _$PERIOD = 46;
	function _findDimensionalSuffix(value) {
	    for (var i = 0; i < value.length; i++) {
	        var c = lang_1.StringWrapper.charCodeAt(value, i);
	        if ((c >= _$0 && c <= _$9) || c == _$PERIOD)
	            continue;
	        return value.substring(i, value.length);
	    }
	    return '';
	}
	function _isPixelDimensionStyle(prop) {
	    switch (prop) {
	        case 'width':
	        case 'height':
	        case 'minWidth':
	        case 'minHeight':
	        case 'maxWidth':
	        case 'maxHeight':
	        case 'left':
	        case 'top':
	        case 'bottom':
	        case 'right':
	        case 'fontSize':
	        case 'outlineWidth':
	        case 'outlineOffset':
	        case 'paddingTop':
	        case 'paddingLeft':
	        case 'paddingBottom':
	        case 'paddingRight':
	        case 'marginTop':
	        case 'marginLeft':
	        case 'marginBottom':
	        case 'marginRight':
	        case 'borderRadius':
	        case 'borderWidth':
	        case 'borderTopWidth':
	        case 'borderLeftWidth':
	        case 'borderRightWidth':
	        case 'borderBottomWidth':
	        case 'textIndent':
	            return true;
	        default:
	            return false;
	    }
	}
	//# sourceMappingURL=web_animations_driver.js.map

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(8);
	var lang_1 = __webpack_require__(5);
	var dom_adapter_1 = __webpack_require__(7);
	var WebAnimationsPlayer = (function () {
	    function WebAnimationsPlayer(element, keyframes, options) {
	        this.element = element;
	        this.keyframes = keyframes;
	        this.options = options;
	        this._subscriptions = [];
	        this._finished = false;
	        this._initialized = false;
	        this._started = false;
	        this.parentPlayer = null;
	        this._duration = options['duration'];
	    }
	    WebAnimationsPlayer.prototype._onFinish = function () {
	        if (!this._finished) {
	            this._finished = true;
	            if (!lang_1.isPresent(this.parentPlayer)) {
	                this.destroy();
	            }
	            this._subscriptions.forEach(function (fn) { return fn(); });
	            this._subscriptions = [];
	        }
	    };
	    WebAnimationsPlayer.prototype.init = function () {
	        var _this = this;
	        if (this._initialized)
	            return;
	        this._initialized = true;
	        var keyframes = this.keyframes.map(function (styles) {
	            var formattedKeyframe = {};
	            collection_1.StringMapWrapper.forEach(styles, function (value, prop) {
	                formattedKeyframe[prop] = value == core_1.AUTO_STYLE ? _computeStyle(_this.element, prop) : value;
	            });
	            return formattedKeyframe;
	        });
	        this._player = this._triggerWebAnimation(this.element, keyframes, this.options);
	        // this is required so that the player doesn't start to animate right away
	        this.reset();
	        this._player.onfinish = function () { return _this._onFinish(); };
	    };
	    /** @internal */
	    WebAnimationsPlayer.prototype._triggerWebAnimation = function (element, keyframes, options) {
	        return element.animate(keyframes, options);
	    };
	    WebAnimationsPlayer.prototype.onDone = function (fn) { this._subscriptions.push(fn); };
	    WebAnimationsPlayer.prototype.play = function () {
	        this.init();
	        this._player.play();
	    };
	    WebAnimationsPlayer.prototype.pause = function () {
	        this.init();
	        this._player.pause();
	    };
	    WebAnimationsPlayer.prototype.finish = function () {
	        this.init();
	        this._onFinish();
	        this._player.finish();
	    };
	    WebAnimationsPlayer.prototype.reset = function () { this._player.cancel(); };
	    WebAnimationsPlayer.prototype.restart = function () {
	        this.reset();
	        this.play();
	    };
	    WebAnimationsPlayer.prototype.hasStarted = function () { return this._started; };
	    WebAnimationsPlayer.prototype.destroy = function () {
	        this.reset();
	        this._onFinish();
	    };
	    Object.defineProperty(WebAnimationsPlayer.prototype, "totalTime", {
	        get: function () { return this._duration; },
	        enumerable: true,
	        configurable: true
	    });
	    WebAnimationsPlayer.prototype.setPosition = function (p) { this._player.currentTime = p * this.totalTime; };
	    WebAnimationsPlayer.prototype.getPosition = function () { return this._player.currentTime / this.totalTime; };
	    return WebAnimationsPlayer;
	}());
	exports.WebAnimationsPlayer = WebAnimationsPlayer;
	function _computeStyle(element, prop) {
	    return dom_adapter_1.getDOM().getComputedStyle(element)[prop];
	}
	//# sourceMappingURL=web_animations_player.js.map

/***/ },
/* 243 */
25,
/* 244 */
/***/ function(module, exports) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	/**
	 * JS version of browser APIs. This library can only run in the browser.
	 */
	var win = typeof window !== 'undefined' && window || {};
	exports.window = win;
	exports.document = win.document;
	exports.location = win.location;
	exports.gc = win['gc'] ? function () { return win['gc'](); } : function () { return null; };
	exports.performance = win['performance'] ? win['performance'] : null;
	exports.Event = win['Event'];
	exports.MouseEvent = win['MouseEvent'];
	exports.KeyboardEvent = win['KeyboardEvent'];
	exports.EventTarget = win['EventTarget'];
	exports.History = win['History'];
	exports.Location = win['Location'];
	exports.EventListener = win['EventListener'];
	//# sourceMappingURL=browser.js.map

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var dom_adapter_1 = __webpack_require__(7);
	var url_sanitizer_1 = __webpack_require__(108);
	/** A <body> element that can be safely used to parse untrusted HTML. Lazily initialized below. */
	var inertElement = null;
	/** Lazily initialized to make sure the DOM adapter gets set before use. */
	var DOM = null;
	/** Returns an HTML element that is guaranteed to not execute code when creating elements in it. */
	function getInertElement() {
	    if (inertElement)
	        return inertElement;
	    DOM = dom_adapter_1.getDOM();
	    // Prefer using <template> element if supported.
	    var templateEl = DOM.createElement('template');
	    if ('content' in templateEl)
	        return templateEl;
	    var doc = DOM.createHtmlDocument();
	    inertElement = DOM.querySelector(doc, 'body');
	    if (inertElement == null) {
	        // usually there should be only one body element in the document, but IE doesn't have any, so we
	        // need to create one.
	        var html = DOM.createElement('html', doc);
	        inertElement = DOM.createElement('body', doc);
	        DOM.appendChild(html, inertElement);
	        DOM.appendChild(doc, html);
	    }
	    return inertElement;
	}
	function tagSet(tags) {
	    var res = {};
	    for (var _i = 0, _a = tags.split(','); _i < _a.length; _i++) {
	        var t = _a[_i];
	        res[t] = true;
	    }
	    return res;
	}
	function merge() {
	    var sets = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        sets[_i - 0] = arguments[_i];
	    }
	    var res = {};
	    for (var _a = 0, sets_1 = sets; _a < sets_1.length; _a++) {
	        var s = sets_1[_a];
	        for (var v in s) {
	            if (s.hasOwnProperty(v))
	                res[v] = true;
	        }
	    }
	    return res;
	}
	// Good source of info about elements and attributes
	// http://dev.w3.org/html5/spec/Overview.html#semantics
	// http://simon.html5.org/html-elements
	// Safe Void Elements - HTML5
	// http://dev.w3.org/html5/spec/Overview.html#void-elements
	var VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');
	// Elements that you can, intentionally, leave open (and which close themselves)
	// http://dev.w3.org/html5/spec/Overview.html#optional-tags
	var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
	var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
	var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
	// Safe Block Elements - HTML5
	var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +
	    'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +
	    'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));
	// Inline Elements - HTML5
	var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +
	    'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +
	    'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
	var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
	// Attributes that have href and hence need to be sanitized
	var URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
	// Attributes that have special href set hence need to be sanitized
	var SRCSET_ATTRS = tagSet('srcset');
	var HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +
	    'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +
	    'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +
	    'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +
	    'valign,value,vspace,width');
	// NB: This currently conciously doesn't support SVG. SVG sanitization has had several security
	// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via
	// innerHTML is required, SVG attributes should be added here.
	// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those
	// can be sanitized, but they increase security surface area without a legitimate use case, so they
	// are left out here.
	var VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);
	/**
	 * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe
	 * attributes.
	 */
	var SanitizingHtmlSerializer = (function () {
	    function SanitizingHtmlSerializer() {
	        // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just
	        // because characters were re-encoded.
	        this.sanitizedSomething = false;
	        this.buf = [];
	    }
	    SanitizingHtmlSerializer.prototype.sanitizeChildren = function (el) {
	        // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.
	        // However this code never accesses properties off of `document` before deleting its contents
	        // again, so it shouldn't be vulnerable to DOM clobbering.
	        var current = el.firstChild;
	        while (current) {
	            if (DOM.isElementNode(current)) {
	                this.startElement(current);
	            }
	            else if (DOM.isTextNode(current)) {
	                this.chars(DOM.nodeValue(current));
	            }
	            else {
	                // Strip non-element, non-text nodes.
	                this.sanitizedSomething = true;
	            }
	            if (DOM.firstChild(current)) {
	                current = DOM.firstChild(current);
	                continue;
	            }
	            while (current) {
	                // Leaving the element. Walk up and to the right, closing tags as we go.
	                if (DOM.isElementNode(current)) {
	                    this.endElement(current);
	                }
	                if (DOM.nextSibling(current)) {
	                    current = DOM.nextSibling(current);
	                    break;
	                }
	                current = DOM.parentElement(current);
	            }
	        }
	        return this.buf.join('');
	    };
	    SanitizingHtmlSerializer.prototype.startElement = function (element) {
	        var _this = this;
	        var tagName = DOM.nodeName(element).toLowerCase();
	        if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
	            this.sanitizedSomething = true;
	            return;
	        }
	        this.buf.push('<');
	        this.buf.push(tagName);
	        DOM.attributeMap(element).forEach(function (value, attrName) {
	            var lower = attrName.toLowerCase();
	            if (!VALID_ATTRS.hasOwnProperty(lower)) {
	                _this.sanitizedSomething = true;
	                return;
	            }
	            // TODO(martinprobst): Special case image URIs for data:image/...
	            if (URI_ATTRS[lower])
	                value = url_sanitizer_1.sanitizeUrl(value);
	            if (SRCSET_ATTRS[lower])
	                value = url_sanitizer_1.sanitizeSrcset(value);
	            _this.buf.push(' ');
	            _this.buf.push(attrName);
	            _this.buf.push('="');
	            _this.buf.push(encodeEntities(value));
	            _this.buf.push('"');
	        });
	        this.buf.push('>');
	    };
	    SanitizingHtmlSerializer.prototype.endElement = function (current) {
	        var tagName = DOM.nodeName(current).toLowerCase();
	        if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
	            this.buf.push('</');
	            this.buf.push(tagName);
	            this.buf.push('>');
	        }
	    };
	    SanitizingHtmlSerializer.prototype.chars = function (chars /** TODO #9100 */) { this.buf.push(encodeEntities(chars)); };
	    return SanitizingHtmlSerializer;
	}());
	// Regular Expressions for parsing tags and attributes
	var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	// ! to ~ is the ASCII range.
	var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
	/**
	 * Escapes all potentially dangerous characters, so that the
	 * resulting string can be safely inserted into attribute or
	 * element text.
	 * @param value
	 * @returns {string} escaped text
	 */
	function encodeEntities(value) {
	    return value.replace(/&/g, '&amp;')
	        .replace(SURROGATE_PAIR_REGEXP, function (match) {
	        var hi = match.charCodeAt(0);
	        var low = match.charCodeAt(1);
	        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
	    })
	        .replace(NON_ALPHANUMERIC_REGEXP, function (match) { return '&#' + match.charCodeAt(0) + ';'; })
	        .replace(/</g, '&lt;')
	        .replace(/>/g, '&gt;');
	}
	/**
	 * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'
	 * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo').
	 *
	 * This is undesirable since we don't want to allow any of these custom attributes. This method
	 * strips them all.
	 */
	function stripCustomNsAttrs(el) {
	    DOM.attributeMap(el).forEach(function (_, attrName) {
	        if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
	            DOM.removeAttribute(el, attrName);
	        }
	    });
	    for (var _i = 0, _a = DOM.childNodesAsList(el); _i < _a.length; _i++) {
	        var n = _a[_i];
	        if (DOM.isElementNode(n))
	            stripCustomNsAttrs(n);
	    }
	}
	/**
	 * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to
	 * the DOM in a browser environment.
	 */
	function sanitizeHtml(unsafeHtmlInput) {
	    try {
	        var containerEl = getInertElement();
	        // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).
	        var unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
	        // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser
	        // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.
	        var mXSSAttempts = 5;
	        var parsedHtml = unsafeHtml;
	        do {
	            if (mXSSAttempts === 0) {
	                throw new Error('Failed to sanitize html because the input is unstable');
	            }
	            mXSSAttempts--;
	            unsafeHtml = parsedHtml;
	            DOM.setInnerHTML(containerEl, unsafeHtml);
	            if (DOM.defaultDoc().documentMode) {
	                // strip custom-namespaced attributes on IE<=11
	                stripCustomNsAttrs(containerEl);
	            }
	            parsedHtml = DOM.getInnerHTML(containerEl);
	        } while (unsafeHtml !== parsedHtml);
	        var sanitizer = new SanitizingHtmlSerializer();
	        var safeHtml = sanitizer.sanitizeChildren(DOM.getTemplateContent(containerEl) || containerEl);
	        // Clear out the body element.
	        var parent_1 = DOM.getTemplateContent(containerEl) || containerEl;
	        for (var _i = 0, _a = DOM.childNodesAsList(parent_1); _i < _a.length; _i++) {
	            var child = _a[_i];
	            DOM.removeChild(parent_1, child);
	        }
	        if (core_1.isDevMode() && sanitizer.sanitizedSomething) {
	            DOM.log('WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');
	        }
	        return safeHtml;
	    }
	    catch (e) {
	        // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.
	        inertElement = null;
	        throw e;
	    }
	}
	exports.sanitizeHtml = sanitizeHtml;
	//# sourceMappingURL=html_sanitizer.js.map

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var dom_adapter_1 = __webpack_require__(7);
	var url_sanitizer_1 = __webpack_require__(108);
	/**
	 * Regular expression for safe style values.
	 *
	 * Quotes (" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.
	 *
	 * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or
	 * font-family) and hence could allow multiple values to get injected, but that should pose no risk
	 * of XSS.
	 *
	 * The function expression checks only for XSS safety, not for CSS validity.
	 *
	 * This regular expression was taken from the Closure sanitization library, and augmented for
	 * transformation values.
	 */
	var VALUES = '[-,."\'%_!# a-zA-Z0-9]+';
	var TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';
	var COLOR_FNS = '(?:rgb|hsl)a?';
	var FN_ARGS = '\\([-0-9.%, a-zA-Z]+\\)';
	var SAFE_STYLE_VALUE = new RegExp("^(" + VALUES + "|(?:" + TRANSFORMATION_FNS + "|" + COLOR_FNS + ")" + FN_ARGS + ")$", 'g');
	/**
	 * Matches a `url(...)` value with an arbitrary argument as long as it does
	 * not contain parentheses.
	 *
	 * The URL value still needs to be sanitized separately.
	 *
	 * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted
	 * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.
	 * by observing whether scroll bars are displayed, or character ranges used by a font face
	 * definition.
	 *
	 * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that
	 * binding a URL value without further cooperation from the page will cause an information leak, and
	 * if so, it is just a leak, not a full blown XSS vulnerability.
	 *
	 * Given the common use case, low likelihood of attack vector, and low impact of an attack, this
	 * code is permissive and allows URLs that sanitize otherwise.
	 */
	var URL_RE = /^url\(([^)]+)\)$/;
	/**
	 * Checks that quotes (" and ') are properly balanced inside a string. Assumes
	 * that neither escape (\) nor any other character that could result in
	 * breaking out of a string parsing context are allowed;
	 * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.
	 *
	 * This code was taken from the Closure sanitization library.
	 */
	function hasBalancedQuotes(value) {
	    var outsideSingle = true;
	    var outsideDouble = true;
	    for (var i = 0; i < value.length; i++) {
	        var c = value.charAt(i);
	        if (c === '\'' && outsideDouble) {
	            outsideSingle = !outsideSingle;
	        }
	        else if (c === '"' && outsideSingle) {
	            outsideDouble = !outsideDouble;
	        }
	    }
	    return outsideSingle && outsideDouble;
	}
	/**
	 * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single
	 * value) and returns a value that is safe to use in a browser environment.
	 */
	function sanitizeStyle(value) {
	    value = String(value).trim(); // Make sure it's actually a string.
	    if (!value)
	        return '';
	    // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for
	    // reasoning behind this.
	    var urlMatch = value.match(URL_RE);
	    if ((urlMatch && url_sanitizer_1.sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||
	        value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {
	        return value; // Safe style values.
	    }
	    if (core_1.isDevMode()) {
	        dom_adapter_1.getDOM().log("WARNING: sanitizing unsafe style value " + value + " (see http://g.co/ng/security#xss).");
	    }
	    return 'unsafe';
	}
	exports.sanitizeStyle = sanitizeStyle;
	//# sourceMappingURL=style_sanitizer.js.map

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var exceptions_1 = __webpack_require__(19);
	var serializer_1 = __webpack_require__(14);
	var event_serializer_1 = __webpack_require__(248);
	var EventDispatcher = (function () {
	    function EventDispatcher(_sink, _serializer) {
	        this._sink = _sink;
	        this._serializer = _serializer;
	    }
	    EventDispatcher.prototype.dispatchRenderEvent = function (element, eventTarget, eventName, event) {
	        var serializedEvent;
	        // TODO (jteplitz602): support custom events #3350
	        switch (event.type) {
	            case 'click':
	            case 'mouseup':
	            case 'mousedown':
	            case 'dblclick':
	            case 'contextmenu':
	            case 'mouseenter':
	            case 'mouseleave':
	            case 'mousemove':
	            case 'mouseout':
	            case 'mouseover':
	            case 'show':
	                serializedEvent = event_serializer_1.serializeMouseEvent(event);
	                break;
	            case 'keydown':
	            case 'keypress':
	            case 'keyup':
	                serializedEvent = event_serializer_1.serializeKeyboardEvent(event);
	                break;
	            case 'input':
	            case 'change':
	            case 'blur':
	                serializedEvent = event_serializer_1.serializeEventWithTarget(event);
	                break;
	            case 'abort':
	            case 'afterprint':
	            case 'beforeprint':
	            case 'cached':
	            case 'canplay':
	            case 'canplaythrough':
	            case 'chargingchange':
	            case 'chargingtimechange':
	            case 'close':
	            case 'dischargingtimechange':
	            case 'DOMContentLoaded':
	            case 'downloading':
	            case 'durationchange':
	            case 'emptied':
	            case 'ended':
	            case 'error':
	            case 'fullscreenchange':
	            case 'fullscreenerror':
	            case 'invalid':
	            case 'languagechange':
	            case 'levelfchange':
	            case 'loadeddata':
	            case 'loadedmetadata':
	            case 'obsolete':
	            case 'offline':
	            case 'online':
	            case 'open':
	            case 'orientatoinchange':
	            case 'pause':
	            case 'pointerlockchange':
	            case 'pointerlockerror':
	            case 'play':
	            case 'playing':
	            case 'ratechange':
	            case 'readystatechange':
	            case 'reset':
	            case 'scroll':
	            case 'seeked':
	            case 'seeking':
	            case 'stalled':
	            case 'submit':
	            case 'success':
	            case 'suspend':
	            case 'timeupdate':
	            case 'updateready':
	            case 'visibilitychange':
	            case 'volumechange':
	            case 'waiting':
	                serializedEvent = event_serializer_1.serializeGenericEvent(event);
	                break;
	            case 'transitionend':
	                serializedEvent = event_serializer_1.serializeTransitionEvent(event);
	                break;
	            default:
	                throw new exceptions_1.BaseException(eventName + ' not supported on WebWorkers');
	        }
	        this._sink.emit({
	            'element': this._serializer.serialize(element, serializer_1.RenderStoreObject),
	            'eventName': eventName,
	            'eventTarget': eventTarget,
	            'event': serializedEvent
	        });
	        // TODO(kegluneq): Eventually, we want the user to indicate from the UI side whether the event
	        // should be canceled, but for now just call `preventDefault` on the original DOM event.
	        return false;
	    };
	    return EventDispatcher;
	}());
	exports.EventDispatcher = EventDispatcher;
	//# sourceMappingURL=event_dispatcher.js.map

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var collection_1 = __webpack_require__(8);
	var lang_1 = __webpack_require__(5);
	var MOUSE_EVENT_PROPERTIES = [
	    'altKey', 'button', 'clientX', 'clientY', 'metaKey', 'movementX', 'movementY', 'offsetX',
	    'offsetY', 'region', 'screenX', 'screenY', 'shiftKey'
	];
	var KEYBOARD_EVENT_PROPERTIES = [
	    'altkey', 'charCode', 'code', 'ctrlKey', 'isComposing', 'key', 'keyCode', 'location', 'metaKey',
	    'repeat', 'shiftKey', 'which'
	];
	var TRANSITION_EVENT_PROPERTIES = ['propertyName', 'elapsedTime', 'pseudoElement'];
	var EVENT_PROPERTIES = ['type', 'bubbles', 'cancelable'];
	var NODES_WITH_VALUE = new collection_1.Set(['input', 'select', 'option', 'button', 'li', 'meter', 'progress', 'param', 'textarea']);
	function serializeGenericEvent(e) {
	    return serializeEvent(e, EVENT_PROPERTIES);
	}
	exports.serializeGenericEvent = serializeGenericEvent;
	// TODO(jteplitz602): Allow users to specify the properties they need rather than always
	// adding value and files #3374
	function serializeEventWithTarget(e) {
	    var serializedEvent = serializeEvent(e, EVENT_PROPERTIES);
	    return addTarget(e, serializedEvent);
	}
	exports.serializeEventWithTarget = serializeEventWithTarget;
	function serializeMouseEvent(e) {
	    return serializeEvent(e, MOUSE_EVENT_PROPERTIES);
	}
	exports.serializeMouseEvent = serializeMouseEvent;
	function serializeKeyboardEvent(e) {
	    var serializedEvent = serializeEvent(e, KEYBOARD_EVENT_PROPERTIES);
	    return addTarget(e, serializedEvent);
	}
	exports.serializeKeyboardEvent = serializeKeyboardEvent;
	function serializeTransitionEvent(e) {
	    var serializedEvent = serializeEvent(e, TRANSITION_EVENT_PROPERTIES);
	    return addTarget(e, serializedEvent);
	}
	exports.serializeTransitionEvent = serializeTransitionEvent;
	// TODO(jteplitz602): #3374. See above.
	function addTarget(e, serializedEvent) {
	    if (NODES_WITH_VALUE.has(e.target.tagName.toLowerCase())) {
	        var target = e.target;
	        serializedEvent['target'] = { 'value': target.value };
	        if (lang_1.isPresent(target.files)) {
	            serializedEvent['target']['files'] = target.files;
	        }
	    }
	    return serializedEvent;
	}
	function serializeEvent(e, properties) {
	    var serialized = {};
	    for (var i = 0; i < properties.length; i++) {
	        var prop = properties[i];
	        serialized[prop] = e[prop];
	    }
	    return serialized;
	}
	//# sourceMappingURL=event_serializer.js.map

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var browser_platform_location_1 = __webpack_require__(64);
	var platform_location_1 = __webpack_require__(250);
	/**
	 * A list of {@link Provider}s. To use the router in a Worker enabled application you must
	 * include these providers when setting up the render thread.
	 * @experimental
	 */
	exports.WORKER_UI_LOCATION_PROVIDERS = [
	    platform_location_1.MessageBasedPlatformLocation, browser_platform_location_1.BrowserPlatformLocation,
	    { provide: core_1.PLATFORM_INITIALIZER, useFactory: initUiLocation, multi: true, deps: [core_1.Injector] }
	];
	function initUiLocation(injector) {
	    return function () {
	        var zone = injector.get(core_1.NgZone);
	        zone.runGuarded(function () { return injector.get(platform_location_1.MessageBasedPlatformLocation).start(); });
	    };
	}
	//# sourceMappingURL=location_providers.js.map

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var browser_platform_location_1 = __webpack_require__(64);
	var lang_1 = __webpack_require__(5);
	var message_bus_1 = __webpack_require__(17);
	var messaging_api_1 = __webpack_require__(68);
	var serialized_types_1 = __webpack_require__(109);
	var serializer_1 = __webpack_require__(14);
	var service_message_broker_1 = __webpack_require__(38);
	var MessageBasedPlatformLocation = (function () {
	    function MessageBasedPlatformLocation(_brokerFactory, _platformLocation, bus, _serializer) {
	        this._brokerFactory = _brokerFactory;
	        this._platformLocation = _platformLocation;
	        this._serializer = _serializer;
	        this._platformLocation.onPopState(lang_1.FunctionWrapper.bind(this._sendUrlChangeEvent, this));
	        this._platformLocation.onHashChange(lang_1.FunctionWrapper.bind(this._sendUrlChangeEvent, this));
	        this._broker = this._brokerFactory.createMessageBroker(messaging_api_1.ROUTER_CHANNEL);
	        this._channelSink = bus.to(messaging_api_1.ROUTER_CHANNEL);
	    }
	    MessageBasedPlatformLocation.prototype.start = function () {
	        this._broker.registerMethod('getLocation', null, lang_1.FunctionWrapper.bind(this._getLocation, this), serialized_types_1.LocationType);
	        this._broker.registerMethod('setPathname', [serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._setPathname, this));
	        this._broker.registerMethod('pushState', [serializer_1.PRIMITIVE, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._platformLocation.pushState, this._platformLocation));
	        this._broker.registerMethod('replaceState', [serializer_1.PRIMITIVE, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._platformLocation.replaceState, this._platformLocation));
	        this._broker.registerMethod('forward', null, lang_1.FunctionWrapper.bind(this._platformLocation.forward, this._platformLocation));
	        this._broker.registerMethod('back', null, lang_1.FunctionWrapper.bind(this._platformLocation.back, this._platformLocation));
	    };
	    MessageBasedPlatformLocation.prototype._getLocation = function () {
	        return Promise.resolve(this._platformLocation.location);
	    };
	    MessageBasedPlatformLocation.prototype._sendUrlChangeEvent = function (e) {
	        var loc = this._serializer.serialize(this._platformLocation.location, serialized_types_1.LocationType);
	        var serializedEvent = { 'type': e.type };
	        this._channelSink.emit({ 'event': serializedEvent, 'location': loc });
	    };
	    MessageBasedPlatformLocation.prototype._setPathname = function (pathname) { this._platformLocation.pathname = pathname; };
	    /** @nocollapse */
	    MessageBasedPlatformLocation.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    MessageBasedPlatformLocation.ctorParameters = [
	        { type: service_message_broker_1.ServiceMessageBrokerFactory, },
	        { type: browser_platform_location_1.BrowserPlatformLocation, },
	        { type: message_bus_1.MessageBus, },
	        { type: serializer_1.Serializer, },
	    ];
	    return MessageBasedPlatformLocation;
	}());
	exports.MessageBasedPlatformLocation = MessageBasedPlatformLocation;
	//# sourceMappingURL=platform_location.js.map

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var lang_1 = __webpack_require__(5);
	var message_bus_1 = __webpack_require__(17);
	var messaging_api_1 = __webpack_require__(68);
	var render_store_1 = __webpack_require__(37);
	var serializer_1 = __webpack_require__(14);
	var service_message_broker_1 = __webpack_require__(38);
	var event_dispatcher_1 = __webpack_require__(247);
	var MessageBasedRenderer = (function () {
	    function MessageBasedRenderer(_brokerFactory, _bus, _serializer, _renderStore, _rootRenderer) {
	        this._brokerFactory = _brokerFactory;
	        this._bus = _bus;
	        this._serializer = _serializer;
	        this._renderStore = _renderStore;
	        this._rootRenderer = _rootRenderer;
	    }
	    MessageBasedRenderer.prototype.start = function () {
	        var broker = this._brokerFactory.createMessageBroker(messaging_api_1.RENDERER_CHANNEL);
	        this._bus.initChannel(messaging_api_1.EVENT_CHANNEL);
	        this._eventDispatcher = new event_dispatcher_1.EventDispatcher(this._bus.to(messaging_api_1.EVENT_CHANNEL), this._serializer);
	        broker.registerMethod('renderComponent', [core_1.RenderComponentType, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._renderComponent, this));
	        broker.registerMethod('selectRootElement', [serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._selectRootElement, this));
	        broker.registerMethod('createElement', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._createElement, this));
	        broker.registerMethod('createViewRoot', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._createViewRoot, this));
	        broker.registerMethod('createTemplateAnchor', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._createTemplateAnchor, this));
	        broker.registerMethod('createText', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._createText, this));
	        broker.registerMethod('projectNodes', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.RenderStoreObject], lang_1.FunctionWrapper.bind(this._projectNodes, this));
	        broker.registerMethod('attachViewAfter', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.RenderStoreObject], lang_1.FunctionWrapper.bind(this._attachViewAfter, this));
	        broker.registerMethod('detachView', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject], lang_1.FunctionWrapper.bind(this._detachView, this));
	        broker.registerMethod('destroyView', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.RenderStoreObject], lang_1.FunctionWrapper.bind(this._destroyView, this));
	        broker.registerMethod('setElementProperty', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._setElementProperty, this));
	        broker.registerMethod('setElementAttribute', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._setElementAttribute, this));
	        broker.registerMethod('setBindingDebugInfo', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._setBindingDebugInfo, this));
	        broker.registerMethod('setElementClass', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._setElementClass, this));
	        broker.registerMethod('setElementStyle', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._setElementStyle, this));
	        broker.registerMethod('invokeElementMethod', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._invokeElementMethod, this));
	        broker.registerMethod('setText', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._setText, this));
	        broker.registerMethod('listen', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._listen, this));
	        broker.registerMethod('listenGlobal', [serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._listenGlobal, this));
	        broker.registerMethod('listenDone', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject], lang_1.FunctionWrapper.bind(this._listenDone, this));
	    };
	    MessageBasedRenderer.prototype._renderComponent = function (renderComponentType, rendererId) {
	        var renderer = this._rootRenderer.renderComponent(renderComponentType);
	        this._renderStore.store(renderer, rendererId);
	    };
	    MessageBasedRenderer.prototype._selectRootElement = function (renderer, selector, elId) {
	        this._renderStore.store(renderer.selectRootElement(selector, null), elId);
	    };
	    MessageBasedRenderer.prototype._createElement = function (renderer, parentElement, name, elId) {
	        this._renderStore.store(renderer.createElement(parentElement, name, null), elId);
	    };
	    MessageBasedRenderer.prototype._createViewRoot = function (renderer, hostElement, elId) {
	        var viewRoot = renderer.createViewRoot(hostElement);
	        if (this._renderStore.serialize(hostElement) !== elId) {
	            this._renderStore.store(viewRoot, elId);
	        }
	    };
	    MessageBasedRenderer.prototype._createTemplateAnchor = function (renderer, parentElement, elId) {
	        this._renderStore.store(renderer.createTemplateAnchor(parentElement, null), elId);
	    };
	    MessageBasedRenderer.prototype._createText = function (renderer, parentElement, value, elId) {
	        this._renderStore.store(renderer.createText(parentElement, value, null), elId);
	    };
	    MessageBasedRenderer.prototype._projectNodes = function (renderer, parentElement, nodes) {
	        renderer.projectNodes(parentElement, nodes);
	    };
	    MessageBasedRenderer.prototype._attachViewAfter = function (renderer, node, viewRootNodes) {
	        renderer.attachViewAfter(node, viewRootNodes);
	    };
	    MessageBasedRenderer.prototype._detachView = function (renderer, viewRootNodes) {
	        renderer.detachView(viewRootNodes);
	    };
	    MessageBasedRenderer.prototype._destroyView = function (renderer, hostElement, viewAllNodes) {
	        renderer.destroyView(hostElement, viewAllNodes);
	        for (var i = 0; i < viewAllNodes.length; i++) {
	            this._renderStore.remove(viewAllNodes[i]);
	        }
	    };
	    MessageBasedRenderer.prototype._setElementProperty = function (renderer, renderElement, propertyName, propertyValue) {
	        renderer.setElementProperty(renderElement, propertyName, propertyValue);
	    };
	    MessageBasedRenderer.prototype._setElementAttribute = function (renderer, renderElement, attributeName, attributeValue) {
	        renderer.setElementAttribute(renderElement, attributeName, attributeValue);
	    };
	    MessageBasedRenderer.prototype._setBindingDebugInfo = function (renderer, renderElement, propertyName, propertyValue) {
	        renderer.setBindingDebugInfo(renderElement, propertyName, propertyValue);
	    };
	    MessageBasedRenderer.prototype._setElementClass = function (renderer, renderElement, className, isAdd) {
	        renderer.setElementClass(renderElement, className, isAdd);
	    };
	    MessageBasedRenderer.prototype._setElementStyle = function (renderer, renderElement, styleName, styleValue) {
	        renderer.setElementStyle(renderElement, styleName, styleValue);
	    };
	    MessageBasedRenderer.prototype._invokeElementMethod = function (renderer, renderElement, methodName, args) {
	        renderer.invokeElementMethod(renderElement, methodName, args);
	    };
	    MessageBasedRenderer.prototype._setText = function (renderer, renderNode, text) {
	        renderer.setText(renderNode, text);
	    };
	    MessageBasedRenderer.prototype._listen = function (renderer, renderElement, eventName, unlistenId) {
	        var _this = this;
	        var unregisterCallback = renderer.listen(renderElement, eventName, function (event /** TODO #9100 */) {
	            return _this._eventDispatcher.dispatchRenderEvent(renderElement, null, eventName, event);
	        });
	        this._renderStore.store(unregisterCallback, unlistenId);
	    };
	    MessageBasedRenderer.prototype._listenGlobal = function (renderer, eventTarget, eventName, unlistenId) {
	        var _this = this;
	        var unregisterCallback = renderer.listenGlobal(eventTarget, eventName, function (event /** TODO #9100 */) {
	            return _this._eventDispatcher.dispatchRenderEvent(null, eventTarget, eventName, event);
	        });
	        this._renderStore.store(unregisterCallback, unlistenId);
	    };
	    MessageBasedRenderer.prototype._listenDone = function (renderer, unlistenCallback) { unlistenCallback(); };
	    /** @nocollapse */
	    MessageBasedRenderer.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    MessageBasedRenderer.ctorParameters = [
	        { type: service_message_broker_1.ServiceMessageBrokerFactory, },
	        { type: message_bus_1.MessageBus, },
	        { type: serializer_1.Serializer, },
	        { type: render_store_1.RenderStore, },
	        { type: core_1.RootRenderer, },
	    ];
	    return MessageBasedRenderer;
	}());
	exports.MessageBasedRenderer = MessageBasedRenderer;
	//# sourceMappingURL=renderer.js.map

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var common_1 = __webpack_require__(28);
	var core_1 = __webpack_require__(1);
	var platform_location_1 = __webpack_require__(253);
	/**
	 * Those providers should be added when the router is used in a worker context in addition to the
	 * {@link ROUTER_PROVIDERS} and after them.
	 * @experimental
	 */
	exports.WORKER_APP_LOCATION_PROVIDERS = [
	    { provide: common_1.PlatformLocation, useClass: platform_location_1.WebWorkerPlatformLocation }, {
	        provide: core_1.APP_INITIALIZER,
	        useFactory: appInitFnFactory,
	        multi: true,
	        deps: [common_1.PlatformLocation, core_1.NgZone]
	    }
	];
	function appInitFnFactory(platformLocation, zone) {
	    return function () { return zone.runGuarded(function () { return platformLocation.init(); }); };
	}
	//# sourceMappingURL=location_providers.js.map

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var common_1 = __webpack_require__(28);
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(8);
	var exceptions_1 = __webpack_require__(19);
	var lang_1 = __webpack_require__(5);
	var client_message_broker_1 = __webpack_require__(36);
	var message_bus_1 = __webpack_require__(17);
	var messaging_api_1 = __webpack_require__(68);
	var serialized_types_1 = __webpack_require__(109);
	var serializer_1 = __webpack_require__(14);
	var event_deserializer_1 = __webpack_require__(186);
	var WebWorkerPlatformLocation = (function (_super) {
	    __extends(WebWorkerPlatformLocation, _super);
	    function WebWorkerPlatformLocation(brokerFactory, bus, _serializer) {
	        var _this = this;
	        _super.call(this);
	        this._serializer = _serializer;
	        this._popStateListeners = [];
	        this._hashChangeListeners = [];
	        this._location = null;
	        this._broker = brokerFactory.createMessageBroker(messaging_api_1.ROUTER_CHANNEL);
	        this._channelSource = bus.from(messaging_api_1.ROUTER_CHANNEL);
	        this._channelSource.subscribe({
	            next: function (msg) {
	                var listeners = null;
	                if (collection_1.StringMapWrapper.contains(msg, 'event')) {
	                    var type = msg['event']['type'];
	                    if (lang_1.StringWrapper.equals(type, 'popstate')) {
	                        listeners = _this._popStateListeners;
	                    }
	                    else if (lang_1.StringWrapper.equals(type, 'hashchange')) {
	                        listeners = _this._hashChangeListeners;
	                    }
	                    if (listeners !== null) {
	                        var e_1 = event_deserializer_1.deserializeGenericEvent(msg['event']);
	                        // There was a popState or hashChange event, so the location object thas been updated
	                        _this._location = _this._serializer.deserialize(msg['location'], serialized_types_1.LocationType);
	                        listeners.forEach(function (fn) { return fn(e_1); });
	                    }
	                }
	            }
	        });
	    }
	    /** @internal **/
	    WebWorkerPlatformLocation.prototype.init = function () {
	        var _this = this;
	        var args = new client_message_broker_1.UiArguments('getLocation');
	        var locationPromise = this._broker.runOnService(args, serialized_types_1.LocationType);
	        return locationPromise.then(function (val) {
	            _this._location = val;
	            return true;
	        }, function (err) { throw new exceptions_1.BaseException(err); });
	    };
	    WebWorkerPlatformLocation.prototype.getBaseHrefFromDOM = function () {
	        throw new exceptions_1.BaseException('Attempt to get base href from DOM from WebWorker. You must either provide a value for the APP_BASE_HREF token through DI or use the hash location strategy.');
	    };
	    WebWorkerPlatformLocation.prototype.onPopState = function (fn) { this._popStateListeners.push(fn); };
	    WebWorkerPlatformLocation.prototype.onHashChange = function (fn) { this._hashChangeListeners.push(fn); };
	    Object.defineProperty(WebWorkerPlatformLocation.prototype, "pathname", {
	        get: function () {
	            if (this._location === null) {
	                return null;
	            }
	            return this._location.pathname;
	        },
	        set: function (newPath) {
	            if (this._location === null) {
	                throw new exceptions_1.BaseException('Attempt to set pathname before value is obtained from UI');
	            }
	            this._location.pathname = newPath;
	            var fnArgs = [new client_message_broker_1.FnArg(newPath, serializer_1.PRIMITIVE)];
	            var args = new client_message_broker_1.UiArguments('setPathname', fnArgs);
	            this._broker.runOnService(args, null);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WebWorkerPlatformLocation.prototype, "search", {
	        get: function () {
	            if (this._location === null) {
	                return null;
	            }
	            return this._location.search;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WebWorkerPlatformLocation.prototype, "hash", {
	        get: function () {
	            if (this._location === null) {
	                return null;
	            }
	            return this._location.hash;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    WebWorkerPlatformLocation.prototype.pushState = function (state, title, url) {
	        var fnArgs = [new client_message_broker_1.FnArg(state, serializer_1.PRIMITIVE), new client_message_broker_1.FnArg(title, serializer_1.PRIMITIVE), new client_message_broker_1.FnArg(url, serializer_1.PRIMITIVE)];
	        var args = new client_message_broker_1.UiArguments('pushState', fnArgs);
	        this._broker.runOnService(args, null);
	    };
	    WebWorkerPlatformLocation.prototype.replaceState = function (state, title, url) {
	        var fnArgs = [new client_message_broker_1.FnArg(state, serializer_1.PRIMITIVE), new client_message_broker_1.FnArg(title, serializer_1.PRIMITIVE), new client_message_broker_1.FnArg(url, serializer_1.PRIMITIVE)];
	        var args = new client_message_broker_1.UiArguments('replaceState', fnArgs);
	        this._broker.runOnService(args, null);
	    };
	    WebWorkerPlatformLocation.prototype.forward = function () {
	        var args = new client_message_broker_1.UiArguments('forward');
	        this._broker.runOnService(args, null);
	    };
	    WebWorkerPlatformLocation.prototype.back = function () {
	        var args = new client_message_broker_1.UiArguments('back');
	        this._broker.runOnService(args, null);
	    };
	    /** @nocollapse */
	    WebWorkerPlatformLocation.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    WebWorkerPlatformLocation.ctorParameters = [
	        { type: client_message_broker_1.ClientMessageBrokerFactory, },
	        { type: message_bus_1.MessageBus, },
	        { type: serializer_1.Serializer, },
	    ];
	    return WebWorkerPlatformLocation;
	}(common_1.PlatformLocation));
	exports.WebWorkerPlatformLocation = WebWorkerPlatformLocation;
	//# sourceMappingURL=platform_location.js.map

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var collection_1 = __webpack_require__(8);
	var lang_1 = __webpack_require__(5);
	var client_message_broker_1 = __webpack_require__(36);
	var message_bus_1 = __webpack_require__(17);
	var messaging_api_1 = __webpack_require__(68);
	var render_store_1 = __webpack_require__(37);
	var serializer_1 = __webpack_require__(14);
	var event_deserializer_1 = __webpack_require__(186);
	var WebWorkerRootRenderer = (function () {
	    function WebWorkerRootRenderer(messageBrokerFactory, bus, _serializer, _renderStore) {
	        var _this = this;
	        this._serializer = _serializer;
	        this._renderStore = _renderStore;
	        this.globalEvents = new NamedEventEmitter();
	        this._componentRenderers = new Map();
	        this._messageBroker = messageBrokerFactory.createMessageBroker(messaging_api_1.RENDERER_CHANNEL);
	        bus.initChannel(messaging_api_1.EVENT_CHANNEL);
	        var source = bus.from(messaging_api_1.EVENT_CHANNEL);
	        source.subscribe({ next: function (message) { return _this._dispatchEvent(message); } });
	    }
	    WebWorkerRootRenderer.prototype._dispatchEvent = function (message) {
	        var eventName = message['eventName'];
	        var target = message['eventTarget'];
	        var event = event_deserializer_1.deserializeGenericEvent(message['event']);
	        if (lang_1.isPresent(target)) {
	            this.globalEvents.dispatchEvent(eventNameWithTarget(target, eventName), event);
	        }
	        else {
	            var element = this._serializer.deserialize(message['element'], serializer_1.RenderStoreObject);
	            element.events.dispatchEvent(eventName, event);
	        }
	    };
	    WebWorkerRootRenderer.prototype.renderComponent = function (componentType) {
	        var result = this._componentRenderers.get(componentType.id);
	        if (lang_1.isBlank(result)) {
	            result = new WebWorkerRenderer(this, componentType);
	            this._componentRenderers.set(componentType.id, result);
	            var id = this._renderStore.allocateId();
	            this._renderStore.store(result, id);
	            this.runOnService('renderComponent', [
	                new client_message_broker_1.FnArg(componentType, core_1.RenderComponentType),
	                new client_message_broker_1.FnArg(result, serializer_1.RenderStoreObject),
	            ]);
	        }
	        return result;
	    };
	    WebWorkerRootRenderer.prototype.runOnService = function (fnName, fnArgs) {
	        var args = new client_message_broker_1.UiArguments(fnName, fnArgs);
	        this._messageBroker.runOnService(args, null);
	    };
	    WebWorkerRootRenderer.prototype.allocateNode = function () {
	        var result = new WebWorkerRenderNode();
	        var id = this._renderStore.allocateId();
	        this._renderStore.store(result, id);
	        return result;
	    };
	    WebWorkerRootRenderer.prototype.allocateId = function () { return this._renderStore.allocateId(); };
	    WebWorkerRootRenderer.prototype.destroyNodes = function (nodes) {
	        for (var i = 0; i < nodes.length; i++) {
	            this._renderStore.remove(nodes[i]);
	        }
	    };
	    /** @nocollapse */
	    WebWorkerRootRenderer.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    WebWorkerRootRenderer.ctorParameters = [
	        { type: client_message_broker_1.ClientMessageBrokerFactory, },
	        { type: message_bus_1.MessageBus, },
	        { type: serializer_1.Serializer, },
	        { type: render_store_1.RenderStore, },
	    ];
	    return WebWorkerRootRenderer;
	}());
	exports.WebWorkerRootRenderer = WebWorkerRootRenderer;
	var WebWorkerRenderer = (function () {
	    function WebWorkerRenderer(_rootRenderer, _componentType) {
	        this._rootRenderer = _rootRenderer;
	        this._componentType = _componentType;
	    }
	    WebWorkerRenderer.prototype._runOnService = function (fnName, fnArgs) {
	        var fnArgsWithRenderer = [new client_message_broker_1.FnArg(this, serializer_1.RenderStoreObject)].concat(fnArgs);
	        this._rootRenderer.runOnService(fnName, fnArgsWithRenderer);
	    };
	    WebWorkerRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
	        var node = this._rootRenderer.allocateNode();
	        this._runOnService('selectRootElement', [new client_message_broker_1.FnArg(selectorOrNode, null), new client_message_broker_1.FnArg(node, serializer_1.RenderStoreObject)]);
	        return node;
	    };
	    WebWorkerRenderer.prototype.createElement = function (parentElement, name, debugInfo) {
	        var node = this._rootRenderer.allocateNode();
	        this._runOnService('createElement', [
	            new client_message_broker_1.FnArg(parentElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(name, null),
	            new client_message_broker_1.FnArg(node, serializer_1.RenderStoreObject)
	        ]);
	        return node;
	    };
	    WebWorkerRenderer.prototype.createViewRoot = function (hostElement) {
	        var viewRoot = this._componentType.encapsulation === core_1.ViewEncapsulation.Native ?
	            this._rootRenderer.allocateNode() :
	            hostElement;
	        this._runOnService('createViewRoot', [new client_message_broker_1.FnArg(hostElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(viewRoot, serializer_1.RenderStoreObject)]);
	        return viewRoot;
	    };
	    WebWorkerRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
	        var node = this._rootRenderer.allocateNode();
	        this._runOnService('createTemplateAnchor', [new client_message_broker_1.FnArg(parentElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(node, serializer_1.RenderStoreObject)]);
	        return node;
	    };
	    WebWorkerRenderer.prototype.createText = function (parentElement, value, debugInfo) {
	        var node = this._rootRenderer.allocateNode();
	        this._runOnService('createText', [
	            new client_message_broker_1.FnArg(parentElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(value, null),
	            new client_message_broker_1.FnArg(node, serializer_1.RenderStoreObject)
	        ]);
	        return node;
	    };
	    WebWorkerRenderer.prototype.projectNodes = function (parentElement, nodes) {
	        this._runOnService('projectNodes', [new client_message_broker_1.FnArg(parentElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(nodes, serializer_1.RenderStoreObject)]);
	    };
	    WebWorkerRenderer.prototype.attachViewAfter = function (node, viewRootNodes) {
	        this._runOnService('attachViewAfter', [new client_message_broker_1.FnArg(node, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(viewRootNodes, serializer_1.RenderStoreObject)]);
	    };
	    WebWorkerRenderer.prototype.detachView = function (viewRootNodes) {
	        this._runOnService('detachView', [new client_message_broker_1.FnArg(viewRootNodes, serializer_1.RenderStoreObject)]);
	    };
	    WebWorkerRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
	        this._runOnService('destroyView', [new client_message_broker_1.FnArg(hostElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(viewAllNodes, serializer_1.RenderStoreObject)]);
	        this._rootRenderer.destroyNodes(viewAllNodes);
	    };
	    WebWorkerRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
	        this._runOnService('setElementProperty', [
	            new client_message_broker_1.FnArg(renderElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(propertyName, null),
	            new client_message_broker_1.FnArg(propertyValue, null)
	        ]);
	    };
	    WebWorkerRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
	        this._runOnService('setElementAttribute', [
	            new client_message_broker_1.FnArg(renderElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(attributeName, null),
	            new client_message_broker_1.FnArg(attributeValue, null)
	        ]);
	    };
	    WebWorkerRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
	        this._runOnService('setBindingDebugInfo', [
	            new client_message_broker_1.FnArg(renderElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(propertyName, null),
	            new client_message_broker_1.FnArg(propertyValue, null)
	        ]);
	    };
	    WebWorkerRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
	        this._runOnService('setElementClass', [
	            new client_message_broker_1.FnArg(renderElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(className, null),
	            new client_message_broker_1.FnArg(isAdd, null)
	        ]);
	    };
	    WebWorkerRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
	        this._runOnService('setElementStyle', [
	            new client_message_broker_1.FnArg(renderElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(styleName, null),
	            new client_message_broker_1.FnArg(styleValue, null)
	        ]);
	    };
	    WebWorkerRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
	        this._runOnService('invokeElementMethod', [
	            new client_message_broker_1.FnArg(renderElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(methodName, null),
	            new client_message_broker_1.FnArg(args, null)
	        ]);
	    };
	    WebWorkerRenderer.prototype.setText = function (renderNode, text) {
	        this._runOnService('setText', [new client_message_broker_1.FnArg(renderNode, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(text, null)]);
	    };
	    WebWorkerRenderer.prototype.listen = function (renderElement, name, callback) {
	        var _this = this;
	        renderElement.events.listen(name, callback);
	        var unlistenCallbackId = this._rootRenderer.allocateId();
	        this._runOnService('listen', [
	            new client_message_broker_1.FnArg(renderElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(name, null),
	            new client_message_broker_1.FnArg(unlistenCallbackId, null)
	        ]);
	        return function () {
	            renderElement.events.unlisten(name, callback);
	            _this._runOnService('listenDone', [new client_message_broker_1.FnArg(unlistenCallbackId, null)]);
	        };
	    };
	    WebWorkerRenderer.prototype.listenGlobal = function (target, name, callback) {
	        var _this = this;
	        this._rootRenderer.globalEvents.listen(eventNameWithTarget(target, name), callback);
	        var unlistenCallbackId = this._rootRenderer.allocateId();
	        this._runOnService('listenGlobal', [new client_message_broker_1.FnArg(target, null), new client_message_broker_1.FnArg(name, null), new client_message_broker_1.FnArg(unlistenCallbackId, null)]);
	        return function () {
	            _this._rootRenderer.globalEvents.unlisten(eventNameWithTarget(target, name), callback);
	            _this._runOnService('listenDone', [new client_message_broker_1.FnArg(unlistenCallbackId, null)]);
	        };
	    };
	    WebWorkerRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
	        // TODO
	        return null;
	    };
	    return WebWorkerRenderer;
	}());
	exports.WebWorkerRenderer = WebWorkerRenderer;
	var NamedEventEmitter = (function () {
	    function NamedEventEmitter() {
	    }
	    NamedEventEmitter.prototype._getListeners = function (eventName) {
	        if (lang_1.isBlank(this._listeners)) {
	            this._listeners = new Map();
	        }
	        var listeners = this._listeners.get(eventName);
	        if (lang_1.isBlank(listeners)) {
	            listeners = [];
	            this._listeners.set(eventName, listeners);
	        }
	        return listeners;
	    };
	    NamedEventEmitter.prototype.listen = function (eventName, callback) { this._getListeners(eventName).push(callback); };
	    NamedEventEmitter.prototype.unlisten = function (eventName, callback) {
	        collection_1.ListWrapper.remove(this._getListeners(eventName), callback);
	    };
	    NamedEventEmitter.prototype.dispatchEvent = function (eventName, event) {
	        var listeners = this._getListeners(eventName);
	        for (var i = 0; i < listeners.length; i++) {
	            listeners[i](event);
	        }
	    };
	    return NamedEventEmitter;
	}());
	exports.NamedEventEmitter = NamedEventEmitter;
	function eventNameWithTarget(target, eventName) {
	    return target + ":" + eventName;
	}
	var WebWorkerRenderNode = (function () {
	    function WebWorkerRenderNode() {
	        this.events = new NamedEventEmitter();
	    }
	    return WebWorkerRenderNode;
	}());
	exports.WebWorkerRenderNode = WebWorkerRenderNode;
	//# sourceMappingURL=renderer.js.map

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var dom_adapter_1 = __webpack_require__(7);
	/**
	 * This adapter is required to log error messages.
	 *
	 * Note: other methods all throw as the DOM is not accessible directly in web worker context.
	 */
	var WorkerDomAdapter = (function (_super) {
	    __extends(WorkerDomAdapter, _super);
	    function WorkerDomAdapter() {
	        _super.apply(this, arguments);
	    }
	    WorkerDomAdapter.makeCurrent = function () { dom_adapter_1.setRootDomAdapter(new WorkerDomAdapter()); };
	    WorkerDomAdapter.prototype.logError = function (error /** TODO #9100 */) {
	        if (console.error) {
	            console.error(error);
	        }
	        else {
	            console.log(error);
	        }
	    };
	    WorkerDomAdapter.prototype.log = function (error /** TODO #9100 */) { console.log(error); };
	    WorkerDomAdapter.prototype.logGroup = function (error /** TODO #9100 */) {
	        if (console.group) {
	            console.group(error);
	            this.logError(error);
	        }
	        else {
	            console.log(error);
	        }
	    };
	    WorkerDomAdapter.prototype.logGroupEnd = function () {
	        if (console.groupEnd) {
	            console.groupEnd();
	        }
	    };
	    WorkerDomAdapter.prototype.hasProperty = function (element /** TODO #9100 */, name) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.setProperty = function (el, name, value) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getProperty = function (el, name) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.invoke = function (el, methodName, args) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getXHR = function () { throw 'not implemented'; };
	    Object.defineProperty(WorkerDomAdapter.prototype, "attrToPropMap", {
	        get: function () { throw 'not implemented'; },
	        set: function (value) { throw 'not implemented'; },
	        enumerable: true,
	        configurable: true
	    });
	    WorkerDomAdapter.prototype.parse = function (templateHtml) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.query = function (selector) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.querySelector = function (el /** TODO #9100 */, selector) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.querySelectorAll = function (el /** TODO #9100 */, selector) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.on = function (el /** TODO #9100 */, evt /** TODO #9100 */, listener /** TODO #9100 */) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.onAndCancel = function (el /** TODO #9100 */, evt /** TODO #9100 */, listener /** TODO #9100 */) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.dispatchEvent = function (el /** TODO #9100 */, evt /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.createMouseEvent = function (eventType /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.createEvent = function (eventType) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.preventDefault = function (evt /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.isPrevented = function (evt /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getInnerHTML = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getTemplateContent = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getOuterHTML = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.nodeName = function (node /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.nodeValue = function (node /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.type = function (node /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.content = function (node /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.firstChild = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.nextSibling = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.parentElement = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.childNodes = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.childNodesAsList = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.clearNodes = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.appendChild = function (el /** TODO #9100 */, node /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.removeChild = function (el /** TODO #9100 */, node /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.replaceChild = function (el /** TODO #9100 */, newNode /** TODO #9100 */, oldNode /** TODO #9100 */) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.remove = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.insertBefore = function (el /** TODO #9100 */, node /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.insertAllBefore = function (el /** TODO #9100 */, nodes /** TODO #9100 */) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.insertAfter = function (el /** TODO #9100 */, node /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.setInnerHTML = function (el /** TODO #9100 */, value /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getText = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.setText = function (el /** TODO #9100 */, value) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getValue = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.setValue = function (el /** TODO #9100 */, value) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getChecked = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.setChecked = function (el /** TODO #9100 */, value) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.createComment = function (text) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.createTemplate = function (html /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.createElement = function (tagName /** TODO #9100 */, doc /** TODO #9100 */) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.createElementNS = function (ns, tagName, doc /** TODO #9100 */) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.createTextNode = function (text, doc /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc /** TODO #9100 */) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.createStyleElement = function (css, doc /** TODO #9100 */) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.createShadowRoot = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getShadowRoot = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getHost = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getDistributedNodes = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.clone = function (node) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getElementsByClassName = function (element /** TODO #9100 */, name) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.getElementsByTagName = function (element /** TODO #9100 */, name) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.classList = function (element /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.addClass = function (element /** TODO #9100 */, className) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.removeClass = function (element /** TODO #9100 */, className) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.hasClass = function (element /** TODO #9100 */, className) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.setStyle = function (element /** TODO #9100 */, styleName, styleValue) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.removeStyle = function (element /** TODO #9100 */, styleName) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getStyle = function (element /** TODO #9100 */, styleName) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.hasStyle = function (element /** TODO #9100 */, styleName, styleValue) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.tagName = function (element /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.attributeMap = function (element /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.hasAttribute = function (element /** TODO #9100 */, attribute) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.hasAttributeNS = function (element /** TODO #9100 */, ns, attribute) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.getAttribute = function (element /** TODO #9100 */, attribute) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.getAttributeNS = function (element /** TODO #9100 */, ns, attribute) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.setAttribute = function (element /** TODO #9100 */, name, value) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.setAttributeNS = function (element /** TODO #9100 */, ns, name, value) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.removeAttribute = function (element /** TODO #9100 */, attribute) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.removeAttributeNS = function (element /** TODO #9100 */, ns, attribute) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.templateAwareRoot = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.createHtmlDocument = function () { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.defaultDoc = function () { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getBoundingClientRect = function (el /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getTitle = function () { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.setTitle = function (newTitle) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.elementMatches = function (n /** TODO #9100 */, selector) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.isTemplateElement = function (el) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.isTextNode = function (node /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.isCommentNode = function (node /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.isElementNode = function (node /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.hasShadowRoot = function (node /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.isShadowRoot = function (node /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.importIntoDoc = function (node) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.adoptNode = function (node) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getHref = function (element /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getEventKey = function (event /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.resolveAndSetHref = function (element /** TODO #9100 */, baseUrl, href) {
	        throw 'not implemented';
	    };
	    WorkerDomAdapter.prototype.supportsDOMEvents = function () { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.supportsNativeShadowDOM = function () { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getGlobalEventTarget = function (target) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getHistory = function () { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getLocation = function () { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getBaseHref = function () { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.resetBaseElement = function () { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getUserAgent = function () { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.setData = function (element /** TODO #9100 */, name, value) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getComputedStyle = function (element /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getData = function (element /** TODO #9100 */, name) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.setGlobalVar = function (name, value) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.requestAnimationFrame = function (callback /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.cancelAnimationFrame = function (id /** TODO #9100 */) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.performanceNow = function () { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getAnimationPrefix = function () { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.getTransitionEnd = function () { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.supportsAnimation = function () { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.supportsWebAnimation = function () { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.supportsCookies = function () { return false; };
	    WorkerDomAdapter.prototype.getCookie = function (name) { throw 'not implemented'; };
	    WorkerDomAdapter.prototype.setCookie = function (name, value) { throw 'not implemented'; };
	    return WorkerDomAdapter;
	}(dom_adapter_1.DomAdapter));
	exports.WorkerDomAdapter = WorkerDomAdapter;
	//# sourceMappingURL=worker_adapter.js.map

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var common_1 = __webpack_require__(28);
	var core_1 = __webpack_require__(1);
	var browser_1 = __webpack_require__(63);
	var lang_1 = __webpack_require__(5);
	var api_1 = __webpack_require__(184);
	var client_message_broker_1 = __webpack_require__(36);
	var message_bus_1 = __webpack_require__(17);
	var post_message_bus_1 = __webpack_require__(185);
	var render_store_1 = __webpack_require__(37);
	var serializer_1 = __webpack_require__(14);
	var service_message_broker_1 = __webpack_require__(38);
	var renderer_1 = __webpack_require__(254);
	var worker_adapter_1 = __webpack_require__(255);
	var PrintLogger = (function () {
	    function PrintLogger() {
	        this.log = lang_1.print;
	        this.logError = lang_1.print;
	        this.logGroup = lang_1.print;
	    }
	    PrintLogger.prototype.logGroupEnd = function () { };
	    return PrintLogger;
	}());
	/**
	 * @deprecated Use `platformWorkerApp()` or create a custom platform factory via
	 * `createPlatformFactory(platformWorkerApp, ...)`
	 */
	exports.WORKER_APP_PLATFORM_PROVIDERS = core_1.PLATFORM_COMMON_PROVIDERS;
	/**
	 * @deprecated Create a module that includes `WorkerAppModule` instead. This is empty for backwards
	 * compatibility,
	 * as all of our bootstrap methods add a module implicitly, i.e. keeping this filled would add the
	 * providers 2x.
	 */
	exports.WORKER_APP_APPLICATION_PROVIDERS = [];
	/**
	 * @experimental
	 */
	exports.platformWorkerApp = core_1.createPlatformFactory(core_1.platformCore, 'workerApp');
	/**
	 * @deprecated Use {@link platformWorkerApp} instead
	 */
	exports.workerAppPlatform = exports.platformWorkerApp;
	function _exceptionHandler() {
	    return new core_1.ExceptionHandler(new PrintLogger());
	}
	// TODO(jteplitz602) remove this and compile with lib.webworker.d.ts (#3492)
	var _postMessage = {
	    postMessage: function (message, transferrables) {
	        postMessage(message, transferrables);
	    }
	};
	function createMessageBus(zone) {
	    var sink = new post_message_bus_1.PostMessageBusSink(_postMessage);
	    var source = new post_message_bus_1.PostMessageBusSource();
	    var bus = new post_message_bus_1.PostMessageBus(sink, source);
	    bus.attachToZone(zone);
	    return bus;
	}
	function setupWebWorker() {
	    worker_adapter_1.WorkerDomAdapter.makeCurrent();
	}
	var WorkerAppModule = (function () {
	    function WorkerAppModule() {
	    }
	    /** @nocollapse */
	    WorkerAppModule.decorators = [
	        { type: core_1.NgModule, args: [{
	                    providers: [
	                        common_1.FORM_PROVIDERS, browser_1.BROWSER_SANITIZATION_PROVIDERS, serializer_1.Serializer,
	                        { provide: client_message_broker_1.ClientMessageBrokerFactory, useClass: client_message_broker_1.ClientMessageBrokerFactory_ },
	                        { provide: service_message_broker_1.ServiceMessageBrokerFactory, useClass: service_message_broker_1.ServiceMessageBrokerFactory_ },
	                        renderer_1.WebWorkerRootRenderer, { provide: core_1.RootRenderer, useExisting: renderer_1.WebWorkerRootRenderer },
	                        { provide: api_1.ON_WEB_WORKER, useValue: true }, render_store_1.RenderStore,
	                        { provide: core_1.ExceptionHandler, useFactory: _exceptionHandler, deps: [] },
	                        { provide: message_bus_1.MessageBus, useFactory: createMessageBus, deps: [core_1.NgZone] },
	                        { provide: core_1.APP_INITIALIZER, useValue: setupWebWorker, multi: true }
	                    ],
	                    exports: [common_1.CommonModule, core_1.ApplicationModule]
	                },] },
	    ];
	    return WorkerAppModule;
	}());
	exports.WorkerAppModule = WorkerAppModule;
	//# sourceMappingURL=worker_app.js.map

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var core_1 = __webpack_require__(1);
	var core_private_1 = __webpack_require__(34);
	var browser_1 = __webpack_require__(63);
	var browser_adapter_1 = __webpack_require__(176);
	var testability_1 = __webpack_require__(177);
	var animation_driver_1 = __webpack_require__(65);
	var dom_adapter_1 = __webpack_require__(7);
	var dom_renderer_1 = __webpack_require__(66);
	var dom_tokens_1 = __webpack_require__(35);
	var dom_events_1 = __webpack_require__(106);
	var event_manager_1 = __webpack_require__(23);
	var hammer_gestures_1 = __webpack_require__(107);
	var key_events_1 = __webpack_require__(179);
	var shared_styles_host_1 = __webpack_require__(67);
	var exceptions_1 = __webpack_require__(19);
	var api_1 = __webpack_require__(184);
	var client_message_broker_1 = __webpack_require__(36);
	var message_bus_1 = __webpack_require__(17);
	var post_message_bus_1 = __webpack_require__(185);
	var render_store_1 = __webpack_require__(37);
	var serializer_1 = __webpack_require__(14);
	var service_message_broker_1 = __webpack_require__(38);
	var renderer_1 = __webpack_require__(251);
	var WebWorkerInstance = (function () {
	    function WebWorkerInstance() {
	    }
	    /** @internal */
	    WebWorkerInstance.prototype.init = function (worker, bus) {
	        this.worker = worker;
	        this.bus = bus;
	    };
	    /** @nocollapse */
	    WebWorkerInstance.decorators = [
	        { type: core_1.Injectable },
	    ];
	    return WebWorkerInstance;
	}());
	exports.WebWorkerInstance = WebWorkerInstance;
	/**
	 * @experimental WebWorker support is currently experimental.
	 */
	exports.WORKER_SCRIPT = new core_1.OpaqueToken('WebWorkerScript');
	/**
	 * A multiple providers used to automatically call the `start()` method after the service is
	 * created.
	 *
	 * TODO(vicb): create an interface for startable services to implement
	 * @experimental WebWorker support is currently experimental.
	 */
	exports.WORKER_UI_STARTABLE_MESSAGING_SERVICE = new core_1.OpaqueToken('WorkerRenderStartableMsgService');
	/**
	 * @experimental WebWorker support is currently experimental.
	 */
	exports._WORKER_UI_PLATFORM_PROVIDERS = [
	    { provide: core_1.NgZone, useFactory: createNgZone, deps: [] },
	    renderer_1.MessageBasedRenderer,
	    { provide: exports.WORKER_UI_STARTABLE_MESSAGING_SERVICE, useExisting: renderer_1.MessageBasedRenderer, multi: true },
	    browser_1.BROWSER_SANITIZATION_PROVIDERS,
	    { provide: core_1.ExceptionHandler, useFactory: _exceptionHandler, deps: [] },
	    { provide: dom_tokens_1.DOCUMENT, useFactory: _document, deps: [] },
	    // TODO(jteplitz602): Investigate if we definitely need EVENT_MANAGER on the render thread
	    // #5298
	    { provide: event_manager_1.EVENT_MANAGER_PLUGINS, useClass: dom_events_1.DomEventsPlugin, multi: true },
	    { provide: event_manager_1.EVENT_MANAGER_PLUGINS, useClass: key_events_1.KeyEventsPlugin, multi: true },
	    { provide: event_manager_1.EVENT_MANAGER_PLUGINS, useClass: hammer_gestures_1.HammerGesturesPlugin, multi: true },
	    { provide: hammer_gestures_1.HAMMER_GESTURE_CONFIG, useClass: hammer_gestures_1.HammerGestureConfig },
	    { provide: dom_renderer_1.DomRootRenderer, useClass: dom_renderer_1.DomRootRenderer_ },
	    { provide: core_1.RootRenderer, useExisting: dom_renderer_1.DomRootRenderer },
	    { provide: shared_styles_host_1.SharedStylesHost, useExisting: shared_styles_host_1.DomSharedStylesHost },
	    { provide: service_message_broker_1.ServiceMessageBrokerFactory, useClass: service_message_broker_1.ServiceMessageBrokerFactory_ },
	    { provide: client_message_broker_1.ClientMessageBrokerFactory, useClass: client_message_broker_1.ClientMessageBrokerFactory_ },
	    { provide: animation_driver_1.AnimationDriver, useFactory: _resolveDefaultAnimationDriver },
	    serializer_1.Serializer,
	    { provide: api_1.ON_WEB_WORKER, useValue: false },
	    render_store_1.RenderStore,
	    shared_styles_host_1.DomSharedStylesHost,
	    core_1.Testability,
	    event_manager_1.EventManager,
	    WebWorkerInstance,
	    {
	        provide: core_1.PLATFORM_INITIALIZER,
	        useFactory: initWebWorkerRenderPlatform,
	        multi: true,
	        deps: [core_1.Injector]
	    },
	    { provide: message_bus_1.MessageBus, useFactory: messageBusFactory, deps: [WebWorkerInstance] }
	];
	/**
	 * * @deprecated Use `platformWorkerUi()` or create a custom platform factory via
	 * `createPlatformFactory(platformWorkerUi, ...)`
	 */
	exports.WORKER_UI_PLATFORM_PROVIDERS = [core_1.PLATFORM_COMMON_PROVIDERS, exports._WORKER_UI_PLATFORM_PROVIDERS];
	/**
	 * @deprecated Worker UI only has a platform but no application
	 */
	exports.WORKER_UI_APPLICATION_PROVIDERS = [];
	function initializeGenericWorkerRenderer(injector) {
	    var bus = injector.get(message_bus_1.MessageBus);
	    var zone = injector.get(core_1.NgZone);
	    bus.attachToZone(zone);
	    // initialize message services after the bus has been created
	    var services = injector.get(exports.WORKER_UI_STARTABLE_MESSAGING_SERVICE);
	    zone.runGuarded(function () { services.forEach(function (svc) { svc.start(); }); });
	}
	function messageBusFactory(instance) {
	    return instance.bus;
	}
	function initWebWorkerRenderPlatform(injector) {
	    return function () {
	        browser_adapter_1.BrowserDomAdapter.makeCurrent();
	        core_private_1.wtfInit();
	        testability_1.BrowserGetTestability.init();
	        var scriptUri;
	        try {
	            scriptUri = injector.get(exports.WORKER_SCRIPT);
	        }
	        catch (e) {
	            throw new exceptions_1.BaseException('You must provide your WebWorker\'s initialization script with the WORKER_SCRIPT token');
	        }
	        var instance = injector.get(WebWorkerInstance);
	        spawnWebWorker(scriptUri, instance);
	        initializeGenericWorkerRenderer(injector);
	    };
	}
	/**
	 * @experimental WebWorker support is currently experimental.
	 */
	exports.platformWorkerUi = core_1.createPlatformFactory(core_1.platformCore, 'workerUi', exports._WORKER_UI_PLATFORM_PROVIDERS);
	/**
	 * @deprecated Use {@link platformWorkerUi} instead
	 */
	exports.workerUiPlatform = exports.platformWorkerUi;
	function _exceptionHandler() {
	    return new core_1.ExceptionHandler(dom_adapter_1.getDOM());
	}
	function _document() {
	    return dom_adapter_1.getDOM().defaultDoc();
	}
	function createNgZone() {
	    return new core_1.NgZone({ enableLongStackTrace: core_1.isDevMode() });
	}
	/**
	 * Spawns a new class and initializes the WebWorkerInstance
	 */
	function spawnWebWorker(uri, instance) {
	    var webWorker = new Worker(uri);
	    var sink = new post_message_bus_1.PostMessageBusSink(webWorker);
	    var source = new post_message_bus_1.PostMessageBusSource(webWorker);
	    var bus = new post_message_bus_1.PostMessageBus(sink, source);
	    instance.init(webWorker, bus);
	}
	function _resolveDefaultAnimationDriver() {
	    // web workers have not been tested or configured to
	    // work with animations just yet...
	    return animation_driver_1.AnimationDriver.NOOP;
	}
	//# sourceMappingURL=worker_render.js.map

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _client = __webpack_require__(187);

	Object.defineProperty(exports, 'HalClient', {
	  enumerable: true,
	  get: function get() {
	    return _client.HalClient;
	  }
	});

	var _error = __webpack_require__(188);

	Object.defineProperty(exports, 'HalError', {
	  enumerable: true,
	  get: function get() {
	    return _error.HalError;
	  }
	});

	var _field = __webpack_require__(110);

	Object.defineProperty(exports, 'HalEmbedded', {
	  enumerable: true,
	  get: function get() {
	    return _field.HalEmbedded;
	  }
	});
	Object.defineProperty(exports, 'HalField', {
	  enumerable: true,
	  get: function get() {
	    return _field.HalField;
	  }
	});
	Object.defineProperty(exports, 'HalFieldSection', {
	  enumerable: true,
	  get: function get() {
	    return _field.HalFieldSection;
	  }
	});
	Object.defineProperty(exports, 'HalLink', {
	  enumerable: true,
	  get: function get() {
	    return _field.HalLink;
	  }
	});

	var _hal = __webpack_require__(259);

	Object.defineProperty(exports, 'HalModule', {
	  enumerable: true,
	  get: function get() {
	    return _hal.HalModule;
	  }
	});

	var _http = __webpack_require__(111);

	Object.defineProperty(exports, 'HalHttp', {
	  enumerable: true,
	  get: function get() {
	    return _http.HalHttp;
	  }
	});

	var _instanceFactory = __webpack_require__(112);

	Object.defineProperty(exports, 'HalInstanceFactory', {
	  enumerable: true,
	  get: function get() {
	    return _instanceFactory.HalInstanceFactory;
	  }
	});

	var _resourceFactory = __webpack_require__(69);

	Object.defineProperty(exports, 'HalResourceFactory', {
	  enumerable: true,
	  get: function get() {
	    return _resourceFactory.HalResourceFactory;
	  }
	});

	var _jsonObject = __webpack_require__(189);

	Object.defineProperty(exports, 'BaseHalJsonObjectSerializerOptions', {
	  enumerable: true,
	  get: function get() {
	    return _jsonObject.BaseHalJsonObjectSerializerOptions;
	  }
	});
	Object.defineProperty(exports, 'HalJsonObjectSerializer', {
	  enumerable: true,
	  get: function get() {
	    return _jsonObject.HalJsonObjectSerializer;
	  }
	});
	Object.defineProperty(exports, 'HalJsonObjectSerializerOptions', {
	  enumerable: true,
	  get: function get() {
	    return _jsonObject.HalJsonObjectSerializerOptions;
	  }
	});

	var _arrayTranslator = __webpack_require__(191);

	Object.defineProperty(exports, 'HalArrayTranslator', {
	  enumerable: true,
	  get: function get() {
	    return _arrayTranslator.HalArrayTranslator;
	  }
	});

	var _defaultObjectTranslator = __webpack_require__(192);

	Object.defineProperty(exports, 'HalDefaultObjectTranslator', {
	  enumerable: true,
	  get: function get() {
	    return _defaultObjectTranslator.HalDefaultObjectTranslator;
	  }
	});

	var keepBabelHappy = false;

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.HalModule = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _core = __webpack_require__(1);

	var _providers = __webpack_require__(261);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = undefined && undefined.__metadata || function (k, v) {
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var HalModule = exports.HalModule = function HalModule() {
	    _classCallCheck(this, HalModule);
	};
	exports.HalModule = HalModule = __decorate([(0, _core.NgModule)({ providers: [_providers.HAL_PROVIDERS] }), __metadata('design:paramtypes', [])], HalModule);

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.HalHttpResource = exports.HalHttpResourceFactory = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _core = __webpack_require__(1);

	var _uriTemplates = __webpack_require__(291);

	var _uriTemplates2 = _interopRequireDefault(_uriTemplates);

	var _http = __webpack_require__(111);

	var _instanceFactory = __webpack_require__(112);

	var _resourceFactory = __webpack_require__(69);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = undefined && undefined.__metadata || function (k, v) {
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};

	/**
	 *
	 */
	var HalHttpResourceFactory = exports.HalHttpResourceFactory = function (_HalResourceFactory) {
	    _inherits(HalHttpResourceFactory, _HalResourceFactory);

	    function HalHttpResourceFactory(halHttp, instanceFactory) {
	        _classCallCheck(this, HalHttpResourceFactory);

	        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(HalHttpResourceFactory).call(this));

	        _this.halHttp = halHttp;
	        _this.instanceFactory = instanceFactory;
	        return _this;
	    }

	    _createClass(HalHttpResourceFactory, [{
	        key: "createResource",
	        value: function createResource(link, typeDescription) {
	            return new HalHttpResource(link, typeDescription, this.halHttp, this.instanceFactory, this);
	        }
	    }]);

	    return HalHttpResourceFactory;
	}(_resourceFactory.HalResourceFactory);
	exports.HalHttpResourceFactory = HalHttpResourceFactory = __decorate([(0, _core.Injectable)(), __metadata('design:paramtypes', [_http.HalHttp, _instanceFactory.HalInstanceFactory])], HalHttpResourceFactory);
	/**
	 *
	 */

	var HalHttpResource = exports.HalHttpResource = function () {
	    function HalHttpResource(link, typeDescription, halHttp, instanceFactory, resourceFactory) {
	        _classCallCheck(this, HalHttpResource);

	        this.link = link;
	        this.typeDescription = typeDescription;
	        this.halHttp = halHttp;
	        this.instanceFactory = instanceFactory;
	        this.resourceFactory = resourceFactory;
	    }

	    _createClass(HalHttpResource, [{
	        key: "get",
	        value: function get(params) {
	            var _this2 = this;

	            return this.halHttp.get(this.filledUrl(params)).map(function (object) {
	                return _this2.instanceFactory.createInstance(object, _this2.typeDescription, _this2.resourceFactory);
	            });
	        }
	    }, {
	        key: "delete",
	        value: function _delete(params) {
	            return this.halHttp.delete(this.filledUrl(params));
	        }
	    }, {
	        key: "post",
	        value: function post(body, params, typeDescription) {
	            // TODO: Implement this method.
	            return undefined;
	        }
	    }, {
	        key: "put",
	        value: function put(body, params) {
	            // TODO: Implement this method.
	            return undefined;
	        }
	    }, {
	        key: "filledUrl",
	        value: function filledUrl(params) {
	            var template = new _uriTemplates2.default(this.link.href);
	            return template.fill(params);
	        }
	    }]);

	    return HalHttpResource;
	}();

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.HAL_PROVIDERS = undefined;

	var _core = __webpack_require__(1);

	var _client = __webpack_require__(187);

	var _http = __webpack_require__(111);

	var _httpResourceFactory = __webpack_require__(260);

	var _instanceFactory = __webpack_require__(112);

	var _object = __webpack_require__(39);

	var _resourceFactory = __webpack_require__(69);

	var _translator = __webpack_require__(190);

	var _jsonObject = __webpack_require__(189);

	var _arrayTranslator = __webpack_require__(191);

	var _defaultObjectTranslator = __webpack_require__(192);

	var HAL_PROVIDERS = exports.HAL_PROVIDERS = [_client.HalClient, _http.HalHttp, _instanceFactory.HalInstanceFactory, (0, _core.provide)(_object.HalObjectSerializer, { useClass: _jsonObject.HalJsonObjectSerializer }), (0, _core.provide)(_jsonObject.HalJsonObjectSerializerOptions, { useClass: _jsonObject.BaseHalJsonObjectSerializerOptions }), (0, _core.provide)(_resourceFactory.HalResourceFactory, { useClass: _httpResourceFactory.HalHttpResourceFactory }), (0, _core.provide)(_translator.HAL_COLLECTION_TRANSLATORS, { useClass: _arrayTranslator.HalArrayTranslator, multi: true }), (0, _core.provide)(_translator.HAL_OBJECT_TRANSLATORS, { useClass: _defaultObjectTranslator.HalDefaultObjectTranslator, multi: true })];

/***/ },
/* 262 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = applyDecorators;
	var defineProperty = Object.defineProperty;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	function applyDecorators(Class, props) {
	  var prototype = Class.prototype;

	  for (var key in props) {
	    var decorators = props[key];

	    for (var i = 0, l = decorators.length; i < l; i++) {
	      var decorator = decorators[i];

	      defineProperty(prototype, key, decorator(prototype, key, getOwnPropertyDescriptor(prototype, key)));
	    }
	  }

	  return Class;
	}

	module.exports = exports["default"];

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = autobind;

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

	var _privateUtils = __webpack_require__(9);

	var defineProperty = Object.defineProperty;

	function bind(fn, context) {
	  if (fn.bind) {
	    return fn.bind(context);
	  } else {
	    return function __autobind__() {
	      return fn.apply(context, arguments);
	    };
	  }
	}

	var mapStore = undefined;

	function getBoundSuper(obj, fn) {
	  if (typeof WeakMap === 'undefined') {
	    throw new Error('Using @autobind on ' + fn.name + '() requires WeakMap support due to its use of super.' + fn.name + '()\n      See https://github.com/jayphelps/core-decorators.js/issues/20');
	  }

	  if (!mapStore) {
	    mapStore = new WeakMap();
	  }

	  if (mapStore.has(obj) === false) {
	    mapStore.set(obj, new WeakMap());
	  }

	  var superStore = mapStore.get(obj);

	  if (superStore.has(fn) === false) {
	    superStore.set(fn, bind(fn, obj));
	  }

	  return superStore.get(fn);
	}

	function autobindClass(klass) {
	  var descs = (0, _privateUtils.getOwnPropertyDescriptors)(klass.prototype);

	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = (0, _privateUtils.getOwnKeys)(descs)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var key = _step.value;

	      var desc = descs[key];
	      if (typeof desc.value !== 'function' || key === 'constructor') {
	        continue;
	      }

	      defineProperty(klass.prototype, key, autobindMethod(klass.prototype, key, desc));
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator['return']) {
	        _iterator['return']();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	}

	function autobindMethod(target, key, _ref) {
	  var fn = _ref.value;
	  var configurable = _ref.configurable;
	  var enumerable = _ref.enumerable;

	  if (typeof fn !== 'function') {
	    throw new SyntaxError('@autobind can only be used on functions, not: ' + fn);
	  }

	  var constructor = target.constructor;

	  return {
	    configurable: configurable,
	    enumerable: enumerable,

	    get: function get() {
	      // Class.prototype.key lookup
	      // Someone accesses the property directly on the prototype on which it is
	      // actually defined on, i.e. Class.prototype.hasOwnProperty(key)
	      if (this === target) {
	        return fn;
	      }

	      // Class.prototype.key lookup
	      // Someone accesses the property directly on a prototype but it was found
	      // up the chain, not defined directly on it
	      // i.e. Class.prototype.hasOwnProperty(key) == false && key in Class.prototype
	      if (this.constructor !== constructor && Object.getPrototypeOf(this).constructor === constructor) {
	        return fn;
	      }

	      // Autobound method calling super.sameMethod() which is also autobound and so on.
	      if (this.constructor !== constructor && key in this.constructor.prototype) {
	        return getBoundSuper(this, fn);
	      }

	      var boundFn = bind(fn, this);

	      defineProperty(this, key, {
	        configurable: true,
	        writable: true,
	        // NOT enumerable when it's a bound method
	        enumerable: false,
	        value: boundFn
	      });

	      return boundFn;
	    },
	    set: (0, _privateUtils.createDefaultSetter)(key)
	  };
	}

	function handle(args) {
	  if (args.length === 1) {
	    return autobindClass.apply(undefined, _toConsumableArray(args));
	  } else {
	    return autobindMethod.apply(undefined, _toConsumableArray(args));
	  }
	}

	function autobind() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  if (args.length === 0) {
	    return function () {
	      return handle(arguments);
	    };
	  } else {
	    return handle(args);
	  }
	}

	module.exports = exports['default'];

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * core-decorators.js
	 * (c) 2016 Jay Phelps and contributors
	 * MIT Licensed
	 * https://github.com/jayphelps/core-decorators.js
	 * @license
	 */
	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequire(obj) { return obj && obj.__esModule ? obj['default'] : obj; }

	var _override = __webpack_require__(274);

	exports.override = _interopRequire(_override);

	var _deprecate = __webpack_require__(267);

	exports.deprecate = _interopRequire(_deprecate);
	exports.deprecated = _interopRequire(_deprecate);

	var _suppressWarnings = __webpack_require__(276);

	exports.suppressWarnings = _interopRequire(_suppressWarnings);

	var _memoize = __webpack_require__(270);

	exports.memoize = _interopRequire(_memoize);

	var _autobind = __webpack_require__(263);

	exports.autobind = _interopRequire(_autobind);

	var _readonly = __webpack_require__(275);

	exports.readonly = _interopRequire(_readonly);

	var _enumerable = __webpack_require__(268);

	exports.enumerable = _interopRequire(_enumerable);

	var _nonenumerable = __webpack_require__(273);

	exports.nonenumerable = _interopRequire(_nonenumerable);

	var _nonconfigurable = __webpack_require__(272);

	exports.nonconfigurable = _interopRequire(_nonconfigurable);

	var _debounce = __webpack_require__(265);

	exports.debounce = _interopRequire(_debounce);

	var _throttle = __webpack_require__(277);

	exports.throttle = _interopRequire(_throttle);

	var _decorate = __webpack_require__(266);

	exports.decorate = _interopRequire(_decorate);

	var _mixin = __webpack_require__(271);

	exports.mixin = _interopRequire(_mixin);
	exports.mixins = _interopRequire(_mixin);

	var _lazyInitialize = __webpack_require__(193);

	exports.lazyInitialize = _interopRequire(_lazyInitialize);

	var _time = __webpack_require__(278);

	exports.time = _interopRequire(_time);

	var _extendDescriptor = __webpack_require__(269);

	exports.extendDescriptor = _interopRequire(_extendDescriptor);

	// Helper to apply decorators to a class without transpiler support

	var _applyDecorators = __webpack_require__(262);

	exports.applyDecorators = _interopRequire(_applyDecorators);

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports['default'] = debounce;

	var _privateUtils = __webpack_require__(9);

	var DEFAULT_TIMEOUT = 300;

	function handleDescriptor(target, key, descriptor, _ref) {
	  var _ref2 = _slicedToArray(_ref, 2);

	  var _ref2$0 = _ref2[0];
	  var wait = _ref2$0 === undefined ? DEFAULT_TIMEOUT : _ref2$0;
	  var _ref2$1 = _ref2[1];
	  var immediate = _ref2$1 === undefined ? false : _ref2$1;

	  var callback = descriptor.value;

	  if (typeof callback !== 'function') {
	    throw new SyntaxError('Only functions can be debounced');
	  }

	  return _extends({}, descriptor, {
	    value: function value() {
	      var _this = this;

	      var _metaFor = (0, _privateUtils.metaFor)(this);

	      var debounceTimeoutIds = _metaFor.debounceTimeoutIds;

	      var timeout = debounceTimeoutIds[key];
	      var callNow = immediate && !timeout;
	      var args = arguments;

	      clearTimeout(timeout);

	      debounceTimeoutIds[key] = setTimeout(function () {
	        delete debounceTimeoutIds[key];
	        if (!immediate) {
	          callback.apply(_this, args);
	        }
	      }, wait);

	      if (callNow) {
	        callback.apply(this, args);
	      }
	    }
	  });
	}

	function debounce() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return (0, _privateUtils.decorate)(handleDescriptor, args);
	}

	module.exports = exports['default'];

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = decorate;

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

	function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

	var _privateUtils = __webpack_require__(9);

	function handleDescriptor(target, key, descriptor, _ref) {
	  var _ref2 = _toArray(_ref);

	  var decorator = _ref2[0];

	  var args = _ref2.slice(1);

	  var configurable = descriptor.configurable;
	  var enumerable = descriptor.enumerable;
	  var writable = descriptor.writable;

	  var originalGet = descriptor.get;
	  var originalSet = descriptor.set;
	  var originalValue = descriptor.value;
	  var isGetter = !!originalGet;

	  return {
	    configurable: configurable,
	    enumerable: enumerable,
	    get: function get() {
	      var fn = isGetter ? originalGet.call(this) : originalValue;
	      var value = decorator.call.apply(decorator, [this, fn].concat(_toConsumableArray(args)));

	      if (isGetter) {
	        return value;
	      } else {
	        var desc = {
	          configurable: configurable,
	          enumerable: enumerable
	        };

	        desc.value = value;
	        desc.writable = writable;

	        Object.defineProperty(this, key, desc);

	        return value;
	      }
	    },
	    set: isGetter ? originalSet : (0, _privateUtils.createDefaultSetter)()
	  };
	}

	function decorate() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return (0, _privateUtils.decorate)(handleDescriptor, args);
	}

	module.exports = exports['default'];

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports['default'] = deprecate;

	var _privateUtils = __webpack_require__(9);

	var DEFAULT_MSG = 'This function will be removed in future versions.';

	function handleDescriptor(target, key, descriptor, _ref) {
	  var _ref2 = _slicedToArray(_ref, 2);

	  var _ref2$0 = _ref2[0];
	  var msg = _ref2$0 === undefined ? DEFAULT_MSG : _ref2$0;
	  var _ref2$1 = _ref2[1];
	  var options = _ref2$1 === undefined ? {} : _ref2$1;

	  if (typeof descriptor.value !== 'function') {
	    throw new SyntaxError('Only functions can be marked as deprecated');
	  }

	  var methodSignature = target.constructor.name + '#' + key;

	  if (options.url) {
	    msg += '\n\n    See ' + options.url + ' for more details.\n\n';
	  }

	  return _extends({}, descriptor, {
	    value: function deprecationWrapper() {
	      console.warn('DEPRECATION ' + methodSignature + ': ' + msg);
	      return descriptor.value.apply(this, arguments);
	    }
	  });
	}

	function deprecate() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return (0, _privateUtils.decorate)(handleDescriptor, args);
	}

	module.exports = exports['default'];

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = enumerable;

	var _privateUtils = __webpack_require__(9);

	function handleDescriptor(target, key, descriptor) {
	  descriptor.enumerable = true;
	  return descriptor;
	}

	function enumerable() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return (0, _privateUtils.decorate)(handleDescriptor, args);
	}

	module.exports = exports['default'];

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports['default'] = extendDescriptor;

	var _privateUtils = __webpack_require__(9);

	function handleDescriptor(target, key, descriptor) {
	  var superKlass = Object.getPrototypeOf(target);
	  var superDesc = Object.getOwnPropertyDescriptor(superKlass, key);

	  return _extends({}, superDesc, {
	    value: descriptor.value,
	    initializer: descriptor.initializer,
	    get: descriptor.get || superDesc.get,
	    set: descriptor.set || superDesc.set
	  });
	}

	function extendDescriptor() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return (0, _privateUtils.decorate)(handleDescriptor, args);
	}

	module.exports = exports['default'];

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports['default'] = memoize;

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var _privateUtils = __webpack_require__(9);

	function toObject(cache, value) {
	  if (value === Object(value)) {
	    return value;
	  }
	  return cache[value] || (cache[value] = {});
	}

	function applyAndCache(context, fn, args, cache, signature) {
	  var ret = fn.apply(context, args);
	  cache[signature] = ret;
	  return ret;
	}

	function metaForDescriptor(descriptor) {
	  var fn = undefined,
	      wrapKey = undefined;

	  // This is ugly code, but way faster than other
	  // ways I tried that *looked* pretty

	  if (descriptor.value) {
	    fn = descriptor.value;
	    wrapKey = 'value';
	  } else if (descriptor.get) {
	    fn = descriptor.get;
	    wrapKey = 'get';
	  } else if (descriptor.set) {
	    fn = descriptor.set;
	    wrapKey = 'set';
	  }

	  return { fn: fn, wrapKey: wrapKey };
	}

	function handleDescriptor(target, key, descriptor) {
	  console.warn('DEPRECATION: @memoize is deprecated and will be removed shortly. Use @decorate with lodash\'s memoize helper.\n\n  https://github.com/jayphelps/core-decorators.js#decorate');

	  var _metaForDescriptor = metaForDescriptor(descriptor);

	  var fn = _metaForDescriptor.fn;
	  var wrapKey = _metaForDescriptor.wrapKey;

	  var argumentCache = new WeakMap();
	  var signatureCache = Object.create(null);
	  var primativeRefCache = Object.create(null);
	  var argumentIdCounter = 0;

	  return _extends({}, descriptor, _defineProperty({}, wrapKey, function memoizeWrapper() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    var signature = '0';

	    for (var i = 0, l = args.length; i < l; i++) {
	      var arg = args[i];
	      var argRef = toObject(primativeRefCache, arg);
	      var argKey = argumentCache.get(argRef);

	      if (argKey === undefined) {
	        argKey = ++argumentIdCounter;
	        argumentCache.set(argRef, argKey);
	      }

	      signature += argKey;
	    }

	    return signatureCache[signature] || applyAndCache(this, fn, arguments, signatureCache, signature);
	  }));
	}

	function memoize() {
	  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	    args[_key2] = arguments[_key2];
	  }

	  return (0, _privateUtils.decorate)(handleDescriptor, args);
	}

	module.exports = exports['default'];

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = mixin;

	var _privateUtils = __webpack_require__(9);

	var defineProperty = Object.defineProperty;
	var getPrototypeOf = Object.getPrototypeOf;

	function buggySymbol(symbol) {
	  return Object.prototype.toString.call(symbol) === '[object Symbol]' && typeof symbol === 'object';
	}

	function hasProperty(prop, obj) {
	  // We have to traverse manually prototypes' chain for polyfilled ES6 Symbols
	  // like "in" operator does.
	  // I.e.: Babel 5 Symbol polyfill stores every created symbol in Object.prototype.
	  // That's why we cannot use construction like "prop in obj" to check, if needed
	  // prop actually exists in given object/prototypes' chain.
	  if (buggySymbol(prop)) {
	    do {
	      if (obj === Object.prototype) {
	        // Polyfill assigns undefined as value for stored symbol key.
	        // We can assume in this special case if there is nothing assigned it doesn't exist.
	        return typeof obj[prop] !== 'undefined';
	      }
	      if (obj.hasOwnProperty(prop)) {
	        return true;
	      }
	    } while (obj = getPrototypeOf(obj));
	    return false;
	  } else {
	    return prop in obj;
	  }
	}

	function handleClass(target, mixins) {
	  if (!mixins.length) {
	    throw new SyntaxError('@mixin() class ' + target.name + ' requires at least one mixin as an argument');
	  }

	  for (var i = 0, l = mixins.length; i < l; i++) {
	    var descs = (0, _privateUtils.getOwnPropertyDescriptors)(mixins[i]);

	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = (0, _privateUtils.getOwnKeys)(descs)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var key = _step.value;

	        if (!hasProperty(key, target.prototype)) {
	          defineProperty(target.prototype, key, descs[key]);
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator['return']) {
	          _iterator['return']();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  }
	}

	function mixin() {
	  for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
	    mixins[_key] = arguments[_key];
	  }

	  if (typeof mixins[0] === 'function') {
	    return handleClass(mixins[0], []);
	  } else {
	    return function (target) {
	      return handleClass(target, mixins);
	    };
	  }
	}

	module.exports = exports['default'];

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = nonconfigurable;

	var _privateUtils = __webpack_require__(9);

	function handleDescriptor(target, key, descriptor) {
	  descriptor.configurable = false;
	  return descriptor;
	}

	function nonconfigurable() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return (0, _privateUtils.decorate)(handleDescriptor, args);
	}

	module.exports = exports['default'];

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = nonenumerable;

	var _privateUtils = __webpack_require__(9);

	function handleDescriptor(target, key, descriptor) {
	  descriptor.enumerable = false;
	  return descriptor;
	}

	function nonenumerable() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return (0, _privateUtils.decorate)(handleDescriptor, args);
	}

	module.exports = exports['default'];

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	exports['default'] = override;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _privateUtils = __webpack_require__(9);

	var GENERIC_FUNCTION_ERROR = '{child} does not properly override {parent}';
	var FUNCTION_REGEXP = /^function ([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?(\([^\)]*\))[\s\S]+$/;

	var SyntaxErrorReporter = (function () {
	  _createClass(SyntaxErrorReporter, [{
	    key: '_getTopic',
	    value: function _getTopic(descriptor) {
	      if (descriptor === undefined) {
	        return null;
	      }

	      if ('value' in descriptor) {
	        return descriptor.value;
	      }

	      if ('get' in descriptor) {
	        return descriptor.get;
	      }

	      if ('set' in descriptor) {
	        return descriptor.set;
	      }
	    }
	  }, {
	    key: '_extractTopicSignature',
	    value: function _extractTopicSignature(topic) {
	      switch (typeof topic) {
	        case 'function':
	          return this._extractFunctionSignature(topic);
	        default:
	          return this.key;
	      }
	    }
	  }, {
	    key: '_extractFunctionSignature',
	    value: function _extractFunctionSignature(fn) {
	      var _this = this;

	      return fn.toString().replace(FUNCTION_REGEXP, function (match, name, params) {
	        if (name === undefined) name = _this.key;
	        return name + params;
	      });
	    }
	  }, {
	    key: 'key',
	    get: function get() {
	      return this.childDescriptor.key;
	    }
	  }, {
	    key: 'parentNotation',
	    get: function get() {
	      return this.parentKlass.constructor.name + '#' + this.parentPropertySignature;
	    }
	  }, {
	    key: 'childNotation',
	    get: function get() {
	      return this.childKlass.constructor.name + '#' + this.childPropertySignature;
	    }
	  }, {
	    key: 'parentTopic',
	    get: function get() {
	      return this._getTopic(this.parentDescriptor);
	    }
	  }, {
	    key: 'childTopic',
	    get: function get() {
	      return this._getTopic(this.childDescriptor);
	    }
	  }, {
	    key: 'parentPropertySignature',
	    get: function get() {
	      return this._extractTopicSignature(this.parentTopic);
	    }
	  }, {
	    key: 'childPropertySignature',
	    get: function get() {
	      return this._extractTopicSignature(this.childTopic);
	    }
	  }]);

	  function SyntaxErrorReporter(parentKlass, childKlass, parentDescriptor, childDescriptor) {
	    _classCallCheck(this, SyntaxErrorReporter);

	    this.parentKlass = parentKlass;
	    this.childKlass = childKlass;
	    this.parentDescriptor = parentDescriptor;
	    this.childDescriptor = childDescriptor;
	  }

	  _createClass(SyntaxErrorReporter, [{
	    key: 'assert',
	    value: function assert(condition) {
	      var msg = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	      if (condition !== true) {
	        this.error(GENERIC_FUNCTION_ERROR + msg);
	      }
	    }
	  }, {
	    key: 'error',
	    value: function error(msg) {
	      var _this2 = this;

	      msg = msg
	      // Replace lazily, because they actually might not
	      // be available in all cases
	      .replace('{parent}', function (m) {
	        return _this2.parentNotation;
	      }).replace('{child}', function (m) {
	        return _this2.childNotation;
	      });
	      throw new SyntaxError(msg);
	    }
	  }]);

	  return SyntaxErrorReporter;
	})();

	function getDescriptorType(descriptor) {
	  if (descriptor.hasOwnProperty('value')) {
	    return 'data';
	  }

	  if (descriptor.hasOwnProperty('get') || descriptor.hasOwnProperty('set')) {
	    return 'accessor';
	  }

	  // If none of them exist, browsers treat it as
	  // a data descriptor with a value of `undefined`
	  return 'data';
	}

	function checkFunctionSignatures(parent, child, reporter) {
	  reporter.assert(parent.length === child.length);
	}

	function checkDataDescriptors(parent, child, reporter) {
	  var parentValueType = typeof parent.value;
	  var childValueType = typeof child.value;

	  if (parentValueType === 'undefined' && childValueType === 'undefined') {
	    // class properties can be any expression, which isn't ran until the
	    // the instance is created, so we can't reliably get type information
	    // for them yet (per spec). Perhaps when Babel includes flow-type info
	    // in runtime? Tried regex solutions, but super hacky and only feasible
	    // on primitives, which is confusing for usage...
	    reporter.error('descriptor values are both undefined. (class properties are are not currently supported)\'');
	  }

	  if (parentValueType !== childValueType) {
	    var isFunctionOverUndefined = childValueType === 'function' && parentValueType === undefined;
	    // Even though we don't support class properties, this
	    // will still handle more than just functions, just in case.
	    // Shadowing an undefined value is an error if the inherited
	    // value was undefined (usually a class property, not a method)
	    if (isFunctionOverUndefined || parentValueType !== undefined) {
	      reporter.error('value types do not match. {parent} is "' + parentValueType + '", {child} is "' + childValueType + '"');
	    }
	  }

	  // Switch, in preparation for supporting more types
	  switch (childValueType) {
	    case 'function':
	      checkFunctionSignatures(parent.value, child.value, reporter);
	      break;

	    default:
	      reporter.error('Unexpected error. Please file a bug with: {parent} is "' + parentValueType + '", {child} is "' + childValueType + '"');
	      break;
	  }
	}

	function checkAccessorDescriptors(parent, child, reporter) {
	  var parentHasGetter = typeof parent.get === 'function';
	  var childHasGetter = typeof child.get === 'function';
	  var parentHasSetter = typeof parent.set === 'function';
	  var childHasSetter = typeof child.set === 'function';

	  if (parentHasGetter || childHasGetter) {
	    if (!parentHasGetter && parentHasSetter) {
	      reporter.error('{parent} is setter but {child} is getter');
	    }

	    if (!childHasGetter && childHasSetter) {
	      reporter.error('{parent} is getter but {child} is setter');
	    }

	    checkFunctionSignatures(parent.get, child.get, reporter);
	  }

	  if (parentHasSetter || childHasSetter) {
	    if (!parentHasSetter && parentHasGetter) {
	      reporter.error('{parent} is getter but {child} is setter');
	    }

	    if (!childHasSetter && childHasGetter) {
	      reporter.error('{parent} is setter but {child} is getter');
	    }

	    checkFunctionSignatures(parent.set, child.set, reporter);
	  }
	}

	function checkDescriptors(parent, child, reporter) {
	  var parentType = getDescriptorType(parent);
	  var childType = getDescriptorType(child);

	  if (parentType !== childType) {
	    reporter.error('descriptor types do not match. {parent} is "' + parentType + '", {child} is "' + childType + '"');
	  }

	  switch (childType) {
	    case 'data':
	      checkDataDescriptors(parent, child, reporter);
	      break;

	    case 'accessor':
	      checkAccessorDescriptors(parent, child, reporter);
	      break;
	  }
	}

	var suggestionTransforms = [function (key) {
	  return key.toLowerCase();
	}, function (key) {
	  return key.toUpperCase();
	}, function (key) {
	  return key + 's';
	}, function (key) {
	  return key.slice(0, -1);
	}, function (key) {
	  return key.slice(1, key.length);
	}];

	function findPossibleAlternatives(superKlass, key) {
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = suggestionTransforms[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var fn = _step.value;

	      var suggestion = fn(key);
	      if (suggestion in superKlass) {
	        return suggestion;
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator['return']) {
	        _iterator['return']();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  return null;
	}

	function handleDescriptor(target, key, descriptor) {
	  descriptor.key = key;
	  var superKlass = Object.getPrototypeOf(target);
	  var superDescriptor = Object.getOwnPropertyDescriptor(superKlass, key);
	  var reporter = new SyntaxErrorReporter(superKlass, target, superDescriptor, descriptor);

	  if (superDescriptor === undefined) {
	    var suggestedKey = findPossibleAlternatives(superKlass, key);
	    var suggestion = suggestedKey ? '\n\n  Did you mean "' + suggestedKey + '"?' : '';
	    reporter.error('No descriptor matching {child} was found on the prototype chain.' + suggestion);
	  }

	  checkDescriptors(superDescriptor, descriptor, reporter);

	  return descriptor;
	}

	function override() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return (0, _privateUtils.decorate)(handleDescriptor, args);
	}

	module.exports = exports['default'];

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = readonly;

	var _privateUtils = __webpack_require__(9);

	function handleDescriptor(target, key, descriptor) {
	  descriptor.writable = false;
	  return descriptor;
	}

	function readonly() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return (0, _privateUtils.decorate)(handleDescriptor, args);
	}

	module.exports = exports['default'];

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports['default'] = suppressWarnings;

	var _privateUtils = __webpack_require__(9);

	function suppressedWarningNoop() {
	  // Warnings are currently suppressed via @suppressWarnings
	}

	function applyWithoutWarnings(context, fn, args) {
	  var nativeWarn = console.warn;
	  console.warn = suppressedWarningNoop;
	  var ret = fn.apply(context, args);
	  console.warn = nativeWarn;
	  return ret;
	}

	function handleDescriptor(target, key, descriptor) {
	  return _extends({}, descriptor, {
	    value: function suppressWarningsWrapper() {
	      return applyWithoutWarnings(this, descriptor.value, arguments);
	    }
	  });
	}

	function suppressWarnings() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return (0, _privateUtils.decorate)(handleDescriptor, args);
	}

	module.exports = exports['default'];

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports['default'] = throttle;

	var _privateUtils = __webpack_require__(9);

	var DEFAULT_TIMEOUT = 300;

	function handleDescriptor(target, key, descriptor, _ref) {
	  var _ref2 = _slicedToArray(_ref, 2);

	  var _ref2$0 = _ref2[0];
	  var wait = _ref2$0 === undefined ? DEFAULT_TIMEOUT : _ref2$0;
	  var _ref2$1 = _ref2[1];
	  var options = _ref2$1 === undefined ? {} : _ref2$1;

	  var callback = descriptor.value;

	  if (typeof callback !== 'function') {
	    throw new SyntaxError('Only functions can be throttled');
	  }

	  if (options.leading !== false) {
	    options.leading = true;
	  }

	  if (options.trailing !== false) {
	    options.trailing = true;
	  }

	  return _extends({}, descriptor, {
	    value: function value() {
	      var _this = this;

	      var _metaFor = (0, _privateUtils.metaFor)(this);

	      var throttleTimeoutIds = _metaFor.throttleTimeoutIds;
	      var throttlePreviousTimestamps = _metaFor.throttlePreviousTimestamps;

	      var timeout = throttleTimeoutIds[key];
	      // last execute timestamp
	      var previous = throttlePreviousTimestamps[key] || 0;
	      var now = Date.now();
	      var args = arguments;

	      // if first be called and disable the execution on the leading edge
	      // set last execute timestamp to now
	      if (!previous && options.leading === false) {
	        previous = now;
	      }

	      var remaining = wait - (now - previous);

	      if (remaining <= 0) {
	        clearTimeout(timeout);
	        delete throttleTimeoutIds[key];
	        throttlePreviousTimestamps[key] = now;
	        callback.apply(this, args);
	      } else if (!timeout && options.trailing !== false) {
	        throttleTimeoutIds[key] = setTimeout(function () {
	          throttlePreviousTimestamps[key] = options.leading === false ? 0 : Date.now();
	          delete throttleTimeoutIds[key];
	          callback.apply(_this, args);
	        }, remaining);
	      }
	    }
	  });
	}

	function throttle() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return (0, _privateUtils.decorate)(handleDescriptor, args);
	}

	module.exports = exports['default'];

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports['default'] = time;

	var _privateUtils = __webpack_require__(9);

	var labels = {};

	// Exported for mocking in tests
	var defaultConsole = {
	  time: console.time ? console.time.bind(console) : function (label) {
	    labels[label] = new Date();
	  },
	  timeEnd: console.timeEnd ? console.timeEnd.bind(console) : function (label) {
	    var timeNow = new Date();
	    var timeTaken = timeNow - labels[label];
	    delete labels[label];
	    console.log(label + ': ' + timeTaken + 'ms');
	  }
	};

	exports.defaultConsole = defaultConsole;
	var count = 0;

	function handleDescriptor(target, key, descriptor, _ref) {
	  var _ref2 = _slicedToArray(_ref, 2);

	  var _ref2$0 = _ref2[0];
	  var prefix = _ref2$0 === undefined ? null : _ref2$0;
	  var _ref2$1 = _ref2[1];
	  var console = _ref2$1 === undefined ? defaultConsole : _ref2$1;

	  var fn = descriptor.value;

	  if (prefix === null) {
	    prefix = target.constructor.name + '.' + key;
	  }

	  if (typeof fn !== 'function') {
	    throw new SyntaxError('@time can only be used on functions, not: ' + fn);
	  }

	  return _extends({}, descriptor, {
	    value: function value() {
	      var label = prefix + '-' + count;
	      count++;
	      console.time(label);

	      try {
	        return fn.apply(this, arguments);
	      } finally {
	        console.timeEnd(label);
	      }
	    }
	  });
	}

	function time() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return (0, _privateUtils.decorate)(handleDescriptor, args);
	}

/***/ },
/* 279 */
/***/ function(module, exports) {

	"use strict";
	exports.empty = {
	    isUnsubscribed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};
	//# sourceMappingURL=Observer.js.map

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(113);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubjectSubscription = (function (_super) {
	    __extends(SubjectSubscription, _super);
	    function SubjectSubscription(subject, observer) {
	        _super.call(this);
	        this.subject = subject;
	        this.observer = observer;
	        this.isUnsubscribed = false;
	    }
	    SubjectSubscription.prototype.unsubscribe = function () {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isUnsubscribed = true;
	        var subject = this.subject;
	        var observers = subject.observers;
	        this.subject = null;
	        if (!observers || observers.length === 0 || subject.isUnsubscribed) {
	            return;
	        }
	        var subscriberIndex = observers.indexOf(this.observer);
	        if (subscriberIndex !== -1) {
	            observers.splice(subscriberIndex, 1);
	        }
	    };
	    return SubjectSubscription;
	}(Subscription_1.Subscription));
	exports.SubjectSubscription = SubjectSubscription;
	//# sourceMappingURL=SubjectSubscription.js.map

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(40);
	var Observable_1 = __webpack_require__(24);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var PromiseObservable = (function (_super) {
	    __extends(PromiseObservable, _super);
	    function PromiseObservable(promise, scheduler) {
	        if (scheduler === void 0) { scheduler = null; }
	        _super.call(this);
	        this.promise = promise;
	        this.scheduler = scheduler;
	    }
	    /**
	     * @param promise
	     * @param scheduler
	     * @return {PromiseObservable}
	     * @static true
	     * @name fromPromise
	     * @owner Observable
	     */
	    PromiseObservable.create = function (promise, scheduler) {
	        if (scheduler === void 0) { scheduler = null; }
	        return new PromiseObservable(promise, scheduler);
	    };
	    PromiseObservable.prototype._subscribe = function (subscriber) {
	        var _this = this;
	        var promise = this.promise;
	        var scheduler = this.scheduler;
	        if (scheduler == null) {
	            if (this._isScalar) {
	                if (!subscriber.isUnsubscribed) {
	                    subscriber.next(this.value);
	                    subscriber.complete();
	                }
	            }
	            else {
	                promise.then(function (value) {
	                    _this.value = value;
	                    _this._isScalar = true;
	                    if (!subscriber.isUnsubscribed) {
	                        subscriber.next(value);
	                        subscriber.complete();
	                    }
	                }, function (err) {
	                    if (!subscriber.isUnsubscribed) {
	                        subscriber.error(err);
	                    }
	                })
	                    .then(null, function (err) {
	                    // escape the promise trap, throw unhandled errors
	                    root_1.root.setTimeout(function () { throw err; });
	                });
	            }
	        }
	        else {
	            if (this._isScalar) {
	                if (!subscriber.isUnsubscribed) {
	                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
	                }
	            }
	            else {
	                promise.then(function (value) {
	                    _this.value = value;
	                    _this._isScalar = true;
	                    if (!subscriber.isUnsubscribed) {
	                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
	                    }
	                }, function (err) {
	                    if (!subscriber.isUnsubscribed) {
	                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
	                    }
	                })
	                    .then(null, function (err) {
	                    // escape the promise trap, throw unhandled errors
	                    root_1.root.setTimeout(function () { throw err; });
	                });
	            }
	        }
	    };
	    return PromiseObservable;
	}(Observable_1.Observable));
	exports.PromiseObservable = PromiseObservable;
	function dispatchNext(arg) {
	    var value = arg.value, subscriber = arg.subscriber;
	    if (!subscriber.isUnsubscribed) {
	        subscriber.next(value);
	        subscriber.complete();
	    }
	}
	function dispatchError(arg) {
	    var err = arg.err, subscriber = arg.subscriber;
	    if (!subscriber.isUnsubscribed) {
	        subscriber.error(err);
	    }
	}
	//# sourceMappingURL=PromiseObservable.js.map

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(40);
	/**
	 * @param PromiseCtor
	 * @return {Promise<T>}
	 * @method toPromise
	 * @owner Observable
	 */
	function toPromise(PromiseCtor) {
	    var _this = this;
	    if (!PromiseCtor) {
	        if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	            PromiseCtor = root_1.root.Rx.config.Promise;
	        }
	        else if (root_1.root.Promise) {
	            PromiseCtor = root_1.root.Promise;
	        }
	    }
	    if (!PromiseCtor) {
	        throw new Error('no Promise impl found');
	    }
	    return new PromiseCtor(function (resolve, reject) {
	        var value;
	        _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
	    });
	}
	exports.toPromise = toPromise;
	//# sourceMappingURL=toPromise.js.map

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(40);
	var Symbol = root_1.root.Symbol;
	if (typeof Symbol === 'function') {
	    if (Symbol.observable) {
	        exports.$$observable = Symbol.observable;
	    }
	    else {
	        if (typeof Symbol.for === 'function') {
	            exports.$$observable = Symbol.for('observable');
	        }
	        else {
	            exports.$$observable = Symbol('observable');
	        }
	        Symbol.observable = exports.$$observable;
	    }
	}
	else {
	    exports.$$observable = '@@observable';
	}
	//# sourceMappingURL=observable.js.map

/***/ },
/* 284 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an action is invalid because the object has been
	 * unsubscribed.
	 *
	 * @see {@link Subject}
	 * @see {@link BehaviorSubject}
	 *
	 * @class ObjectUnsubscribedError
	 */
	var ObjectUnsubscribedError = (function (_super) {
	    __extends(ObjectUnsubscribedError, _super);
	    function ObjectUnsubscribedError() {
	        _super.call(this, 'object unsubscribed');
	        this.name = 'ObjectUnsubscribedError';
	    }
	    return ObjectUnsubscribedError;
	}(Error));
	exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
	//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ },
/* 285 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = (function (_super) {
	    __extends(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        this.name = 'UnsubscriptionError';
	        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n') : '';
	    }
	    return UnsubscriptionError;
	}(Error));
	exports.UnsubscriptionError = UnsubscriptionError;
	//# sourceMappingURL=UnsubscriptionError.js.map

/***/ },
/* 286 */
/***/ function(module, exports) {

	"use strict";
	exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArray.js.map

/***/ },
/* 287 */
/***/ function(module, exports) {

	"use strict";
	function isObject(x) {
	    return x != null && typeof x === 'object';
	}
	exports.isObject = isObject;
	//# sourceMappingURL=isObject.js.map

/***/ },
/* 288 */
/***/ function(module, exports) {

	"use strict";
	function throwError(e) { throw e; }
	exports.throwError = throwError;
	//# sourceMappingURL=throwError.js.map

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(194);
	var rxSubscriber_1 = __webpack_require__(114);
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver && typeof nextOrObserver === 'object') {
	        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
	            return nextOrObserver;
	        }
	        else if (typeof nextOrObserver[rxSubscriber_1.$$rxSubscriber] === 'function') {
	            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
	        }
	    }
	    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	}
	exports.toSubscriber = toSubscriber;
	//# sourceMappingURL=toSubscriber.js.map

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var errorObject_1 = __webpack_require__(195);
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1.errorObject.e = e;
	        return errorObject_1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	exports.tryCatch = tryCatch;
	;
	//# sourceMappingURL=tryCatch.js.map

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
		if (true) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof module !== 'undefined' && module.exports){
			module.exports = factory();
		} else {
			global.UriTemplate = factory();
		}
	})(this, function () {
		var uriTemplateGlobalModifiers = {
			"+": true,
			"#": true,
			".": true,
			"/": true,
			";": true,
			"?": true,
			"&": true
		};
		var uriTemplateSuffices = {
			"*": true
		};
		var urlEscapedChars = /[:/&?#]/;

		function notReallyPercentEncode(string) {
			return encodeURI(string).replace(/%25[0-9][0-9]/g, function (doubleEncoded) {
				return "%" + doubleEncoded.substring(3);
			});
		}

		function isPercentEncoded(string) {
			string = string.replace(/%../g, '');
			return encodeURIComponent(string) === string;
		}

		function uriTemplateSubstitution(spec) {
			var modifier = "";
			if (uriTemplateGlobalModifiers[spec.charAt(0)]) {
				modifier = spec.charAt(0);
				spec = spec.substring(1);
			}
			var separator = "";
			var prefix = "";
			var shouldEscape = true;
			var showVariables = false;
			var trimEmptyString = false;
			if (modifier == '+') {
				shouldEscape = false;
			} else if (modifier == ".") {
				prefix = ".";
				separator = ".";
			} else if (modifier == "/") {
				prefix = "/";
				separator = "/";
			} else if (modifier == '#') {
				prefix = "#";
				shouldEscape = false;
			} else if (modifier == ';') {
				prefix = ";";
				separator = ";",
				showVariables = true;
				trimEmptyString = true;
			} else if (modifier == '?') {
				prefix = "?";
				separator = "&",
				showVariables = true;
			} else if (modifier == '&') {
				prefix = "&";
				separator = "&",
				showVariables = true;
			}

			var varNames = [];
			var varList = spec.split(",");
			var varSpecs = [];
			var varSpecMap = {};
			for (var i = 0; i < varList.length; i++) {
				var varName = varList[i];
				var truncate = null;
				if (varName.indexOf(":") != -1) {
					var parts = varName.split(":");
					varName = parts[0];
					truncate = parseInt(parts[1]);
				}
				var suffices = {};
				while (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {
					suffices[varName.charAt(varName.length - 1)] = true;
					varName = varName.substring(0, varName.length - 1);
				}
				var varSpec = {
					truncate: truncate,
					name: varName,
					suffices: suffices
				};
				varSpecs.push(varSpec);
				varSpecMap[varName] = varSpec;
				varNames.push(varName);
			}
			var subFunction = function (valueFunction) {
				var result = "";
				var startIndex = 0;
				for (var i = 0; i < varSpecs.length; i++) {
					var varSpec = varSpecs[i];
					var value = valueFunction(varSpec.name);
					if (value == null || (Array.isArray(value) && value.length == 0) || (typeof value == 'object' && Object.keys(value).length == 0)) {
						startIndex++;
						continue;
					}
					if (i == startIndex) {
						result += prefix;
					} else {
						result += (separator || ",");
					}
					if (Array.isArray(value)) {
						if (showVariables) {
							result += varSpec.name + "=";
						}
						for (var j = 0; j < value.length; j++) {
							if (j > 0) {
								result += varSpec.suffices['*'] ? (separator || ",") : ",";
								if (varSpec.suffices['*'] && showVariables) {
									result += varSpec.name + "=";
								}
							}
							result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, "%21") : notReallyPercentEncode(value[j]);
						}
					} else if (typeof value == "object") {
						if (showVariables && !varSpec.suffices['*']) {
							result += varSpec.name + "=";
						}
						var first = true;
						for (var key in value) {
							if (!first) {
								result += varSpec.suffices['*'] ? (separator || ",") : ",";
							}
							first = false;
							result += shouldEscape ? encodeURIComponent(key).replace(/!/g, "%21") : notReallyPercentEncode(key);
							result += varSpec.suffices['*'] ? '=' : ",";
							result += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, "%21") : notReallyPercentEncode(value[key]);
						}
					} else {
						if (showVariables) {
							result += varSpec.name;
							if (!trimEmptyString || value != "") {
								result += "=";
							}
						}
						if (varSpec.truncate != null) {
							value = value.substring(0, varSpec.truncate);
						}
						result += shouldEscape ? encodeURIComponent(value).replace(/!/g, "%21"): notReallyPercentEncode(value);
					}
				}
				return result;
			};
			var guessFunction = function (stringValue, resultObj, strict) {
				if (prefix) {
					stringValue = stringValue.substring(prefix.length);
				}
				if (varSpecs.length == 1 && varSpecs[0].suffices['*']) {
					var varSpec = varSpecs[0];
					var varName = varSpec.name;
					var arrayValue = varSpec.suffices['*'] ? stringValue.split(separator || ",") : [stringValue];
					var hasEquals = (shouldEscape && stringValue.indexOf('=') != -1);	// There's otherwise no way to distinguish between "{value*}" for arrays and objects
					for (var i = 1; i < arrayValue.length; i++) {
						var stringValue = arrayValue[i];
						if (hasEquals && stringValue.indexOf('=') == -1) {
							// Bit of a hack - if we're expecting "=" for key/value pairs, and values can't contain "=", then assume a value has been accidentally split
							arrayValue[i - 1] += (separator || ",") + stringValue;
							arrayValue.splice(i, 1);
							i--;
						}
					}
					for (var i = 0; i < arrayValue.length; i++) {
						var stringValue = arrayValue[i];
						if (shouldEscape && stringValue.indexOf('=') != -1) {
							hasEquals = true;
						}
						var innerArrayValue = stringValue.split(",");
						if (innerArrayValue.length == 1) {
							arrayValue[i] = innerArrayValue[0];
						} else {
							arrayValue[i] = innerArrayValue;
						}
					}

					if (showVariables || hasEquals) {
						var objectValue = resultObj[varName] || {};
						for (var j = 0; j < arrayValue.length; j++) {
							var innerValue = stringValue;
							if (showVariables && !innerValue) {
								// The empty string isn't a valid variable, so if our value is zero-length we have nothing
								continue;
							}
							if (typeof arrayValue[j] == "string") {
								var stringValue = arrayValue[j];
								var innerVarName = stringValue.split("=", 1)[0];
								var stringValue = stringValue.substring(innerVarName.length + 1);
								if (shouldEscape) {
									if (strict && !isPercentEncoded(stringValue)) {
										return;
									}
									stringValue = decodeURIComponent(stringValue);
								}
								innerValue = stringValue;
							} else {
								var stringValue = arrayValue[j][0];
								var innerVarName = stringValue.split("=", 1)[0];
								var stringValue = stringValue.substring(innerVarName.length + 1);
								if (shouldEscape) {
									if (strict && !isPercentEncoded(stringValue)) {
										return;
									}
									stringValue = decodeURIComponent(stringValue);
								}
								arrayValue[j][0] = stringValue;
								innerValue = arrayValue[j];
							}
							if (shouldEscape) {
								if (strict && !isPercentEncoded(innerVarName)) {
									return;
								}
								innerVarName = decodeURIComponent(innerVarName);
							}

							if (objectValue[innerVarName] !== undefined) {
								if (Array.isArray(objectValue[innerVarName])) {
									objectValue[innerVarName].push(innerValue);
								} else {
									objectValue[innerVarName] = [objectValue[innerVarName], innerValue];
								}
							} else {
								objectValue[innerVarName] = innerValue;
							}
						}
						if (Object.keys(objectValue).length == 1 && objectValue[varName] !== undefined) {
							resultObj[varName] = objectValue[varName];
						} else {
							resultObj[varName] = objectValue;
						}
					} else {
						if (shouldEscape) {
							for (var j = 0; j < arrayValue.length; j++) {
								var innerArrayValue = arrayValue[j];
								if (Array.isArray(innerArrayValue)) {
									for (var k = 0; k < innerArrayValue.length; k++) {
										if (strict && !isPercentEncoded(innerArrayValue[k])) {
											return;
										}
										innerArrayValue[k] = decodeURIComponent(innerArrayValue[k]);
									}
								} else {
									if (strict && !isPercentEncoded(innerArrayValue)) {
										return;
									}
									arrayValue[j] = decodeURIComponent(innerArrayValue);
								}
							}
						}

						if (resultObj[varName] !== undefined) {
							if (Array.isArray(resultObj[varName])) {
								resultObj[varName] = resultObj[varName].concat(arrayValue);
							} else {
								resultObj[varName] = [resultObj[varName]].concat(arrayValue);
							}
						} else {
							if (arrayValue.length == 1 && !varSpec.suffices['*']) {
								resultObj[varName] = arrayValue[0];
							} else {
								resultObj[varName] = arrayValue;
							}
						}
					}
				} else {
					var arrayValue = (varSpecs.length == 1) ? [stringValue] : stringValue.split(separator || ",");
					var specIndexMap = {};
					for (var i = 0; i < arrayValue.length; i++) {
						// Try from beginning
						var firstStarred = 0;
						for (; firstStarred < varSpecs.length - 1 && firstStarred < i; firstStarred++) {
							if (varSpecs[firstStarred].suffices['*']) {
								break;
							}
						}
						if (firstStarred == i) {
							// The first [i] of them have no "*" suffix
							specIndexMap[i] = i;
							continue;
						} else {
							// Try from the end
							for (var lastStarred = varSpecs.length - 1; lastStarred > 0 && (varSpecs.length - lastStarred) < (arrayValue.length - i); lastStarred--) {
								if (varSpecs[lastStarred].suffices['*']) {
									break;
								}
							}
							if ((varSpecs.length - lastStarred) == (arrayValue.length - i)) {
								// The last [length - i] of them have no "*" suffix
								specIndexMap[i] = lastStarred;
								continue;
							}
						}
						// Just give up and use the first one
						specIndexMap[i] = firstStarred;
					}
					for (var i = 0; i < arrayValue.length; i++) {
						var stringValue = arrayValue[i];
						if (!stringValue && showVariables) {
							// The empty string isn't a valid variable, so if our value is zero-length we have nothing
							continue;
						}
						var innerArrayValue = stringValue.split(",");
						var hasEquals = false;

						if (showVariables) {
							var stringValue = innerArrayValue[0]; // using innerArrayValue
							var varName = stringValue.split("=", 1)[0];
							var stringValue = stringValue.substring(varName.length + 1);
							innerArrayValue[0] = stringValue;
							var varSpec = varSpecMap[varName] || varSpecs[0];
						} else {
							var varSpec = varSpecs[specIndexMap[i]];
							var varName = varSpec.name;
						}

						for (var j = 0; j < innerArrayValue.length; j++) {
							if (shouldEscape) {
								if (strict && !isPercentEncoded(innerArrayValue[j])) {
									return;
								}
								innerArrayValue[j] = decodeURIComponent(innerArrayValue[j]);
							}
						}

						if ((showVariables || varSpec.suffices['*'])&& resultObj[varName] !== undefined) {
							if (Array.isArray(resultObj[varName])) {
								resultObj[varName] = resultObj[varName].concat(innerArrayValue);
							} else {
								resultObj[varName] = [resultObj[varName]].concat(innerArrayValue);
							}
						} else {
							if (innerArrayValue.length == 1 && !varSpec.suffices['*']) {
								resultObj[varName] = innerArrayValue[0];
							} else {
								resultObj[varName] = innerArrayValue;
							}
						}
					}
				}
				return 1;
			};
			return {
				varNames: varNames,
				prefix: prefix,
				substitution: subFunction,
				unSubstitution: guessFunction
			};
		}

		function UriTemplate(template) {
			if (!(this instanceof UriTemplate)) {
				return new UriTemplate(template);
			}
			var parts = template.split("{");
			var textParts = [parts.shift()];
			var prefixes = [];
			var substitutions = [];
			var unSubstitutions = [];
			var varNames = [];
			while (parts.length > 0) {
				var part = parts.shift();
				var spec = part.split("}")[0];
				var remainder = part.substring(spec.length + 1);
				var funcs = uriTemplateSubstitution(spec);
				substitutions.push(funcs.substitution);
				unSubstitutions.push(funcs.unSubstitution);
				prefixes.push(funcs.prefix);
				textParts.push(remainder);
				varNames = varNames.concat(funcs.varNames);
			}
			this.fill = function (valueFunction) {
				if (valueFunction && typeof valueFunction !== 'function') {
					var value = valueFunction;
					valueFunction = function (varName) {
						return value[varName];
					};
				}

				var result = textParts[0];
				for (var i = 0; i < substitutions.length; i++) {
					var substitution = substitutions[i];
					result += substitution(valueFunction);
					result += textParts[i + 1];
				}
				return result;
			};
			this.fromUri = function (substituted, options) {
				options = options || {};
				var result = {};
				for (var i = 0; i < textParts.length; i++) {
					var part = textParts[i];
					if (substituted.substring(0, part.length) !== part) {
						return /*undefined*/;
					}
					substituted = substituted.substring(part.length);
					if (i >= textParts.length - 1) {
						// We've run out of input - is there any template left?
						if (substituted == "") {
							break;
						} else {
							return /*undefined*/;
						}
					}

					var prefix = prefixes[i];
					if (prefix && substituted.substring(0, prefix.length) !== prefix) {
						// All values are optional - if we have a prefix and it doesn't match, move along
						continue;
					}

					// Find the next part to un-substitute
					var nextPart = textParts[i + 1];
					var offset = i;
					while (true) {
						if (offset == textParts.length - 2) {
							var endPart = substituted.substring(substituted.length - nextPart.length);
							if (endPart !== nextPart) {
								return /*undefined*/;
							}
							var stringValue = substituted.substring(0, substituted.length - nextPart.length);
							substituted = endPart;
						} else if (nextPart) {
							var nextPartPos = substituted.indexOf(nextPart);
							var stringValue = substituted.substring(0, nextPartPos);
							substituted = substituted.substring(nextPartPos);
						} else if (prefixes[offset + 1]) {
							var nextPartPos = substituted.indexOf(prefixes[offset + 1]);
							if (nextPartPos === -1) nextPartPos = substituted.length;
							var stringValue = substituted.substring(0, nextPartPos);
							substituted = substituted.substring(nextPartPos);
						} else if (textParts.length > offset + 2) {
							// If the separator between this variable and the next is blank (with no prefix), continue onwards
							offset++;
							nextPart = textParts[offset + 1];
							continue;
						} else {
							var stringValue = substituted;
							substituted = "";
						}
						break;
					}
					if (!unSubstitutions[i](stringValue, result, options.strict)) {
						return /*undefined*/;
					}
				}
				return result;
			}
			this.varNames = varNames;
			this.template = template;
		}
		UriTemplate.prototype = {
			toString: function () {
				return this.template;
			},
			fillFromObject: function (obj) {
				return this.fill(obj);
			},
			test: function (uri, options) {
				return !!this.fromUri(uri, options)
			}
		};

		return UriTemplate;
	});


/***/ },
/* 292 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var lang_1 = __webpack_require__(__webpack_module_template_argument_0__);
	exports.Map = lang_1.global.Map;
	exports.Set = lang_1.global.Set;
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Map constructor.  We work around that by manually adding the items.
	var createMapFromPairs = (function () {
	    try {
	        if (new exports.Map([[1, 2]]).size === 1) {
	            return function createMapFromPairs(pairs) { return new exports.Map(pairs); };
	        }
	    }
	    catch (e) {
	    }
	    return function createMapAndPopulateFromPairs(pairs) {
	        var map = new exports.Map();
	        for (var i = 0; i < pairs.length; i++) {
	            var pair = pairs[i];
	            map.set(pair[0], pair[1]);
	        }
	        return map;
	    };
	})();
	var createMapFromMap = (function () {
	    try {
	        if (new exports.Map(new exports.Map())) {
	            return function createMapFromMap(m) { return new exports.Map(m); };
	        }
	    }
	    catch (e) {
	    }
	    return function createMapAndPopulateFromMap(m) {
	        var map = new exports.Map();
	        m.forEach(function (v, k) { map.set(k, v); });
	        return map;
	    };
	})();
	var _clearValues = (function () {
	    if ((new exports.Map()).keys().next) {
	        return function _clearValues(m) {
	            var keyIterator = m.keys();
	            var k;
	            while (!((k = keyIterator.next()).done)) {
	                m.set(k.value, null);
	            }
	        };
	    }
	    else {
	        return function _clearValuesWithForeEach(m) {
	            m.forEach(function (v, k) { m.set(k, null); });
	        };
	    }
	})();
	// Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
	// TODO(mlaval): remove the work around once we have a working polyfill of Array.from
	var _arrayFromMap = (function () {
	    try {
	        if ((new exports.Map()).values().next) {
	            return function createArrayFromMap(m, getValues) {
	                return getValues ? Array.from(m.values()) : Array.from(m.keys());
	            };
	        }
	    }
	    catch (e) {
	    }
	    return function createArrayFromMapWithForeach(m, getValues) {
	        var res = ListWrapper.createFixedSize(m.size), i = 0;
	        m.forEach(function (v, k) {
	            res[i] = getValues ? v : k;
	            i++;
	        });
	        return res;
	    };
	})();
	var MapWrapper = (function () {
	    function MapWrapper() {
	    }
	    MapWrapper.clone = function (m) { return createMapFromMap(m); };
	    MapWrapper.createFromStringMap = function (stringMap) {
	        var result = new exports.Map();
	        for (var prop in stringMap) {
	            result.set(prop, stringMap[prop]);
	        }
	        return result;
	    };
	    MapWrapper.toStringMap = function (m) {
	        var r = {};
	        m.forEach(function (v, k) { return r[k] = v; });
	        return r;
	    };
	    MapWrapper.createFromPairs = function (pairs) { return createMapFromPairs(pairs); };
	    MapWrapper.clearValues = function (m) { _clearValues(m); };
	    MapWrapper.iterable = function (m) { return m; };
	    MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };
	    MapWrapper.values = function (m) { return _arrayFromMap(m, true); };
	    return MapWrapper;
	}());
	exports.MapWrapper = MapWrapper;
	/**
	 * Wraps Javascript Objects
	 */
	var StringMapWrapper = (function () {
	    function StringMapWrapper() {
	    }
	    StringMapWrapper.create = function () {
	        // Note: We are not using Object.create(null) here due to
	        // performance!
	        // http://jsperf.com/ng2-object-create-null
	        return {};
	    };
	    StringMapWrapper.contains = function (map, key) {
	        return map.hasOwnProperty(key);
	    };
	    StringMapWrapper.get = function (map, key) {
	        return map.hasOwnProperty(key) ? map[key] : undefined;
	    };
	    StringMapWrapper.set = function (map, key, value) { map[key] = value; };
	    StringMapWrapper.keys = function (map) { return Object.keys(map); };
	    StringMapWrapper.values = function (map) {
	        return Object.keys(map).map(function (k) { return map[k]; });
	    };
	    StringMapWrapper.isEmpty = function (map) {
	        for (var prop in map) {
	            return false;
	        }
	        return true;
	    };
	    StringMapWrapper.delete = function (map, key) { delete map[key]; };
	    StringMapWrapper.forEach = function (map, callback) {
	        for (var _i = 0, _a = Object.keys(map); _i < _a.length; _i++) {
	            var k = _a[_i];
	            callback(map[k], k);
	        }
	    };
	    StringMapWrapper.merge = function (m1, m2) {
	        var m = {};
	        for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
	            var k = _a[_i];
	            m[k] = m1[k];
	        }
	        for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
	            var k = _c[_b];
	            m[k] = m2[k];
	        }
	        return m;
	    };
	    StringMapWrapper.equals = function (m1, m2) {
	        var k1 = Object.keys(m1);
	        var k2 = Object.keys(m2);
	        if (k1.length != k2.length) {
	            return false;
	        }
	        var key;
	        for (var i = 0; i < k1.length; i++) {
	            key = k1[i];
	            if (m1[key] !== m2[key]) {
	                return false;
	            }
	        }
	        return true;
	    };
	    return StringMapWrapper;
	}());
	exports.StringMapWrapper = StringMapWrapper;
	var ListWrapper = (function () {
	    function ListWrapper() {
	    }
	    // JS has no way to express a statically fixed size list, but dart does so we
	    // keep both methods.
	    ListWrapper.createFixedSize = function (size) { return new Array(size); };
	    ListWrapper.createGrowableSize = function (size) { return new Array(size); };
	    ListWrapper.clone = function (array) { return array.slice(0); };
	    ListWrapper.forEachWithIndex = function (array, fn) {
	        for (var i = 0; i < array.length; i++) {
	            fn(array[i], i);
	        }
	    };
	    ListWrapper.first = function (array) {
	        if (!array)
	            return null;
	        return array[0];
	    };
	    ListWrapper.last = function (array) {
	        if (!array || array.length == 0)
	            return null;
	        return array[array.length - 1];
	    };
	    ListWrapper.indexOf = function (array, value, startIndex) {
	        if (startIndex === void 0) { startIndex = 0; }
	        return array.indexOf(value, startIndex);
	    };
	    ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };
	    ListWrapper.reversed = function (array) {
	        var a = ListWrapper.clone(array);
	        return a.reverse();
	    };
	    ListWrapper.concat = function (a, b) { return a.concat(b); };
	    ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };
	    ListWrapper.removeAt = function (list, index) {
	        var res = list[index];
	        list.splice(index, 1);
	        return res;
	    };
	    ListWrapper.removeAll = function (list, items) {
	        for (var i = 0; i < items.length; ++i) {
	            var index = list.indexOf(items[i]);
	            list.splice(index, 1);
	        }
	    };
	    ListWrapper.remove = function (list, el) {
	        var index = list.indexOf(el);
	        if (index > -1) {
	            list.splice(index, 1);
	            return true;
	        }
	        return false;
	    };
	    ListWrapper.clear = function (list) { list.length = 0; };
	    ListWrapper.isEmpty = function (list) { return list.length == 0; };
	    ListWrapper.fill = function (list, value, start, end) {
	        if (start === void 0) { start = 0; }
	        if (end === void 0) { end = null; }
	        list.fill(value, start, end === null ? list.length : end);
	    };
	    ListWrapper.equals = function (a, b) {
	        if (a.length != b.length)
	            return false;
	        for (var i = 0; i < a.length; ++i) {
	            if (a[i] !== b[i])
	                return false;
	        }
	        return true;
	    };
	    ListWrapper.slice = function (l, from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = null; }
	        return l.slice(from, to === null ? undefined : to);
	    };
	    ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };
	    ListWrapper.sort = function (l, compareFn) {
	        if (lang_1.isPresent(compareFn)) {
	            l.sort(compareFn);
	        }
	        else {
	            l.sort();
	        }
	    };
	    ListWrapper.toString = function (l) { return l.toString(); };
	    ListWrapper.toJSON = function (l) { return JSON.stringify(l); };
	    ListWrapper.maximum = function (list, predicate) {
	        if (list.length == 0) {
	            return null;
	        }
	        var solution = null;
	        var maxValue = -Infinity;
	        for (var index = 0; index < list.length; index++) {
	            var candidate = list[index];
	            if (lang_1.isBlank(candidate)) {
	                continue;
	            }
	            var candidateValue = predicate(candidate);
	            if (candidateValue > maxValue) {
	                solution = candidate;
	                maxValue = candidateValue;
	            }
	        }
	        return solution;
	    };
	    ListWrapper.flatten = function (list) {
	        var target = [];
	        _flattenArray(list, target);
	        return target;
	    };
	    ListWrapper.addAll = function (list, source) {
	        for (var i = 0; i < source.length; i++) {
	            list.push(source[i]);
	        }
	    };
	    return ListWrapper;
	}());
	exports.ListWrapper = ListWrapper;
	function _flattenArray(source, target) {
	    if (lang_1.isPresent(source)) {
	        for (var i = 0; i < source.length; i++) {
	            var item = source[i];
	            if (lang_1.isArray(item)) {
	                _flattenArray(item, target);
	            }
	            else {
	                target.push(item);
	            }
	        }
	    }
	    return target;
	}
	function isListLikeIterable(obj) {
	    if (!lang_1.isJsObject(obj))
	        return false;
	    return lang_1.isArray(obj) ||
	        (!(obj instanceof exports.Map) &&
	            lang_1.getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
	}
	exports.isListLikeIterable = isListLikeIterable;
	function areIterablesEqual(a, b, comparator) {
	    var iterator1 = a[lang_1.getSymbolIterator()]();
	    var iterator2 = b[lang_1.getSymbolIterator()]();
	    while (true) {
	        var item1 = iterator1.next();
	        var item2 = iterator2.next();
	        if (item1.done && item2.done)
	            return true;
	        if (item1.done || item2.done)
	            return false;
	        if (!comparator(item1.value, item2.value))
	            return false;
	    }
	}
	exports.areIterablesEqual = areIterablesEqual;
	function iterateListLike(obj, fn) {
	    if (lang_1.isArray(obj)) {
	        for (var i = 0; i < obj.length; i++) {
	            fn(obj[i]);
	        }
	    }
	    else {
	        var iterator = obj[lang_1.getSymbolIterator()]();
	        var item;
	        while (!((item = iterator.next()).done)) {
	            fn(item.value);
	        }
	    }
	}
	exports.iterateListLike = iterateListLike;
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Set constructor.  We work around that by manually adding the items.
	var createSetFromList = (function () {
	    var test = new exports.Set([1, 2, 3]);
	    if (test.size === 3) {
	        return function createSetFromList(lst) { return new exports.Set(lst); };
	    }
	    else {
	        return function createSetAndPopulateFromList(lst) {
	            var res = new exports.Set(lst);
	            if (res.size !== lst.length) {
	                for (var i = 0; i < lst.length; i++) {
	                    res.add(lst[i]);
	                }
	            }
	            return res;
	        };
	    }
	})();
	var SetWrapper = (function () {
	    function SetWrapper() {
	    }
	    SetWrapper.createFromList = function (lst) { return createSetFromList(lst); };
	    SetWrapper.has = function (s, key) { return s.has(key); };
	    SetWrapper.delete = function (m, k) { m.delete(k); };
	    return SetWrapper;
	}());
	exports.SetWrapper = SetWrapper;
	//# sourceMappingURL=collection.js.map

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var base_wrapped_exception_1 = __webpack_require__(__webpack_module_template_argument_0__);
	var collection_1 = __webpack_require__(__webpack_module_template_argument_1__);
	var lang_1 = __webpack_require__(__webpack_module_template_argument_2__);
	var _ArrayLogger = (function () {
	    function _ArrayLogger() {
	        this.res = [];
	    }
	    _ArrayLogger.prototype.log = function (s) { this.res.push(s); };
	    _ArrayLogger.prototype.logError = function (s) { this.res.push(s); };
	    _ArrayLogger.prototype.logGroup = function (s) { this.res.push(s); };
	    _ArrayLogger.prototype.logGroupEnd = function () { };
	    ;
	    return _ArrayLogger;
	}());
	/**
	 * Provides a hook for centralized exception handling.
	 *
	 * The default implementation of `ExceptionHandler` prints error messages to the `Console`. To
	 * intercept error handling,
	 * write a custom exception handler that replaces this default as appropriate for your app.
	 *
	 * ### Example
	 *
	 * ```javascript
	 *
	 * class MyExceptionHandler implements ExceptionHandler {
	 *   call(error, stackTrace = null, reason = null) {
	 *     // do something with the exception
	 *   }
	 * }
	 *
	 * bootstrap(MyApp, [{provide: ExceptionHandler, useClass: MyExceptionHandler}])
	 *
	 * ```
	 * @stable
	 */
	var ExceptionHandler = (function () {
	    function ExceptionHandler(_logger, _rethrowException) {
	        if (_rethrowException === void 0) { _rethrowException = true; }
	        this._logger = _logger;
	        this._rethrowException = _rethrowException;
	    }
	    ExceptionHandler.exceptionToString = function (exception, stackTrace, reason) {
	        if (stackTrace === void 0) { stackTrace = null; }
	        if (reason === void 0) { reason = null; }
	        var l = new _ArrayLogger();
	        var e = new ExceptionHandler(l, false);
	        e.call(exception, stackTrace, reason);
	        return l.res.join('\n');
	    };
	    ExceptionHandler.prototype.call = function (exception, stackTrace, reason) {
	        if (stackTrace === void 0) { stackTrace = null; }
	        if (reason === void 0) { reason = null; }
	        var originalException = this._findOriginalException(exception);
	        var originalStack = this._findOriginalStack(exception);
	        var context = this._findContext(exception);
	        this._logger.logGroup("EXCEPTION: " + this._extractMessage(exception));
	        if (lang_1.isPresent(stackTrace) && lang_1.isBlank(originalStack)) {
	            this._logger.logError('STACKTRACE:');
	            this._logger.logError(this._longStackTrace(stackTrace));
	        }
	        if (lang_1.isPresent(reason)) {
	            this._logger.logError("REASON: " + reason);
	        }
	        if (lang_1.isPresent(originalException)) {
	            this._logger.logError("ORIGINAL EXCEPTION: " + this._extractMessage(originalException));
	        }
	        if (lang_1.isPresent(originalStack)) {
	            this._logger.logError('ORIGINAL STACKTRACE:');
	            this._logger.logError(this._longStackTrace(originalStack));
	        }
	        if (lang_1.isPresent(context)) {
	            this._logger.logError('ERROR CONTEXT:');
	            this._logger.logError(context);
	        }
	        this._logger.logGroupEnd();
	        // We rethrow exceptions, so operations like 'bootstrap' will result in an error
	        // when an exception happens. If we do not rethrow, bootstrap will always succeed.
	        if (this._rethrowException)
	            throw exception;
	    };
	    /** @internal */
	    ExceptionHandler.prototype._extractMessage = function (exception) {
	        return exception instanceof base_wrapped_exception_1.BaseWrappedException ? exception.wrapperMessage :
	            exception.toString();
	    };
	    /** @internal */
	    ExceptionHandler.prototype._longStackTrace = function (stackTrace) {
	        return collection_1.isListLikeIterable(stackTrace) ? stackTrace.join('\n\n-----async gap-----\n') :
	            stackTrace.toString();
	    };
	    /** @internal */
	    ExceptionHandler.prototype._findContext = function (exception) {
	        try {
	            if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
	                return null;
	            return lang_1.isPresent(exception.context) ? exception.context :
	                this._findContext(exception.originalException);
	        }
	        catch (e) {
	            // exception.context can throw an exception. if it happens, we ignore the context.
	            return null;
	        }
	    };
	    /** @internal */
	    ExceptionHandler.prototype._findOriginalException = function (exception) {
	        if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
	            return null;
	        var e = exception.originalException;
	        while (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
	            e = e.originalException;
	        }
	        return e;
	    };
	    /** @internal */
	    ExceptionHandler.prototype._findOriginalStack = function (exception) {
	        if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
	            return null;
	        var e = exception;
	        var stack = exception.originalStack;
	        while (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
	            e = e.originalException;
	            if (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
	                stack = e.originalStack;
	            }
	        }
	        return stack;
	    };
	    return ExceptionHandler;
	}());
	exports.ExceptionHandler = ExceptionHandler;
	//# sourceMappingURL=exception_handler.js.map

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var base_wrapped_exception_1 = __webpack_require__(__webpack_module_template_argument_0__);
	var exception_handler_1 = __webpack_require__(__webpack_module_template_argument_1__);
	var exception_handler_2 = __webpack_require__(__webpack_module_template_argument_2__);
	exports.ExceptionHandler = exception_handler_2.ExceptionHandler;
	/**
	 * @stable
	 */
	var BaseException = (function (_super) {
	    __extends(BaseException, _super);
	    function BaseException(message) {
	        if (message === void 0) { message = '--'; }
	        _super.call(this, message);
	        this.message = message;
	        this.stack = (new Error(message)).stack;
	    }
	    BaseException.prototype.toString = function () { return this.message; };
	    return BaseException;
	}(Error));
	exports.BaseException = BaseException;
	/**
	 * Wraps an exception and provides additional context or information.
	 * @stable
	 */
	var WrappedException = (function (_super) {
	    __extends(WrappedException, _super);
	    function WrappedException(_wrapperMessage, _originalException /** TODO #9100 */, _originalStack /** TODO #9100 */, _context /** TODO #9100 */) {
	        _super.call(this, _wrapperMessage);
	        this._wrapperMessage = _wrapperMessage;
	        this._originalException = _originalException;
	        this._originalStack = _originalStack;
	        this._context = _context;
	        this._wrapperStack = (new Error(_wrapperMessage)).stack;
	    }
	    Object.defineProperty(WrappedException.prototype, "wrapperMessage", {
	        get: function () { return this._wrapperMessage; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WrappedException.prototype, "wrapperStack", {
	        get: function () { return this._wrapperStack; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WrappedException.prototype, "originalException", {
	        get: function () { return this._originalException; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WrappedException.prototype, "originalStack", {
	        get: function () { return this._originalStack; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WrappedException.prototype, "context", {
	        get: function () { return this._context; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WrappedException.prototype, "message", {
	        get: function () { return exception_handler_1.ExceptionHandler.exceptionToString(this); },
	        enumerable: true,
	        configurable: true
	    });
	    WrappedException.prototype.toString = function () { return this.message; };
	    return WrappedException;
	}(base_wrapped_exception_1.BaseWrappedException));
	exports.WrappedException = WrappedException;
	function makeTypeError(message) {
	    return new TypeError(message);
	}
	exports.makeTypeError = makeTypeError;
	function unimplemented() {
	    throw new BaseException('unimplemented');
	}
	exports.unimplemented = unimplemented;
	//# sourceMappingURL=exceptions.js.map

/***/ }
/******/ ])));